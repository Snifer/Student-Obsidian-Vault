/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target2) => __defProp(target2, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target2[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target2[prop] = source[prop];
    }
  return target2;
};
var __export = (target2, all) => {
  __markAsModule(target2);
  for (var name in all)
    __defProp(target2, name, { get: all[name], enumerable: true });
};
var __reExport = (target2, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target2, key) && key !== "default")
        __defProp(target2, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target2;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => DatabasePlugin
});
var import_obsidian5 = __toModule(require("obsidian"));
var import_obsidian6 = __toModule(require("obsidian"));
var import_obsidian7 = __toModule(require("obsidian"));

// node_modules/vue/dist/vue.runtime.esm.js
var emptyObject = Object.freeze({});
function isUndef(v) {
  return v === void 0 || v === null;
}
function isDef(v) {
  return v !== void 0 && v !== null;
}
function isTrue(v) {
  return v === true;
}
function isFalse(v) {
  return v === false;
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
var _toString = Object.prototype.toString;
function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
function isPlainObject(obj) {
  return _toString.call(obj) === "[object Object]";
}
function isRegExp(v) {
  return _toString.call(v) === "[object RegExp]";
}
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
  return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
}
function toString(val) {
  return val == null ? "" : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(",");
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function(val) {
    return map[val.toLowerCase()];
  } : function(val) {
    return map[val];
  };
}
var isBuiltInTag = makeMap("slot,component", true);
var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
function remove(arr, item) {
  if (arr.length) {
    var index2 = arr.indexOf(item);
    if (index2 > -1) {
      return arr.splice(index2, 1);
    }
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function cached(fn) {
  var cache3 = Object.create(null);
  return function cachedFn(str) {
    var hit = cache3[str];
    return hit || (cache3[str] = fn(str));
  };
}
var camelizeRE = /-(\w)/g;
var camelize = cached(function(str) {
  return str.replace(camelizeRE, function(_, c) {
    return c ? c.toUpperCase() : "";
  });
});
var capitalize = cached(function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
});
function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  boundFn._length = fn.length;
  return boundFn;
}
function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}
var bind = Function.prototype.bind ? nativeBind : polyfillBind;
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}
function noop(a, b, c) {
}
var no = function(a, b, c) {
  return false;
};
var identity = function(_) {
  return _;
};
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function(e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function(key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}
function once(fn) {
  var called = false;
  return function() {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}
var SSR_ATTR = "data-server-rendered";
var ASSET_TYPES = [
  "component",
  "directive",
  "filter"
];
var LIFECYCLE_HOOKS = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch"
];
var config = {
  optionMergeStrategies: Object.create(null),
  silent: false,
  productionTip: true,
  devtools: true,
  performance: false,
  errorHandler: null,
  warnHandler: null,
  ignoredElements: [],
  keyCodes: Object.create(null),
  isReservedTag: no,
  isReservedAttr: no,
  isUnknownElement: no,
  getTagNamespace: noop,
  parsePlatformTagName: identity,
  mustUseProp: no,
  async: true,
  _lifecycleHooks: LIFECYCLE_HOOKS
};
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function isReserved(str) {
  var c = (str + "").charCodeAt(0);
  return c === 36 || c === 95;
}
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split(".");
  return function(obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}
var hasProto = "__proto__" in {};
var inBrowser = typeof window !== "undefined";
var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
var isEdge = UA && UA.indexOf("edge/") > 0;
var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
var nativeWatch = {}.watch;
var supportsPassive = false;
if (inBrowser) {
  try {
    opts = {};
    Object.defineProperty(opts, "passive", {
      get: function get3() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test-passive", null, opts);
  } catch (e) {
  }
}
var opts;
var _isServer;
var isServerRendering = function() {
  if (_isServer === void 0) {
    if (!inBrowser && !inWeex && typeof global !== "undefined") {
      _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function isNative(Ctor) {
  return typeof Ctor === "function" && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
var _Set;
if (typeof Set !== "undefined" && isNative(Set)) {
  _Set = Set;
} else {
  _Set = /* @__PURE__ */ function() {
    function Set2() {
      this.set = Object.create(null);
    }
    Set2.prototype.has = function has2(key) {
      return this.set[key] === true;
    };
    Set2.prototype.add = function add2(key) {
      this.set[key] = true;
    };
    Set2.prototype.clear = function clear() {
      this.set = Object.create(null);
    };
    return Set2;
  }();
}
var warn = noop;
var tip = noop;
var generateComponentTrace = noop;
var formatComponentName = noop;
if (true) {
  hasConsole = typeof console !== "undefined";
  classifyRE2 = /(?:^|[-_])(\w)/g;
  classify2 = function(str) {
    return str.replace(classifyRE2, function(c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, "");
  };
  warn = function(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : "";
    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };
  tip = function(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
    }
  };
  formatComponentName = function(vm, includeFile) {
    if (vm.$root === vm) {
      return "<Root>";
    }
    var options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }
    return (name ? "<" + classify2(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : "");
  };
  repeat = function(str, n) {
    var res = "";
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };
  generateComponentTrace = function(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return "\n\nfound in\n\n" + tree.map(function(vm2, i) {
        return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) + (Array.isArray(vm2) ? formatComponentName(vm2[0]) + "... (" + vm2[1] + " recursive calls)" : formatComponentName(vm2));
      }).join("\n");
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
var hasConsole;
var classifyRE2;
var classify2;
var repeat;
var uid = 0;
var Dep = function Dep2() {
  this.id = uid++;
  this.subs = [];
};
Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};
Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};
Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};
Dep.prototype.notify = function notify() {
  var subs = this.subs.slice();
  if (!config.async) {
    subs.sort(function(a, b) {
      return a.id - b.id;
    });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};
Dep.target = null;
var targetStack = [];
function pushTarget(target2) {
  targetStack.push(target2);
  Dep.target = target2;
}
function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
var VNode = function VNode2(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = void 0;
  this.context = context;
  this.fnContext = void 0;
  this.fnOptions = void 0;
  this.fnScopeId = void 0;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = void 0;
  this.parent = void 0;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = void 0;
  this.isAsyncPlaceholder = false;
};
var prototypeAccessors = { child: { configurable: true } };
prototypeAccessors.child.get = function() {
  return this.componentInstance;
};
Object.defineProperties(VNode.prototype, prototypeAccessors);
var createEmptyVNode = function(text) {
  if (text === void 0)
    text = "";
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};
function createTextVNode(val) {
  return new VNode(void 0, void 0, void 0, String(val));
}
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
methodsToPatch.forEach(function(method) {
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted4;
    switch (method) {
      case "push":
      case "unshift":
        inserted4 = args;
        break;
      case "splice":
        inserted4 = args.slice(2);
        break;
    }
    if (inserted4) {
      ob.observeArray(inserted4);
    }
    ob.dep.notify();
    return result;
  });
});
var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var shouldObserve = true;
function toggleObserving(value) {
  shouldObserve = value;
}
var Observer = function Observer2(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, "__ob__", this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
Observer.prototype.walk = function walk(obj) {
  var keys2 = Object.keys(obj);
  for (var i = 0; i < keys2.length; i++) {
    defineReactive$$1(obj, keys2[i]);
  }
};
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};
function protoAugment(target2, src) {
  target2.__proto__ = src;
}
function copyAugment(target2, src, keys2) {
  for (var i = 0, l = keys2.length; i < l; i++) {
    var key = keys2[i];
    def(target2, key, src[key]);
  }
}
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}
function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }
  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      if (customSetter) {
        customSetter();
      }
      if (getter && !setter) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
function set(target2, key, val) {
  if (isUndef(target2) || isPrimitive(target2)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target2);
  }
  if (Array.isArray(target2) && isValidArrayIndex(key)) {
    target2.length = Math.max(target2.length, key);
    target2.splice(key, 1, val);
    return val;
  }
  if (key in target2 && !(key in Object.prototype)) {
    target2[key] = val;
    return val;
  }
  var ob = target2.__ob__;
  if (target2._isVue || ob && ob.vmCount) {
    warn("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
    return val;
  }
  if (!ob) {
    target2[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
function del(target2, key) {
  if (isUndef(target2) || isPrimitive(target2)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target2);
  }
  if (Array.isArray(target2) && isValidArrayIndex(key)) {
    target2.splice(key, 1);
    return;
  }
  var ob = target2.__ob__;
  if (target2._isVue || ob && ob.vmCount) {
    warn("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
    return;
  }
  if (!hasOwn(target2, key)) {
    return;
  }
  delete target2[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
var strats = config.optionMergeStrategies;
if (true) {
  strats.el = strats.propsData = function(parent, child, vm, key) {
    if (!vm) {
      warn('option "' + key + '" can only be used during instance creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys2 = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
  for (var i = 0; i < keys2.length; i++) {
    key = keys2[i];
    if (key === "__ob__") {
      continue;
    }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    return function mergedDataFn() {
      return mergeData(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function" ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      var instanceData = typeof childVal === "function" ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === "function" ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}
strats.data = function(parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== "function") {
      warn('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }
  return mergeDataOrFn(parentVal, childVal, vm);
};
function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks2) {
  var res = [];
  for (var i = 0; i < hooks2.length; i++) {
    if (res.indexOf(hooks2[i]) === -1) {
      res.push(hooks2[i]);
    }
  }
  return res;
}
LIFECYCLE_HOOKS.forEach(function(hook) {
  strats[hook] = mergeHook;
});
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}
ASSET_TYPES.forEach(function(type2) {
  strats[type2 + "s"] = mergeAssets;
});
strats.watch = function(parentVal, childVal, vm, key) {
  if (parentVal === nativeWatch) {
    parentVal = void 0;
  }
  if (childVal === nativeWatch) {
    childVal = void 0;
  }
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};
strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
  if (childVal && true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;
var defaultStrat = function(parentVal, childVal) {
  return childVal === void 0 ? parentVal : childVal;
};
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}
function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names should conform to valid custom element name in html5 specification.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function normalizeProps(options, vm) {
  var props2 = options.props;
  if (!props2) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props2)) {
    i = props2.length;
    while (i--) {
      val = props2[i];
      if (typeof val === "string") {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn("props must be strings when using array syntax.");
      }
    }
  } else if (isPlainObject(props2)) {
    for (var key in props2) {
      val = props2[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (true) {
    warn('Invalid value for option "props": expected an Array or an Object, but got ' + toRawType(props2) + ".", vm);
  }
  options.props = res;
}
function normalizeInject(options, vm) {
  var inject2 = options.inject;
  if (!inject2) {
    return;
  }
  var normalized = options.inject = {};
  if (Array.isArray(inject2)) {
    for (var i = 0; i < inject2.length; i++) {
      normalized[inject2[i]] = { from: inject2[i] };
    }
  } else if (isPlainObject(inject2)) {
    for (var key in inject2) {
      var val = inject2[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (true) {
    warn('Invalid value for option "inject": expected an Array or an Object, but got ' + toRawType(inject2) + ".", vm);
  }
}
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === "function") {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}
function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn('Invalid value for option "' + name + '": expected an Object, but got ' + toRawType(value) + ".", vm);
  }
}
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }
  if (typeof child === "function") {
    child = child.options;
  }
  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key2) {
    var strat = strats[key2] || defaultStrat;
    options[key2] = strat(parent[key2], child[key2], vm, key2);
  }
  return options;
}
function resolveAsset(options, type2, id, warnMissing) {
  if (typeof id !== "string") {
    return;
  }
  var assets = options[type2];
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (warnMissing && !res) {
    warn("Failed to resolve " + type2.slice(0, -1) + ": " + id, options);
  }
  return res;
}
function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, "default")) {
      value = false;
    } else if (value === "" || value === hyphenate(key)) {
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  if (value === void 0) {
    value = getPropDefaultValue(vm, prop, key);
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
function getPropDefaultValue(vm, prop, key) {
  if (!hasOwn(prop, "default")) {
    return void 0;
  }
  var def2 = prop.default;
  if (isObject(def2)) {
    warn('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
  }
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
    return vm._props[key];
  }
  return typeof def2 === "function" && getType(prop.type) !== "Function" ? def2.call(vm) : def2;
}
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type2 = prop.type;
  var valid = !type2 || type2 === true;
  var expectedTypes = [];
  if (type2) {
    if (!Array.isArray(type2)) {
      type2 = [type2];
    }
    for (var i = 0; i < type2.length && !valid; i++) {
      var assertedType = assertType(value, type2[i], vm);
      expectedTypes.push(assertedType.expectedType || "");
      valid = assertedType.valid;
    }
  }
  var haveExpectedTypes = expectedTypes.some(function(t) {
    return t;
  });
  if (!valid && haveExpectedTypes) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}
var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type2, vm) {
  var valid;
  var expectedType = getType(type2);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type2;
    }
  } else if (expectedType === "Object") {
    valid = isPlainObject(value);
  } else if (expectedType === "Array") {
    valid = Array.isArray(value);
  } else {
    try {
      valid = value instanceof type2;
    } catch (e) {
      warn('Invalid prop type: "' + String(type2) + '" is not a constructor', vm);
      valid = false;
    }
  }
  return {
    valid,
    expectedType
  };
}
var functionTypeCheckRE = /^\s*function (\w+)/;
function getType(fn) {
  var match = fn && fn.toString().match(functionTypeCheckRE);
  return match ? match[1] : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type2, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type2) ? 0 : -1;
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type2)) {
      return i;
    }
  }
  return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = 'Invalid prop: type check failed for prop "' + name + '". Expected ' + expectedTypes.map(capitalize).join(", ");
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && isExplicable(typeof value) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + styleValue(value, expectedType);
  }
  message += ", got " + receivedType + " ";
  if (isExplicable(receivedType)) {
    message += "with value " + styleValue(value, receivedType) + ".";
  }
  return message;
}
function styleValue(value, type2) {
  if (type2 === "String") {
    return '"' + value + '"';
  } else if (type2 === "Number") {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}
var EXPLICABLE_TYPES = ["string", "number", "boolean"];
function isExplicable(value) {
  return EXPLICABLE_TYPES.some(function(elem) {
    return value.toLowerCase() === elem;
  });
}
function isBoolean() {
  var args = [], len = arguments.length;
  while (len--)
    args[len] = arguments[len];
  return args.some(function(elem) {
    return elem.toLowerCase() === "boolean";
  });
}
function handleError(err, vm, info) {
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks2 = cur.$options.errorCaptured;
        if (hooks2) {
          for (var i = 0; i < hooks2.length; i++) {
            try {
              var capture = hooks2[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, "errorCaptured hook");
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function(e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res;
}
function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      if (e !== err) {
        logError(e, null, "config.errorHandler");
      }
    }
  }
  logError(err, vm, info);
}
function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ': "' + err.toString() + '"', vm);
  }
  if ((inBrowser || inWeex) && typeof console !== "undefined") {
    console.error(err);
  } else {
    throw err;
  }
}
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}
var timerFunc;
if (typeof Promise !== "undefined" && isNative(Promise)) {
  p = Promise.resolve();
  timerFunc = function() {
    p.then(flushCallbacks);
    if (isIOS) {
      setTimeout(noop);
    }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  counter = 1;
  observer = new MutationObserver(flushCallbacks);
  textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function() {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
  timerFunc = function() {
    setImmediate(flushCallbacks);
  };
} else {
  timerFunc = function() {
    setTimeout(flushCallbacks, 0);
  };
}
var p;
var counter;
var observer;
var textNode;
function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function() {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, "nextTick");
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  if (!cb && typeof Promise !== "undefined") {
    return new Promise(function(resolve) {
      _resolve = resolve;
    });
  }
}
var initProxy;
if (true) {
  allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,require");
  warnNonPresent = function(target2, key) {
    warn('Property or method "' + key + '" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target2);
  };
  warnReservedPrefix = function(target2, key) {
    warn('Property "' + key + '" must be accessed with "$data.' + key + '" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data', target2);
  };
  hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
  if (hasProxy) {
    isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set2(target2, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target2[key] = value;
          return true;
        }
      }
    });
  }
  hasHandler = {
    has: function has2(target2, key) {
      var has3 = key in target2;
      var isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
      if (!has3 && !isAllowed) {
        if (key in target2.$data) {
          warnReservedPrefix(target2, key);
        } else {
          warnNonPresent(target2, key);
        }
      }
      return has3 || !isAllowed;
    }
  };
  getHandler = {
    get: function get3(target2, key) {
      if (typeof key === "string" && !(key in target2)) {
        if (key in target2.$data) {
          warnReservedPrefix(target2, key);
        } else {
          warnNonPresent(target2, key);
        }
      }
      return target2[key];
    }
  };
  initProxy = function initProxy2(vm) {
    if (hasProxy) {
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
var allowedGlobals;
var warnNonPresent;
var warnReservedPrefix;
var hasProxy;
var isBuiltInModifier;
var hasHandler;
var getHandler;
var seenObjects = new _Set();
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}
function _traverse(val, seen) {
  var i, keys2;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys2 = Object.keys(val);
    i = keys2.length;
    while (i--) {
      _traverse(val[keys2[i]], seen);
    }
  }
}
var mark;
var measure;
if (true) {
  perf = inBrowser && window.performance;
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function(tag) {
      return perf.mark(tag);
    };
    measure = function(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    };
  }
}
var perf;
var normalizeEvent = cached(function(name) {
  var passive = name.charAt(0) === "&";
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === "~";
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === "!";
  name = capture ? name.slice(1) : name;
  return {
    name,
    once: once$$1,
    capture,
    passive
  };
});
function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns2 = invoker.fns;
    if (Array.isArray(fns2)) {
      var cloned = fns2.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
    }
  }
  invoker.fns = fns;
  return invoker;
}
function updateListeners(on, oldOn, add2, remove$$12, createOnceHandler2, vm) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      warn('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler2(event.name, cur, event.capture);
      }
      add2(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$12(event.name, oldOn[name], event.capture);
    }
  }
}
function mergeVNodeHook(def2, hookKey, hook) {
  if (def2 instanceof VNode) {
    def2 = def2.data.hook || (def2.data.hook = {});
  }
  var invoker;
  var oldHook = def2[hookKey];
  function wrappedHook() {
    hook.apply(this, arguments);
    remove(invoker.fns, wrappedHook);
  }
  if (isUndef(oldHook)) {
    invoker = createFnInvoker([wrappedHook]);
  } else {
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }
  invoker.merged = true;
  def2[hookKey] = invoker;
}
function extractPropsFromVNodeData(data, Ctor, tag) {
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs2 = data.attrs;
  var props2 = data.props;
  if (isDef(attrs2) || isDef(props2)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs2 && hasOwn(attrs2, keyInLowerCase)) {
          tip('Prop "' + keyInLowerCase + '" is passed to component ' + formatComponentName(tag || Ctor) + ', but the declared prop name is "' + key + '". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "' + altKey + '" instead of "' + key + '".');
        }
      }
      checkProp(res, props2, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
    }
  }
  return res;
}
function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : void 0;
}
function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === "boolean") {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i);
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== "") {
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}
function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === "function" ? provide.call(vm) : provide;
  }
}
function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function(key) {
      if (true) {
        defineReactive$$1(vm, key, result[key], function() {
          warn('Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "' + key + '"', vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}
function resolveInject(inject2, vm) {
  if (inject2) {
    var result = Object.create(null);
    var keys2 = hasSymbol ? Reflect.ownKeys(inject2) : Object.keys(inject2);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key === "__ob__") {
        continue;
      }
      var provideKey = inject2[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ("default" in inject2[key]) {
          var provideDefault = inject2[key].default;
          result[key] = typeof provideDefault === "function" ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn('Injection "' + key + '" not found', vm);
        }
      }
    }
    return result;
  }
}
function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === "template") {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}
function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === " ";
}
function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    return slots._normalized;
  } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
    return prevSlots;
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== "$") {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }
  def(res, "$stable", isStable);
  def(res, "$key", key);
  def(res, "$hasNormal", hasNormalSlots);
  return res;
}
function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function() {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === "object" && !Array.isArray(res) ? [res] : normalizeChildren(res);
    var vnode = res && res[0];
    return res && (!vnode || res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) ? void 0 : res;
  };
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized;
}
function proxyNormalSlot(slots, key) {
  return function() {
    return slots[key];
  };
}
function renderList(val, render4) {
  var ret, i, l, keys2, key;
  if (Array.isArray(val) || typeof val === "string") {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render4(val[i], i);
    }
  } else if (typeof val === "number") {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render4(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render4(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys2 = Object.keys(val);
      ret = new Array(keys2.length);
      for (i = 0, l = keys2.length; i < l; i++) {
        key = keys2[i];
        ret[i] = render4(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  ret._isVList = true;
  return ret;
}
function renderSlot(name, fallbackRender, props2, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    props2 = props2 || {};
    if (bindObject) {
      if (!isObject(bindObject)) {
        warn("slot v-bind without argument expects an Object", this);
      }
      props2 = extend(extend({}, bindObject), props2);
    }
    nodes = scopedSlotFn(props2) || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
  } else {
    nodes = this.$slots[name] || (typeof fallbackRender === "function" ? fallbackRender() : fallbackRender);
  }
  var target2 = props2 && props2.slot;
  if (target2) {
    return this.$createElement("template", { slot: target2 }, nodes);
  } else {
    return nodes;
  }
}
function resolveFilter(id) {
  return resolveAsset(this.$options, "filters", id, true) || identity;
}
function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
  return eventKeyCode === void 0;
}
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      warn("v-bind without argument expects an Object or Array value", this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function(key2) {
        if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
          hash = data;
        } else {
          var type2 = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type2, key2) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key2);
        var hyphenatedKey = hyphenate(key2);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key2] = value[key2];
          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key2] = function($event) {
              value[key2] = $event;
            };
          }
        }
      };
      for (var key in value)
        loop(key);
    }
  }
  return data;
}
function renderStatic(index2, isInFor) {
  var cached2 = this._staticTrees || (this._staticTrees = []);
  var tree = cached2[index2];
  if (tree && !isInFor) {
    return tree;
  }
  tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, null, this);
  markStatic(tree, "__static__" + index2, false);
  return tree;
}
function markOnce(tree, index2, key) {
  markStatic(tree, "__once__" + index2 + (key ? "_" + key : ""), true);
  return tree;
}
function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== "string") {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}
function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      warn("v-on without argument expects an Object value", this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}
function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    res.$key = contentHashKey;
  }
  return res;
}
function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === "string" && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== "" && key !== null) {
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }
  return baseObj;
}
function prependModifier(value, symbol) {
  return typeof value === "string" ? symbol + value : value;
}
function installRenderHelpers(target2) {
  target2._o = markOnce;
  target2._n = toNumber;
  target2._s = toString;
  target2._l = renderList;
  target2._t = renderSlot;
  target2._q = looseEqual;
  target2._i = looseIndexOf;
  target2._m = renderStatic;
  target2._f = resolveFilter;
  target2._k = checkKeyCodes;
  target2._b = bindObjectProps;
  target2._v = createTextVNode;
  target2._e = createEmptyVNode;
  target2._u = resolveScopedSlots;
  target2._g = bindObjectListeners;
  target2._d = bindDynamicKeys;
  target2._p = prependModifier;
}
function FunctionalRenderContext(data, props2, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options;
  var contextVm;
  if (hasOwn(parent, "_uid")) {
    contextVm = Object.create(parent);
    contextVm._original = parent;
  } else {
    contextVm = parent;
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props2;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function() {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }
    return this$1.$slots;
  };
  Object.defineProperty(this, "scopedSlots", {
    enumerable: true,
    get: function get3() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  });
  if (isCompiled) {
    this.$options = options;
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }
  if (options._scopeId) {
    this._c = function(a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function(a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props2 = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props2[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props2, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props2, data.props);
    }
  }
  var renderContext = new FunctionalRenderContext(data, props2, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);
  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res;
  }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone;
}
function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      var mountedNode = vnode;
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : void 0, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, "mounted");
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true);
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true);
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }
  var baseCtor = context.$options._base;
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
  if (typeof Ctor !== "function") {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === void 0) {
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }
  data = data || {};
  resolveConstructorOptions(Ctor);
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }
  var listeners = data.on;
  data.on = data.nativeOn;
  if (isTrue(Ctor.options.abstract)) {
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }
  installComponentHooks(data);
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data, void 0, void 0, void 0, context, { Ctor, propsData, listeners, tag, children }, asyncFactory);
  return vnode;
}
function createComponentInstanceForVnode(vnode, parent) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent
  };
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
  var hooks2 = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks2[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks2[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}
function mergeHook$1(f1, f2) {
  var merged = function(a, b) {
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged;
}
function transformModel(options, data) {
  var prop = options.model && options.model.prop || "value";
  var event = options.model && options.model.event || "input";
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = void 0;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\nAlways create fresh vnode data objects in each render!", context);
    return createEmptyVNode();
  }
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    return createEmptyVNode();
  }
  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn("Avoid using non-primitive value as key, use string/number value instead.", context);
    }
  }
  if (Array.isArray(children) && typeof children[0] === "function") {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === "string") {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      if (isDef(data) && isDef(data.nativeOn) && data.tag !== "component") {
        warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
      }
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      vnode = new VNode(tag, data, children, void 0, void 0, context);
    }
  } else {
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }
    if (isDef(data)) {
      registerDeepBindings(data);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}
function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === "foreignObject") {
    ns = void 0;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
        applyNS(child, ns, force);
      }
    }
  }
}
function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}
function initRender(vm) {
  vm._vnode = null;
  vm._staticTrees = null;
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode;
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  vm._c = function(a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  vm.$createElement = function(a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
  var parentData = parentVnode && parentVnode.data;
  if (true) {
    defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, function() {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, null, true);
  }
}
var currentRenderingInstance = null;
function renderMixin(Vue2) {
  installRenderHelpers(Vue2.prototype);
  Vue2.prototype.$nextTick = function(fn) {
    return nextTick(fn, this);
  };
  Vue2.prototype._render = function() {
    var vm = this;
    var ref2 = vm.$options;
    var render4 = ref2.render;
    var _parentVnode = ref2._parentVnode;
    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    }
    vm.$vnode = _parentVnode;
    var vnode;
    try {
      currentRenderingInstance = vm;
      vnode = render4.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e2) {
          handleError(e2, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
      }
      vnode = createEmptyVNode();
    }
    vnode.parent = _parentVnode;
    return vnode;
  };
}
function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory5, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory5;
  node.asyncMeta = { data, context, children, tag };
  return node;
}
function resolveAsyncComponent(factory5, baseCtor) {
  if (isTrue(factory5.error) && isDef(factory5.errorComp)) {
    return factory5.errorComp;
  }
  if (isDef(factory5.resolved)) {
    return factory5.resolved;
  }
  var owner = currentRenderingInstance;
  if (owner && isDef(factory5.owners) && factory5.owners.indexOf(owner) === -1) {
    factory5.owners.push(owner);
  }
  if (isTrue(factory5.loading) && isDef(factory5.loadingComp)) {
    return factory5.loadingComp;
  }
  if (owner && !isDef(factory5.owners)) {
    var owners = factory5.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null;
    owner.$on("hook:destroyed", function() {
      return remove(owners, owner);
    });
    var forceRender = function(renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }
      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };
    var resolve = once(function(res2) {
      factory5.resolved = ensureCtor(res2, baseCtor);
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function(reason) {
      warn("Failed to resolve async component: " + String(factory5) + (reason ? "\nReason: " + reason : ""));
      if (isDef(factory5.errorComp)) {
        factory5.error = true;
        forceRender(true);
      }
    });
    var res = factory5(resolve, reject);
    if (isObject(res)) {
      if (isPromise(res)) {
        if (isUndef(factory5.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);
        if (isDef(res.error)) {
          factory5.errorComp = ensureCtor(res.error, baseCtor);
        }
        if (isDef(res.loading)) {
          factory5.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory5.loading = true;
          } else {
            timerLoading = setTimeout(function() {
              timerLoading = null;
              if (isUndef(factory5.resolved) && isUndef(factory5.error)) {
                factory5.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }
        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function() {
            timerTimeout = null;
            if (isUndef(factory5.resolved)) {
              reject(true ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }
    sync = false;
    return factory5.loading ? factory5.loadingComp : factory5.resolved;
  }
}
function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}
var target;
function add(event, fn) {
  target.$on(event, fn);
}
function remove$1(event, fn) {
  target.$off(event, fn);
}
function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}
function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = void 0;
}
function eventsMixin(Vue2) {
  var hookRE = /^hook:/;
  Vue2.prototype.$on = function(event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };
  Vue2.prototype.$once = function(event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };
  Vue2.prototype.$off = function(event, fn) {
    var vm = this;
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm;
    }
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };
  Vue2.prototype.$emit = function(event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip('Event "' + lowerCaseEvent + '" is emitted in component ' + formatComponentName(vm) + ' but the handler is registered for "' + event + '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "' + hyphenate(event) + '" instead of "' + event + '".');
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = 'event handler for "' + event + '"';
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm;
  };
}
var activeInstance = null;
var isUpdatingChildComponent = false;
function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function() {
    activeInstance = prevActiveInstance;
  };
}
function initLifecycle(vm) {
  var options = vm.$options;
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }
  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue2) {
  Vue2.prototype._update = function(vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    if (!prevVnode) {
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
    } else {
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
  };
  Vue2.prototype.$forceUpdate = function() {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };
  Vue2.prototype.$destroy = function() {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, "beforeDestroy");
    vm._isBeingDestroyed = true;
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    vm._isDestroyed = true;
    vm.__patch__(vm._vnode, null);
    callHook(vm, "destroyed");
    vm.$off();
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}
function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
        warn("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
      } else {
        warn("Failed to mount component: template or render function not defined.", vm);
      }
    }
  }
  callHook(vm, "beforeMount");
  var updateComponent;
  if (config.performance && mark) {
    updateComponent = function() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function() {
      vm._update(vm._render(), hydrating);
    };
  }
  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, "beforeUpdate");
      }
    }
  }, true);
  hydrating = false;
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, "mounted");
  }
  return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  }
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key || !newScopedSlots && vm.$scopedSlots.$key);
  var needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode;
  if (vm._vnode) {
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props2 = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props;
      props2[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    vm.$options.propsData = propsData;
  }
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
  if (true) {
    isUpdatingChildComponent = false;
  }
}
function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}
function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, "activated");
  }
}
function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, "deactivated");
  }
}
function callHook(vm, hook) {
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit("hook:" + hook);
  }
  popTarget();
}
var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}
var currentFlushTimestamp = 0;
var getNow = Date.now;
if (inBrowser && !isIE) {
  performance2 = window.performance;
  if (performance2 && typeof performance2.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
    getNow = function() {
      return performance2.now();
    };
  }
}
var performance2;
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;
  queue.sort(function(a, b) {
    return a.id - b.id;
  });
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "' + watcher.expression + '"' : "in a component render function."), watcher.vm);
        break;
      }
    }
  }
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState();
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);
  if (devtools && config.devtools) {
    devtools.emit("flush");
  }
}
function callUpdatedHooks(queue2) {
  var i = queue2.length;
  while (i--) {
    var watcher = queue2[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, "updated");
    }
  }
}
function queueActivatedComponent(vm) {
  vm._inactive = false;
  activatedChildren.push(vm);
}
function callActivatedHooks(queue2) {
  for (var i = 0; i < queue2.length; i++) {
    queue2[i]._inactive = true;
    activateChildComponent(queue2[i], true);
  }
}
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    if (!waiting) {
      waiting = true;
      if (!config.async) {
        flushSchedulerQueue();
        return;
      }
      nextTick(flushSchedulerQueue);
    }
  }
}
var uid$2 = 0;
var Watcher = function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2;
  this.active = true;
  this.dirty = this.lazy;
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = true ? expOrFn.toString() : "";
  if (typeof expOrFn === "function") {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
      warn('Failed watching path: "' + expOrFn + '" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? void 0 : this.get();
};
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, 'getter for watcher "' + this.expression + '"');
    } else {
      throw e;
    }
  } finally {
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
Watcher.prototype.update = function update() {
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value || isObject(value) || this.deep) {
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        var info = 'callback for watcher "' + this.expression + '"';
        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
Watcher.prototype.depend = function depend2() {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};
Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};
function proxy(target2, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props2 = vm._props = {};
  var keys2 = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function(key2) {
    keys2.push(key2);
    var value = validateProp(key2, propsOptions, propsData, vm);
    if (true) {
      var hyphenatedKey = hyphenate(key2);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
      }
      defineReactive$$1(props2, key2, value, function() {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "` + key2 + '"', vm);
        }
      });
    } else {
      defineReactive$$1(props2, key2, value);
    }
    if (!(key2 in vm)) {
      proxy(vm, "_props", key2);
    }
  };
  for (var key in propsOptions)
    loop(key);
  toggleObserving(true);
}
function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === "function" ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    warn("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
  }
  var keys2 = Object.keys(data);
  var props2 = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys2.length;
  while (i--) {
    var key = keys2[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn('Method "' + key + '" has already been defined as a data property.', vm);
      }
    }
    if (props2 && hasOwn(props2, key)) {
      warn('The data property "' + key + '" is already declared as a prop. Use prop default value instead.', vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  observe(data, true);
}
function getData(data, vm) {
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}
var computedWatcherOptions = { lazy: true };
function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  var isSSR = isServerRendering();
  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === "function" ? userDef : userDef.get;
    if (getter == null) {
      warn('Getter is missing for computed property "' + key + '".', vm);
    }
    if (!isSSR) {
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn('The computed property "' + key + '" is already defined in data.', vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn('The computed property "' + key + '" is already defined as a prop.', vm);
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn('The computed property "' + key + '" is already defined as a method.', vm);
      }
    }
  }
}
function defineComputed(target2, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === "function") {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function() {
      warn('Computed property "' + key + '" was assigned to but it has no setter.', this);
    };
  }
  Object.defineProperty(target2, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}
function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}
function initMethods(vm, methods) {
  var props2 = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== "function") {
        warn('Method "' + key + '" has type "' + typeof methods[key] + '" in the component definition. Did you reference the function correctly?', vm);
      }
      if (props2 && hasOwn(props2, key)) {
        warn('Method "' + key + '" has already been defined as a prop.', vm);
      }
      if (key in vm && isReserved(key)) {
        warn('Method "' + key + '" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.');
      }
    }
    vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
  }
}
function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}
function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === "string") {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue2) {
  var dataDef = {};
  dataDef.get = function() {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function() {
    return this._props;
  };
  if (true) {
    dataDef.set = function() {
      warn("Avoid replacing instance root $data. Use nested data properties instead.", this);
    };
    propsDef.set = function() {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue2.prototype, "$data", dataDef);
  Object.defineProperty(Vue2.prototype, "$props", propsDef);
  Vue2.prototype.$set = set;
  Vue2.prototype.$delete = del;
  Vue2.prototype.$watch = function(expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      var info = 'callback for immediate watcher "' + watcher.expression + '"';
      pushTarget();
      invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
      popTarget();
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
var uid$3 = 0;
function initMixin(Vue2) {
  Vue2.prototype._init = function(options) {
    var vm = this;
    vm._uid = uid$3++;
    var startTag, endTag;
    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }
    vm._isVue = true;
    if (options && options._isComponent) {
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, "beforeCreate");
    initInjections(vm);
    initState(vm);
    initProvide(vm);
    callHook(vm, "created");
    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }
    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}
function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}
function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      Ctor.superOptions = superOptions;
      var modifiedOptions = resolveModifiedOptions(Ctor);
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}
function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = latest[key];
    }
  }
  return modified;
}
function Vue(options) {
  if (!(this instanceof Vue)) {
    warn("Vue is a constructor and should be called with the `new` keyword");
  }
  this._init(options);
}
initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
function initUse(Vue2) {
  Vue2.use = function(plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === "function") {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === "function") {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}
function initMixin$1(Vue2) {
  Vue2.mixin = function(mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
function initExtend(Vue2) {
  Vue2.cid = 0;
  var cid = 1;
  Vue2.extend = function(extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }
    var name = extendOptions.name || Super.options.name;
    if (name) {
      validateComponentName(name);
    }
    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub["super"] = Super;
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;
    ASSET_TYPES.forEach(function(type2) {
      Sub[type2] = Super[type2];
    });
    if (name) {
      Sub.options.components[name] = Sub;
    }
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}
function initProps$1(Comp) {
  var props2 = Comp.options.props;
  for (var key in props2) {
    proxy(Comp.prototype, "_props", key);
  }
}
function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
function initAssetRegisters(Vue2) {
  ASSET_TYPES.forEach(function(type2) {
    Vue2[type2] = function(id, definition) {
      if (!definition) {
        return this.options[type2 + "s"][id];
      } else {
        if (type2 === "component") {
          validateComponentName(id);
        }
        if (type2 === "component" && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type2 === "directive" && typeof definition === "function") {
          definition = { bind: definition, update: definition };
        }
        this.options[type2 + "s"][id] = definition;
        return definition;
      }
    };
  });
}
function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}
function matches(pattern2, name) {
  if (Array.isArray(pattern2)) {
    return pattern2.indexOf(name) > -1;
  } else if (typeof pattern2 === "string") {
    return pattern2.split(",").indexOf(name) > -1;
  } else if (isRegExp(pattern2)) {
    return pattern2.test(name);
  }
  return false;
}
function pruneCache(keepAliveInstance, filter) {
  var cache3 = keepAliveInstance.cache;
  var keys2 = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache3) {
    var entry = cache3[key];
    if (entry) {
      var name = entry.name;
      if (name && !filter(name)) {
        pruneCacheEntry(cache3, key, keys2, _vnode);
      }
    }
  }
}
function pruneCacheEntry(cache3, key, keys2, current) {
  var entry = cache3[key];
  if (entry && (!current || entry.tag !== current.tag)) {
    entry.componentInstance.$destroy();
  }
  cache3[key] = null;
  remove(keys2, key);
}
var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: "keep-alive",
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function cacheVNode() {
      var ref2 = this;
      var cache3 = ref2.cache;
      var keys2 = ref2.keys;
      var vnodeToCache = ref2.vnodeToCache;
      var keyToCache = ref2.keyToCache;
      if (vnodeToCache) {
        var tag = vnodeToCache.tag;
        var componentInstance = vnodeToCache.componentInstance;
        var componentOptions = vnodeToCache.componentOptions;
        cache3[keyToCache] = {
          name: getComponentName(componentOptions),
          tag,
          componentInstance
        };
        keys2.push(keyToCache);
        if (this.max && keys2.length > parseInt(this.max)) {
          pruneCacheEntry(cache3, keys2[0], keys2, this._vnode);
        }
        this.vnodeToCache = null;
      }
    }
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.cacheVNode();
    this.$watch("include", function(val) {
      pruneCache(this$1, function(name) {
        return matches(val, name);
      });
    });
    this.$watch("exclude", function(val) {
      pruneCache(this$1, function(name) {
        return !matches(val, name);
      });
    });
  },
  updated: function updated() {
    this.cacheVNode();
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      var name = getComponentName(componentOptions);
      var ref2 = this;
      var include = ref2.include;
      var exclude = ref2.exclude;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        return vnode;
      }
      var ref$1 = this;
      var cache3 = ref$1.cache;
      var keys2 = ref$1.keys;
      var key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
      if (cache3[key]) {
        vnode.componentInstance = cache3[key].componentInstance;
        remove(keys2, key);
        keys2.push(key);
      } else {
        this.vnodeToCache = vnode;
        this.keyToCache = key;
      }
      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive
};
function initGlobalAPI(Vue2) {
  var configDef = {};
  configDef.get = function() {
    return config;
  };
  if (true) {
    configDef.set = function() {
      warn("Do not replace the Vue.config object, set individual fields instead.");
    };
  }
  Object.defineProperty(Vue2, "config", configDef);
  Vue2.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue2.set = set;
  Vue2.delete = del;
  Vue2.nextTick = nextTick;
  Vue2.observable = function(obj) {
    observe(obj);
    return obj;
  };
  Vue2.options = Object.create(null);
  ASSET_TYPES.forEach(function(type2) {
    Vue2.options[type2 + "s"] = Object.create(null);
  });
  Vue2.options._base = Vue2;
  extend(Vue2.options.components, builtInComponents);
  initUse(Vue2);
  initMixin$1(Vue2);
  initExtend(Vue2);
  initAssetRegisters(Vue2);
}
initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, "$isServer", {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, "$ssrContext", {
  get: function get2() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty(Vue, "FunctionalRenderContext", {
  value: FunctionalRenderContext
});
Vue.version = "2.6.14";
var isReservedAttr = makeMap("style,class");
var acceptValue = makeMap("input,textarea,option,select,progress");
var mustUseProp = function(tag, type2, attr) {
  return attr === "value" && acceptValue(tag) && type2 !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
};
var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
var convertEnumeratedValue = function(key, value) {
  return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
};
var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible");
var xlinkNS = "http://www.w3.org/1999/xlink";
var isXlink = function(name) {
  return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
};
var getXlinkProp = function(name) {
  return isXlink(name) ? name.slice(6, name.length) : "";
};
var isFalsyAttrValue = function(val) {
  return val == null || val === false;
};
function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode2 = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode2 = parentNode2.parent)) {
    if (parentNode2 && parentNode2.data) {
      data = mergeClassData(data, parentNode2.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}
function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  return "";
}
function concat(a, b) {
  return a ? b ? a + " " + b : a : b || "";
}
function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === "string") {
    return value;
  }
  return "";
}
function stringifyArray(value) {
  var res = "";
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
      if (res) {
        res += " ";
      }
      res += stringified;
    }
  }
  return res;
}
function stringifyObject(value) {
  var res = "";
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += " ";
      }
      res += key;
    }
  }
  return res;
}
var namespaceMap = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
};
var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
var isReservedTag = function(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return "svg";
  }
  if (tag === "math") {
    return "math";
  }
}
var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf("-") > -1) {
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}
var isTextInputType = makeMap("text,number,password,search,email,tel,url");
function query(el) {
  if (typeof el === "string") {
    var selected = document.querySelector(el);
    if (!selected) {
      warn("Cannot find element: " + el);
      return document.createElement("div");
    }
    return selected;
  } else {
    return el;
  }
}
function createElement$1(tagName2, vnode) {
  var elm = document.createElement(tagName2);
  if (tagName2 !== "select") {
    return elm;
  }
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
    elm.setAttribute("multiple", "multiple");
  }
  return elm;
}
function createElementNS(namespace, tagName2) {
  return document.createElementNS(namespaceMap[namespace], tagName2);
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function createComment(text) {
  return document.createComment(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(node) {
  return node.tagName;
}
function setTextContent(node, text) {
  node.textContent = text;
}
function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, "");
}
var nodeOps = /* @__PURE__ */ Object.freeze({
  createElement: createElement$1,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  setStyleScope
});
var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update2(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy2(vnode) {
    registerRef(vnode, true);
  }
};
function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) {
    return;
  }
  var vm = vnode.context;
  var ref2 = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref2);
    } else if (refs[key] === ref2) {
      refs[key] = void 0;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref2];
      } else if (refs[key].indexOf(ref2) < 0) {
        refs[key].push(ref2);
      }
    } else {
      refs[key] = ref2;
    }
  }
}
var emptyNode = new VNode("", {}, []);
var hooks = ["create", "activate", "update", "remove", "destroy"];
function sameVnode(a, b) {
  return a.key === b.key && a.asyncFactory === b.asyncFactory && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error));
}
function sameInputType(a, b) {
  if (a.tag !== "input") {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}
function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules2 = backend.modules;
  var nodeOps2 = backend.nodeOps;
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules2.length; ++j) {
      if (isDef(modules2[j][hooks[i]])) {
        cbs[hooks[i]].push(modules2[j][hooks[i]]);
      }
    }
  }
  function emptyNodeAt(elm) {
    return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    function remove$$12() {
      if (--remove$$12.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$12.listeners = listeners;
    return remove$$12;
  }
  function removeNode(el) {
    var parent = nodeOps2.parentNode(el);
    if (isDef(parent)) {
      nodeOps2.removeChild(parent, el);
    }
  }
  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }
  var creatingElmInVPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    vnode.isRootInsert = !nested;
    if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }
    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
      setScope(vnode);
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert2(parentElm, vnode.elm, refElm);
      }
      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps2.createComment(vnode.text);
      insert2(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps2.createTextNode(vnode.text);
      insert2(parentElm, vnode.elm, refElm);
    }
  }
  function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2 = vnode.data;
    if (isDef(i2)) {
      var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
      if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
        i2(vnode, false);
      }
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert2(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }
  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      registerRef(vnode);
      insertedVnodeQueue.push(vnode);
    }
  }
  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i2;
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
        for (i2 = 0; i2 < cbs.activate.length; ++i2) {
          cbs.activate[i2](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    insert2(parentElm, vnode.elm, refElm);
  }
  function insert2(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps2.parentNode(ref$$1) === parent) {
          nodeOps2.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps2.appendChild(parent, elm);
      }
    }
  }
  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i2 = 0; i2 < children.length; ++i2) {
        createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
    }
  }
  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }
  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook;
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }
  function setScope(vnode) {
    var i2;
    if (isDef(i2 = vnode.fnScopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
          nodeOps2.setStyleScope(vnode.elm, i2);
        }
        ancestor = ancestor.parent;
      }
    }
    if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
      nodeOps2.setStyleScope(vnode.elm, i2);
    }
  }
  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }
  function invokeDestroyHook(vnode) {
    var i2, j2;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy)) {
        i2(vnode);
      }
      for (i2 = 0; i2 < cbs.destroy.length; ++i2) {
        cbs.destroy[i2](vnode);
      }
    }
    if (isDef(i2 = vnode.children)) {
      for (j2 = 0; j2 < vnode.children.length; ++j2) {
        invokeDestroyHook(vnode.children[j2]);
      }
    }
  }
  function removeVnodes(vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          removeNode(ch.elm);
        }
      }
    }
  }
  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i2;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        rm.listeners += listeners;
      } else {
        rm = createRmCb(vnode.elm, listeners);
      }
      if (isDef(i2 = vnode.componentInstance) && isDef(i2 = i2._vnode) && isDef(i2.data)) {
        removeAndInvokeRemoveHook(i2, rm);
      }
      for (i2 = 0; i2 < cbs.remove.length; ++i2) {
        cbs.remove[i2](vnode, rm);
      }
      if (isDef(i2 = vnode.data.hook) && isDef(i2 = i2.remove)) {
        i2(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
    var canMove = !removeOnly;
    if (true) {
      checkDuplicateKeys(newCh);
    }
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = void 0;
            canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }
  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i2 = 0; i2 < children.length; i2++) {
      var vnode = children[i2];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }
  function findIdxInOld(node, oldCh, start, end) {
    for (var i2 = start; i2 < end; i2++) {
      var c = oldCh[i2];
      if (isDef(c) && sameVnode(node, c)) {
        return i2;
      }
    }
  }
  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      vnode = ownerArray[index2] = cloneVNode(vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i2;
    var data = vnode.data;
    if (isDef(data) && isDef(i2 = data.hook) && isDef(i2 = i2.prepatch)) {
      i2(oldVnode, vnode);
    }
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i2 = 0; i2 < cbs.update.length; ++i2) {
        cbs.update[i2](oldVnode, vnode);
      }
      if (isDef(i2 = data.hook) && isDef(i2 = i2.update)) {
        i2(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) {
          nodeOps2.setTextContent(elm, "");
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps2.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps2.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.postpatch)) {
        i2(oldVnode, vnode);
      }
    }
  }
  function invokeInsertHook(vnode, queue2, initial) {
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue2;
    } else {
      for (var i2 = 0; i2 < queue2.length; ++i2) {
        queue2[i2].data.hook.insert(queue2[i2]);
      }
    }
  }
  var hydrationBailed = false;
  var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i2;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i2 = data.hook) && isDef(i2 = i2.init)) {
        i2(vnode, true);
      }
      if (isDef(i2 = vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          if (isDef(i2 = data) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
            if (i2 !== elm.innerHTML) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true;
                console.warn("Parent: ", elm);
                console.warn("server innerHTML: ", i2);
                console.warn("client innerHTML: ", elm.innerHTML);
              }
              return false;
            }
          } else {
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            if (!childrenMatch || childNode) {
              if (typeof console !== "undefined" && !hydrationBailed) {
                hydrationBailed = true;
                console.warn("Parent: ", elm);
                console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data["class"]) {
          traverse(data["class"]);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }
  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }
  return function patch2(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }
    var isInitialPatch = false;
    var insertedVnodeQueue = [];
    if (isUndef(oldVnode)) {
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
            }
          }
          oldVnode = emptyNodeAt(oldVnode);
        }
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps2.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i2 = 0; i2 < cbs.destroy.length; ++i2) {
              cbs.destroy[i2](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              var insert3 = ancestor.data.hook.insert;
              if (insert3.merged) {
                for (var i$2 = 1; i$2 < insert3.fns.length; i$2++) {
                  insert3.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }
    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};
function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}
function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      callHook$1(dir, "bind", vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, "update", vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }
  if (dirsWithInsert.length) {
    var callInsert = function() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, "insert", callInsert);
    } else {
      callInsert();
    }
  }
  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, "postpatch", function() {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
      }
    });
  }
  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
      }
    }
  }
}
var emptyModifiers = Object.create(null);
function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, "directives", dir.name, true);
  }
  return res;
}
function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
}
function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}
var baseModules = [
  ref,
  directives
];
function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs2 = vnode.data.attrs || {};
  if (isDef(attrs2.__ob__)) {
    attrs2 = vnode.data.attrs = extend({}, attrs2);
  }
  for (key in attrs2) {
    cur = attrs2[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur, vnode.data.pre);
    }
  }
  if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
    setAttr(elm, "value", attrs2.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs2[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}
function setAttr(el, key, value, isInPre) {
  if (isInPre || el.tagName.indexOf("-") > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}
function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
      var blocker = function(e) {
        e.stopImmediatePropagation();
        el.removeEventListener("input", blocker);
      };
      el.addEventListener("input", blocker);
      el.__ieph = true;
    }
    el.setAttribute(key, value);
  }
}
var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }
  var cls = genClassForVnode(vnode);
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }
  if (cls !== el._prevClass) {
    el.setAttribute("class", cls);
    el._prevClass = cls;
  }
}
var klass = {
  create: updateClass,
  update: updateClass
};
var RANGE_TOKEN = "__r";
var CHECKBOX_RADIO_TOKEN = "__c";
function normalizeEvents(on) {
  if (isDef(on[RANGE_TOKEN])) {
    var event = isIE ? "change" : "input";
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}
var target$1;
function createOnceHandler$1(event, handler, capture) {
  var _target = target$1;
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add$1(name, handler, capture, passive) {
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function(e) {
      if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }
  target$1.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);
}
function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = void 0;
}
var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
var svgContainer;
function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props2 = vnode.data.domProps || {};
  if (isDef(props2.__ob__)) {
    props2 = vnode.data.domProps = extend({}, props2);
  }
  for (key in oldProps) {
    if (!(key in props2)) {
      elm[key] = "";
    }
  }
  for (key in props2) {
    cur = props2[key];
    if (key === "textContent" || key === "innerHTML") {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }
    if (key === "value" && elm.tagName !== "PROGRESS") {
      elm._value = cur;
      var strCur = isUndef(cur) ? "" : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      svgContainer = svgContainer || document.createElement("div");
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (cur !== oldProps[key]) {
      try {
        elm[key] = cur;
      } catch (e) {
      }
    }
  }
}
function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}
function isNotInFocusAndDirty(elm, checkVal) {
  var notInFocus = true;
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {
  }
  return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers;
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}
var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
var parseStyleText = cached(function(cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function(item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});
function normalizeStyleData(data) {
  var style2 = normalizeStyleBinding(data.style);
  return data.staticStyle ? extend(data.staticStyle, style2) : style2;
}
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === "string") {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;
  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }
  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }
  var parentNode2 = vnode;
  while (parentNode2 = parentNode2.parent) {
    if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
      extend(res, styleData);
    }
  }
  return res;
}
var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function(el, name, val) {
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};
var vendorNames = ["Webkit", "Moz", "ms"];
var emptyStyle;
var normalize = cached(function(prop) {
  emptyStyle = emptyStyle || document.createElement("div").style;
  prop = camelize(prop);
  if (prop !== "filter" && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});
function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }
  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style2 = normalizeStyleBinding(vnode.data.style) || {};
  vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
  var newStyle = getStyle(vnode, true);
  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, "");
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      setProp(el, name, cur == null ? "" : cur);
    }
  }
}
var style = {
  create: updateStyle,
  update: updateStyle
};
var whitespaceRE = /\s+/;
function addClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute("class") || "") + " ";
    if (cur.indexOf(" " + cls + " ") < 0) {
      el.setAttribute("class", (cur + cls).trim());
    }
  }
}
function removeClass(el, cls) {
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  if (el.classList) {
    if (cls.indexOf(" ") > -1) {
      cls.split(whitespaceRE).forEach(function(c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute("class");
    }
  } else {
    var cur = " " + (el.getAttribute("class") || "") + " ";
    var tar = " " + cls + " ";
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, " ");
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute("class", cur);
    } else {
      el.removeAttribute("class");
    }
  }
}
function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  if (typeof def$$1 === "object") {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || "v"));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === "string") {
    return autoCssTransition(def$$1);
  }
}
var autoCssTransition = cached(function(name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = "transition";
var ANIMATION = "animation";
var transitionProp = "transition";
var transitionEndEvent = "transitionend";
var animationProp = "animation";
var animationEndEvent = "animationend";
if (hasTransition) {
  if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
    transitionProp = "WebkitTransition";
    transitionEndEvent = "webkitTransitionEnd";
  }
  if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
    animationProp = "WebkitAnimation";
    animationEndEvent = "webkitAnimationEnd";
  }
}
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
  return fn();
};
function nextFrame(fn) {
  raf(function() {
    raf(fn);
  });
}
function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}
function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
  var ref2 = getTransitionInfo(el, expectedType);
  var type2 = ref2.type;
  var timeout = ref2.timeout;
  var propCount = ref2.propCount;
  if (!type2) {
    return cb();
  }
  var event = type2 === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function() {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
  var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
  var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type2;
  var timeout = 0;
  var propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type2 = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type2 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type2 === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
  return {
    type: type2,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max.apply(null, durations.map(function(d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function enter(vnode, toggleDisplay) {
  var el = vnode.elm;
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }
  var css = data.css;
  var type2 = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter2 = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }
  var isAppear = !context._isMounted || !vnode.isRootInsert;
  if (isAppear && !appear && appear !== "") {
    return;
  }
  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === "function" ? appear : enter2 : enter2;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, "enter", vnode);
  }
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function() {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });
  if (!vnode.data.show) {
    mergeVNodeHook(vnode, "insert", function() {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function() {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type2, cb);
          }
        }
      }
    });
  }
  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }
  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}
function leave(vnode, rm) {
  var el = vnode.elm;
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }
  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  if (isDef(el._leaveCb)) {
    return;
  }
  var css = data.css;
  var type2 = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave2 = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave2);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, "leave", vnode);
  }
  var cb = el._leaveCb = once(function() {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });
  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }
  function performLeave() {
    if (cb.cancelled) {
      return;
    }
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function() {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type2, cb);
            }
          }
        }
      });
    }
    leave2 && leave2(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}
function checkDuration(val, name, vnode) {
  if (typeof val !== "number") {
    warn("<transition> explicit " + name + " duration is not a valid number - got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - the duration expression might be incorrect.", vnode.context);
  }
}
function isValidDuration(val) {
  return typeof val === "number" && !isNaN(val);
}
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}
function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}
var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];
var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps, modules });
if (isIE9) {
  document.addEventListener("selectionchange", function() {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, "input");
    }
  });
}
var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === "select") {
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, "postpatch", function() {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener("compositionstart", onCompositionStart);
        el.addEventListener("compositionend", onCompositionEnd);
        el.addEventListener("change", onCompositionEnd);
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === "select") {
      setSelected(el, binding, vnode.context);
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function(o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        var needReset = el.multiple ? binding.value.some(function(v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, "change");
        }
      }
    }
  }
};
function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  if (isIE || isEdge) {
    setTimeout(function() {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}
function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    warn('<select multiple v-model="' + binding.expression + '"> expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}
function hasNoMatchingOption(value, options) {
  return options.every(function(o) {
    return !looseEqual(o, value);
  });
}
function getValue(option) {
  return "_value" in option ? option._value : option.value;
}
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, "input");
}
function trigger(el, type2) {
  var e = document.createEvent("HTMLEvents");
  e.initEvent(type2, true, true);
  el.dispatchEvent(e);
}
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}
var show = {
  bind: function bind2(el, ref2, vnode) {
    var value = ref2.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function() {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : "none";
    }
  },
  update: function update3(el, ref2, vnode) {
    var value = ref2.value;
    var oldValue = ref2.oldValue;
    if (!value === !oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function() {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function() {
          el.style.display = "none";
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : "none";
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show
};
var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}
function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}
function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h("keep-alive", {
      props: rawChild.componentOptions.propsData
    });
  }
}
function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}
function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function(c) {
  return c.tag || isAsyncPlaceholder(c);
};
var isVShowDirective = function(d) {
  return d.name === "show";
};
var Transition = {
  name: "transition",
  props: transitionProps,
  abstract: true,
  render: function render2(h) {
    var this$1 = this;
    var children = this.$slots.default;
    if (!children) {
      return;
    }
    children = children.filter(isNotTextNode);
    if (!children.length) {
      return;
    }
    if (children.length > 1) {
      warn("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
    }
    var mode = this.mode;
    if (mode && mode !== "in-out" && mode !== "out-in") {
      warn("invalid <transition> mode: " + mode, this.$parent);
    }
    var rawChild = children[0];
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }
    var child = getRealChild(rawChild);
    if (!child) {
      return rawChild;
    }
    if (this._leaving) {
      return placeholder(h, rawChild);
    }
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }
    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      var oldData = oldChild.data.transition = extend({}, data);
      if (mode === "out-in") {
        this._leaving = true;
        mergeVNodeHook(oldData, "afterLeave", function() {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === "in-out") {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function() {
          delayedLeave();
        };
        mergeVNodeHook(data, "afterEnter", performLeave);
        mergeVNodeHook(data, "enterCancelled", performLeave);
        mergeVNodeHook(oldData, "delayLeave", function(leave2) {
          delayedLeave = leave2;
        });
      }
    }
    return rawChild;
  }
};
var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update5 = this._update;
    this._update = function(vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      this$1.__patch__(this$1._vnode, this$1.kept, false, true);
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update5.call(this$1, vnode, hydrating);
    };
  },
  render: function render3(h) {
    var tag = this.tag || this.$vnode.data.tag || "span";
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);
    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || "" : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }
    if (prevChildren) {
      var kept = [];
      var removed2 = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed2.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed2;
    }
    return h(tag, null, children);
  },
  updated: function updated2() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || "v") + "-move";
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);
    this._reflow = document.body.offsetHeight;
    children.forEach(function(c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = "";
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove) {
        return this._hasMove;
      }
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function(cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = "none";
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};
function callPendingCbs(c) {
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}
function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = "0s";
  }
}
var platformComponents = {
  Transition,
  TransitionGroup
};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
Vue.prototype.__patch__ = inBrowser ? patch : noop;
Vue.prototype.$mount = function(el, hydrating) {
  el = el && inBrowser ? query(el) : void 0;
  return mountComponent(this, el, hydrating);
};
if (inBrowser) {
  setTimeout(function() {
    if (config.devtools) {
      if (devtools) {
        devtools.emit("init", Vue);
      } else if (true) {
        console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
      }
    }
    if (config.productionTip !== false && typeof console !== "undefined") {
      console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
var vue_runtime_esm_default = Vue;

// src/components/MarkdownLink.vue
var import_obsidian = __toModule(require("obsidian"));
var __vue_script__ = vue_runtime_esm_default.extend({
  data() {
    return {};
  },
  components: {},
  props: {
    href: "",
    path: ""
  },
  computed: {},
  mounted() {
    if (this.href != null) {
      import_obsidian.MarkdownRenderer.renderMarkdown(`<span>[[${this.href.replace(".md", "")}]]</span>`, this.$el, "Untitled", this);
    }
  }
});
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div");
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;
var __vue_inject_styles__ = void 0;
var __vue_scope_id__ = "data-v-8f166afc";
var __vue_module_identifier__ = void 0;
var __vue_is_functional_template__ = false;
function __vue_normalize__(template, style2, script, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  const component = (typeof script === "function" ? script.options : script) || {};
  component.__file = "src/components/MarkdownLink.vue";
  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional)
      component.functional = true;
  }
  component._scopeId = scope;
  if (false) {
    let hook;
    if (false) {
      hook = function(context) {
        context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style2) {
          style2.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      component._ssrRegister = hook;
    } else if (style2) {
      hook = shadowMode ? function(context) {
        style2.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
      } : function(context) {
        style2.call(this, createInjector(context));
      };
    }
    if (hook !== void 0) {
      if (component.functional) {
        const originalRender = component.render;
        component.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        const existing = component.beforeCreate;
        component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
  }
  return component;
}
var __vue_component__ = /* @__PURE__ */ __vue_normalize__({ render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, void 0, void 0, void 0);
var MarkdownLink_default = __vue_component__;

// node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n, max) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max), 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
  } else {
    n = n % max / parseFloat(String(max));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}

// node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h = 0;
  var s = 0;
  var l = (max + min) / 2;
  if (max === min) {
    s = 0;
    h = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * (6 * t);
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h = 0;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;
  if (max === min) {
    h = 0;
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}

// node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}

// node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor = function() {
  function TinyColor2(color, opts) {
    if (color === void 0) {
      color = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R;
    var G;
    var B;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R = RsRGB / 12.92;
    } else {
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B = BsRGB / 12.92;
    } else {
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r = Math.round(this.r);
    var g = Math.round(this.g);
    var b = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x) {
      return "".concat(Math.round(bound01(x, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x) {
      return Math.round(bound01(x, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      if (hex === value) {
        return key;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format) {
    var formatSet = Boolean(format);
    format = format !== null && format !== void 0 ? format : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p + rgb1.r,
      g: (rgb2.g - rgb1.g) * p + rgb1.g,
      b: (rgb2.b - rgb1.b) * p + rgb1.b,
      a: (rgb2.a - rgb1.a) * p + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h = hsv.h;
    var s = hsv.s;
    var v = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h, s, v }));
      v = (v + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n) {
    var hsl = this.toHsl();
    var h = hsl.h;
    var result = [this];
    var increment = 360 / n;
    for (var i = 1; i < n; i++) {
      result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();

// node_modules/vuetify/lib/mixins/themeable/index.js
var Themeable = vue_runtime_esm_default.extend().extend({
  name: "themeable",
  provide() {
    return {
      theme: this.themeableProvide
    };
  },
  inject: {
    theme: {
      default: {
        isDark: false
      }
    }
  },
  props: {
    dark: {
      type: Boolean,
      default: null
    },
    light: {
      type: Boolean,
      default: null
    }
  },
  data() {
    return {
      themeableProvide: {
        isDark: false
      }
    };
  },
  computed: {
    appIsDark() {
      return this.$vuetify.theme.dark || false;
    },
    isDark() {
      if (this.dark === true) {
        return true;
      } else if (this.light === true) {
        return false;
      } else {
        return this.theme.isDark;
      }
    },
    themeClasses() {
      return {
        "theme--dark": this.isDark,
        "theme--light": !this.isDark
      };
    },
    rootIsDark() {
      if (this.dark === true) {
        return true;
      } else if (this.light === true) {
        return false;
      } else {
        return this.appIsDark;
      }
    },
    rootThemeClasses() {
      return {
        "theme--dark": this.rootIsDark,
        "theme--light": !this.rootIsDark
      };
    }
  },
  watch: {
    isDark: {
      handler(newVal, oldVal) {
        if (newVal !== oldVal) {
          this.themeableProvide.isDark = this.isDark;
        }
      },
      immediate: true
    }
  }
});
var themeable_default = Themeable;
function functionalThemeClasses(context) {
  const vm = __spreadValues(__spreadValues({}, context.props), context.injections);
  const isDark = Themeable.options.computed.isDark.call(vm);
  return Themeable.options.computed.themeClasses.call({
    isDark
  });
}

// node_modules/vuetify/lib/util/mixins.js
function mixins(...args) {
  return vue_runtime_esm_default.extend({
    mixins: args
  });
}

// node_modules/vuetify/lib/components/VApp/VApp.js
var VApp_default = mixins(themeable_default).extend({
  name: "v-app",
  props: {
    dark: {
      type: Boolean,
      default: void 0
    },
    id: {
      type: String,
      default: "app"
    },
    light: {
      type: Boolean,
      default: void 0
    }
  },
  computed: {
    isDark() {
      return this.$vuetify.theme.dark;
    }
  },
  beforeCreate() {
    if (!this.$vuetify || this.$vuetify === this.$root) {
      throw new Error("Vuetify is not properly initialized, see https://vuetifyjs.com/getting-started/quick-start#bootstrapping-the-vuetify-object");
    }
  },
  render(h) {
    const wrapper = h("div", {
      staticClass: "v-application--wrap"
    }, this.$slots.default);
    return h("div", {
      staticClass: "v-application",
      class: __spreadValues({
        "v-application--is-rtl": this.$vuetify.rtl,
        "v-application--is-ltr": !this.$vuetify.rtl
      }, this.themeClasses),
      attrs: {
        "data-app": true
      },
      domProps: {
        id: this.id
      }
    }, [wrapper]);
  }
});

// node_modules/vuetify/lib/mixins/binds-attrs/index.js
function makeWatcher(property) {
  return function(val, oldVal) {
    for (const attr in oldVal) {
      if (!Object.prototype.hasOwnProperty.call(val, attr)) {
        this.$delete(this.$data[property], attr);
      }
    }
    for (const attr in val) {
      this.$set(this.$data[property], attr, val[attr]);
    }
  };
}
var binds_attrs_default = vue_runtime_esm_default.extend({
  data: () => ({
    attrs$: {},
    listeners$: {}
  }),
  created() {
    this.$watch("$attrs", makeWatcher("attrs$"), {
      immediate: true
    });
    this.$watch("$listeners", makeWatcher("listeners$"), {
      immediate: true
    });
  }
});

// node_modules/vuetify/lib/install.js
function install(Vue2, args = {}) {
  if (install.installed)
    return;
  install.installed = true;
  if (vue_runtime_esm_default !== Vue2) {
    consoleError(`Multiple instances of Vue detected
See https://github.com/vuetifyjs/vuetify/issues/4068

If you're seeing "$attrs is readonly", it's caused by this`);
  }
  const components = args.components || {};
  const directives2 = args.directives || {};
  for (const name in directives2) {
    const directive4 = directives2[name];
    Vue2.directive(name, directive4);
  }
  (function registerComponents(components2) {
    if (components2) {
      for (const key in components2) {
        const component = components2[key];
        if (component && !registerComponents(component.$_vuetify_subcomponents)) {
          Vue2.component(key, component);
        }
      }
      return true;
    }
    return false;
  })(components);
  if (Vue2.$_vuetify_installed)
    return;
  Vue2.$_vuetify_installed = true;
  Vue2.mixin({
    beforeCreate() {
      const options = this.$options;
      if (options.vuetify) {
        options.vuetify.init(this, this.$ssrContext);
        this.$vuetify = Vue2.observable(options.vuetify.framework);
      } else {
        this.$vuetify = options.parent && options.parent.$vuetify || this;
      }
    },
    beforeMount() {
      if (this.$options.vuetify && this.$el && this.$el.hasAttribute("data-server-rendered")) {
        this.$vuetify.isHydrating = true;
        this.$vuetify.breakpoint.update(true);
      }
    },
    mounted() {
      if (this.$options.vuetify && this.$vuetify.isHydrating) {
        this.$vuetify.isHydrating = false;
        this.$vuetify.breakpoint.update();
      }
    }
  });
}

// node_modules/vuetify/lib/services/service/index.js
var Service = class {
  constructor() {
    this.framework = {};
  }
  init(root, ssrContext) {
  }
};

// node_modules/vuetify/lib/services/application/index.js
var Application = class extends Service {
  constructor() {
    super(...arguments);
    this.bar = 0;
    this.top = 0;
    this.left = 0;
    this.insetFooter = 0;
    this.right = 0;
    this.bottom = 0;
    this.footer = 0;
    this.application = {
      bar: {},
      top: {},
      left: {},
      insetFooter: {},
      right: {},
      bottom: {},
      footer: {}
    };
  }
  register(uid2, location, size) {
    this.application[location][uid2] = size;
    this.update(location);
  }
  unregister(uid2, location) {
    if (this.application[location][uid2] == null)
      return;
    delete this.application[location][uid2];
    this.update(location);
  }
  update(location) {
    this[location] = Object.values(this.application[location]).reduce((acc, cur) => acc + cur, 0);
  }
};
Application.property = "application";

// node_modules/vuetify/lib/services/breakpoint/index.js
var Breakpoint = class extends Service {
  constructor(preset2) {
    super();
    this.xs = false;
    this.sm = false;
    this.md = false;
    this.lg = false;
    this.xl = false;
    this.xsOnly = false;
    this.smOnly = false;
    this.smAndDown = false;
    this.smAndUp = false;
    this.mdOnly = false;
    this.mdAndDown = false;
    this.mdAndUp = false;
    this.lgOnly = false;
    this.lgAndDown = false;
    this.lgAndUp = false;
    this.xlOnly = false;
    this.name = "xs";
    this.height = 0;
    this.width = 0;
    this.mobile = true;
    this.resizeTimeout = 0;
    const {
      mobileBreakpoint,
      scrollBarWidth,
      thresholds
    } = preset2[Breakpoint.property];
    this.mobileBreakpoint = mobileBreakpoint;
    this.scrollBarWidth = scrollBarWidth;
    this.thresholds = thresholds;
  }
  init() {
    this.update();
    if (typeof window === "undefined")
      return;
    window.addEventListener("resize", this.onResize.bind(this), {
      passive: true
    });
  }
  update(ssr = false) {
    const height = ssr ? 0 : this.getClientHeight();
    const width = ssr ? 0 : this.getClientWidth();
    const xs = width < this.thresholds.xs;
    const sm = width < this.thresholds.sm && !xs;
    const md = width < this.thresholds.md - this.scrollBarWidth && !(sm || xs);
    const lg = width < this.thresholds.lg - this.scrollBarWidth && !(md || sm || xs);
    const xl = width >= this.thresholds.lg - this.scrollBarWidth;
    this.height = height;
    this.width = width;
    this.xs = xs;
    this.sm = sm;
    this.md = md;
    this.lg = lg;
    this.xl = xl;
    this.xsOnly = xs;
    this.smOnly = sm;
    this.smAndDown = (xs || sm) && !(md || lg || xl);
    this.smAndUp = !xs && (sm || md || lg || xl);
    this.mdOnly = md;
    this.mdAndDown = (xs || sm || md) && !(lg || xl);
    this.mdAndUp = !(xs || sm) && (md || lg || xl);
    this.lgOnly = lg;
    this.lgAndDown = (xs || sm || md || lg) && !xl;
    this.lgAndUp = !(xs || sm || md) && (lg || xl);
    this.xlOnly = xl;
    switch (true) {
      case xs:
        this.name = "xs";
        break;
      case sm:
        this.name = "sm";
        break;
      case md:
        this.name = "md";
        break;
      case lg:
        this.name = "lg";
        break;
      default:
        this.name = "xl";
        break;
    }
    if (typeof this.mobileBreakpoint === "number") {
      this.mobile = width < parseInt(this.mobileBreakpoint, 10);
      return;
    }
    const breakpoints3 = {
      xs: 0,
      sm: 1,
      md: 2,
      lg: 3,
      xl: 4
    };
    const current = breakpoints3[this.name];
    const max = breakpoints3[this.mobileBreakpoint];
    this.mobile = current <= max;
  }
  onResize() {
    clearTimeout(this.resizeTimeout);
    this.resizeTimeout = window.setTimeout(this.update.bind(this), 200);
  }
  getClientWidth() {
    if (typeof document === "undefined")
      return 0;
    return Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  }
  getClientHeight() {
    if (typeof document === "undefined")
      return 0;
    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  }
};
Breakpoint.property = "breakpoint";

// node_modules/vuetify/lib/services/goto/easing-patterns.js
var easing_patterns_exports = {};
__export(easing_patterns_exports, {
  easeInCubic: () => easeInCubic,
  easeInOutCubic: () => easeInOutCubic,
  easeInOutQuad: () => easeInOutQuad,
  easeInOutQuart: () => easeInOutQuart,
  easeInOutQuint: () => easeInOutQuint,
  easeInQuad: () => easeInQuad,
  easeInQuart: () => easeInQuart,
  easeInQuint: () => easeInQuint,
  easeOutCubic: () => easeOutCubic,
  easeOutQuad: () => easeOutQuad,
  easeOutQuart: () => easeOutQuart,
  easeOutQuint: () => easeOutQuint,
  linear: () => linear
});
var linear = (t) => t;
var easeInQuad = (t) => t ** 2;
var easeOutQuad = (t) => t * (2 - t);
var easeInOutQuad = (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t;
var easeInCubic = (t) => t ** 3;
var easeOutCubic = (t) => --t ** 3 + 1;
var easeInOutCubic = (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
var easeInQuart = (t) => t ** 4;
var easeOutQuart = (t) => 1 - --t ** 4;
var easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
var easeInQuint = (t) => t ** 5;
var easeOutQuint = (t) => 1 + --t ** 5;
var easeInOutQuint = (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5;

// node_modules/vuetify/lib/services/goto/util.js
function getOffset(target2) {
  if (typeof target2 === "number") {
    return target2;
  }
  let el = $(target2);
  if (!el) {
    throw typeof target2 === "string" ? new Error(`Target element "${target2}" not found.`) : new TypeError(`Target must be a Number/Selector/HTMLElement/VueComponent, received ${type(target2)} instead.`);
  }
  let totalOffset = 0;
  while (el) {
    totalOffset += el.offsetTop;
    el = el.offsetParent;
  }
  return totalOffset;
}
function getContainer(container) {
  const el = $(container);
  if (el)
    return el;
  throw typeof container === "string" ? new Error(`Container element "${container}" not found.`) : new TypeError(`Container must be a Selector/HTMLElement/VueComponent, received ${type(container)} instead.`);
}
function type(el) {
  return el == null ? el : el.constructor.name;
}
function $(el) {
  if (typeof el === "string") {
    return document.querySelector(el);
  } else if (el && el._isVue) {
    return el.$el;
  } else if (el instanceof HTMLElement) {
    return el;
  } else {
    return null;
  }
}

// node_modules/vuetify/lib/services/goto/index.js
function goTo(_target, _settings = {}) {
  const settings = __spreadValues({
    container: document.scrollingElement || document.body || document.documentElement,
    duration: 500,
    offset: 0,
    easing: "easeInOutCubic",
    appOffset: true
  }, _settings);
  const container = getContainer(settings.container);
  if (settings.appOffset && goTo.framework.application) {
    const isDrawer = container.classList.contains("v-navigation-drawer");
    const isClipped = container.classList.contains("v-navigation-drawer--clipped");
    const {
      bar,
      top
    } = goTo.framework.application;
    settings.offset += bar;
    if (!isDrawer || isClipped)
      settings.offset += top;
  }
  const startTime = performance.now();
  let targetLocation;
  if (typeof _target === "number") {
    targetLocation = getOffset(_target) - settings.offset;
  } else {
    targetLocation = getOffset(_target) - getOffset(container) - settings.offset;
  }
  const startLocation = container.scrollTop;
  if (targetLocation === startLocation)
    return Promise.resolve(targetLocation);
  const ease = typeof settings.easing === "function" ? settings.easing : easing_patterns_exports[settings.easing];
  if (!ease)
    throw new TypeError(`Easing function "${settings.easing}" not found.`);
  return new Promise((resolve) => requestAnimationFrame(function step(currentTime) {
    const timeElapsed = currentTime - startTime;
    const progress = Math.abs(settings.duration ? Math.min(timeElapsed / settings.duration, 1) : 1);
    container.scrollTop = Math.floor(startLocation + (targetLocation - startLocation) * ease(progress));
    const clientHeight = container === document.body ? document.documentElement.clientHeight : container.clientHeight;
    const reachBottom = clientHeight + container.scrollTop >= container.scrollHeight;
    if (progress === 1 || targetLocation > container.scrollTop && reachBottom) {
      return resolve(targetLocation);
    }
    requestAnimationFrame(step);
  }));
}
goTo.framework = {};
goTo.init = () => {
};
var Goto = class extends Service {
  constructor() {
    super();
    return goTo;
  }
};
Goto.property = "goTo";

// node_modules/vuetify/lib/util/helpers.js
function createSimpleFunctional(c, el = "div", name) {
  return vue_runtime_esm_default.extend({
    name: name || c.replace(/__/g, "-"),
    functional: true,
    props: {
      tag: {
        type: String,
        default: el
      }
    },
    render(h, {
      data,
      props: props2,
      children
    }) {
      data.staticClass = `${c} ${data.staticClass || ""}`.trim();
      return h(props2.tag, data, children);
    }
  });
}
function addOnceEventListener(el, eventName, cb, options = false) {
  const once2 = (event) => {
    cb(event);
    el.removeEventListener(eventName, once2, options);
  };
  el.addEventListener(eventName, once2, options);
}
var passiveSupported = false;
try {
  if (typeof window !== "undefined") {
    const testListenerOpts = Object.defineProperty({}, "passive", {
      get: () => {
        passiveSupported = true;
      }
    });
    window.addEventListener("testListener", testListenerOpts, testListenerOpts);
    window.removeEventListener("testListener", testListenerOpts, testListenerOpts);
  }
} catch (e) {
  console.warn(e);
}
function getNestedValue(obj, path, fallback2) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback2 : obj;
  for (let i = 0; i < last; i++) {
    if (obj == null) {
      return fallback2;
    }
    obj = obj[path[i]];
  }
  if (obj == null)
    return fallback2;
  return obj[path[last]] === void 0 ? fallback2 : obj[path[last]];
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
    return false;
  }
  if (a !== Object(a) || b !== Object(b)) {
    return false;
  }
  const props2 = Object.keys(a);
  if (props2.length !== Object.keys(b).length) {
    return false;
  }
  return props2.every((p) => deepEqual(a[p], b[p]));
}
function getObjectValueByPath(obj, path, fallback2) {
  if (obj == null || !path || typeof path !== "string")
    return fallback2;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback2);
}
function getPropertyFromItem(item, property, fallback2) {
  if (property == null)
    return item === void 0 ? fallback2 : item;
  if (item !== Object(item))
    return fallback2 === void 0 ? item : fallback2;
  if (typeof property === "string")
    return getObjectValueByPath(item, property, fallback2);
  if (Array.isArray(property))
    return getNestedValue(item, property, fallback2);
  if (typeof property !== "function")
    return fallback2;
  const value = property(item, fallback2);
  return typeof value === "undefined" ? fallback2 : value;
}
function createRange(length) {
  return Array.from({
    length
  }, (v, k) => k);
}
function getZIndex(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return 0;
  const index2 = +window.getComputedStyle(el).getPropertyValue("z-index");
  if (!index2)
    return getZIndex(el.parentNode);
  return index2;
}
var tagsToReplace = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escapeHTML(str) {
  return str.replace(/[&<>]/g, (tag) => tagsToReplace[tag] || tag);
}
function filterObjectOnKeys(obj, keys2) {
  const filtered = {};
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (typeof obj[key] !== "undefined") {
      filtered[key] = obj[key];
    }
  }
  return filtered;
}
function convertToUnit(str, unit = "px") {
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else {
    return `${Number(str)}${unit}`;
  }
}
function kebabCase(str) {
  return (str || "").replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function isObject2(obj) {
  return obj !== null && typeof obj === "object";
}
var keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
function remapInternalIcon(vm, iconName) {
  const component = vm.$vuetify.icons.component;
  if (iconName.startsWith("$")) {
    const iconPath = `$vuetify.icons.values.${iconName.split("$").pop().split(".").pop()}`;
    const override = getObjectValueByPath(vm, iconPath, iconName);
    if (typeof override === "string")
      iconName = override;
    else
      return override;
  }
  if (component == null) {
    return iconName;
  }
  return {
    component,
    props: {
      icon: iconName
    }
  };
}
function keys(o) {
  return Object.keys(o);
}
var camelizeRE2 = /-(\w)/g;
var camelize2 = (str) => {
  return str.replace(camelizeRE2, (_, c) => c ? c.toUpperCase() : "");
};
function upperFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function groupItems(items, groupBy, groupDesc) {
  const key = groupBy[0];
  const groups = [];
  let current;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    const val = getObjectValueByPath(item, key, null);
    if (current !== val) {
      current = val;
      groups.push({
        name: val != null ? val : "",
        items: []
      });
    }
    groups[groups.length - 1].items.push(item);
  }
  return groups;
}
function wrapInArray(v) {
  return v != null ? Array.isArray(v) ? v : [v] : [];
}
function sortItems(items, sortBy, sortDesc, locale, customSorters) {
  if (sortBy === null || !sortBy.length)
    return items;
  const stringCollator = new Intl.Collator(locale, {
    sensitivity: "accent",
    usage: "sort"
  });
  return items.sort((a, b) => {
    for (let i = 0; i < sortBy.length; i++) {
      const sortKey = sortBy[i];
      let sortA = getObjectValueByPath(a, sortKey);
      let sortB = getObjectValueByPath(b, sortKey);
      if (sortDesc[i]) {
        [sortA, sortB] = [sortB, sortA];
      }
      if (customSorters && customSorters[sortKey]) {
        const customResult = customSorters[sortKey](sortA, sortB);
        if (!customResult)
          continue;
        return customResult;
      }
      if (sortA === null && sortB === null) {
        continue;
      }
      if (sortA instanceof Date && sortB instanceof Date) {
        return sortA.getTime() - sortB.getTime();
      }
      [sortA, sortB] = [sortA, sortB].map((s) => (s || "").toString().toLocaleLowerCase());
      if (sortA !== sortB) {
        if (!isNaN(sortA) && !isNaN(sortB))
          return Number(sortA) - Number(sortB);
        return stringCollator.compare(sortA, sortB);
      }
    }
    return 0;
  });
}
function defaultFilter(value, search, item) {
  return value != null && search != null && typeof value !== "boolean" && value.toString().toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) !== -1;
}
function searchItems(items, search) {
  if (!search)
    return items;
  search = search.toString().toLowerCase();
  if (search.trim() === "")
    return items;
  return items.filter((item) => Object.keys(item).some((key) => defaultFilter(getObjectValueByPath(item, key), search, item)));
}
function getSlotType(vm, name, split) {
  if (vm.$slots.hasOwnProperty(name) && vm.$scopedSlots.hasOwnProperty(name) && vm.$scopedSlots[name].name) {
    return split ? "v-slot" : "scoped";
  }
  if (vm.$slots.hasOwnProperty(name))
    return "normal";
  if (vm.$scopedSlots.hasOwnProperty(name))
    return "scoped";
}
function getPrefixedScopedSlots(prefix, scopedSlots) {
  return Object.keys(scopedSlots).filter((k) => k.startsWith(prefix)).reduce((obj, k) => {
    obj[k.replace(prefix, "")] = scopedSlots[k];
    return obj;
  }, {});
}
function getSlot(vm, name = "default", data, optional = false) {
  if (vm.$scopedSlots.hasOwnProperty(name)) {
    return vm.$scopedSlots[name](data instanceof Function ? data() : data);
  } else if (vm.$slots.hasOwnProperty(name) && (!data || optional)) {
    return vm.$slots[name];
  }
  return void 0;
}
function clamp(value, min = 0, max = 1) {
  return Math.max(min, Math.min(max, value));
}
function camelizeObjectKeys(obj) {
  if (!obj)
    return {};
  return Object.keys(obj).reduce((o, key) => {
    o[camelize2(key)] = obj[key];
    return o;
  }, {});
}
function mergeDeep(source = {}, target2 = {}) {
  for (const key in target2) {
    const sourceProperty = source[key];
    const targetProperty = target2[key];
    if (isObject2(sourceProperty) && isObject2(targetProperty)) {
      source[key] = mergeDeep(sourceProperty, targetProperty);
      continue;
    }
    source[key] = targetProperty;
  }
  return source;
}
function fillArray(length, obj) {
  return Array(length).fill(obj);
}

// node_modules/vuetify/lib/services/icons/presets/mdi-svg.js
var icons = {
  complete: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z",
  cancel: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
  close: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
  delete: "M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z",
  clear: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z",
  success: "M12,2C17.52,2 22,6.48 22,12C22,17.52 17.52,22 12,22C6.48,22 2,17.52 2,12C2,6.48 6.48,2 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z",
  info: "M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
  warning: "M11,4.5H13V15.5H11V4.5M13,17.5V19.5H11V17.5H13Z",
  error: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z",
  prev: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z",
  next: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z",
  checkboxOn: "M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
  checkboxOff: "M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z",
  checkboxIndeterminate: "M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z",
  delimiter: "M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
  sort: "M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z",
  expand: "M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z",
  menu: "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z",
  subgroup: "M7,10L12,15L17,10H7Z",
  dropdown: "M7,10L12,15L17,10H7Z",
  radioOn: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z",
  radioOff: "M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z",
  edit: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z",
  ratingEmpty: "M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
  ratingFull: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z",
  ratingHalf: "M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z",
  loading: "M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12",
  first: "M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z",
  last: "M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z",
  unfold: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z",
  file: "M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z",
  plus: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z",
  minus: "M19,13H5V11H19V13Z"
};
var mdi_svg_default = icons;

// node_modules/vuetify/lib/services/icons/presets/md.js
var icons2 = {
  complete: "check",
  cancel: "cancel",
  close: "close",
  delete: "cancel",
  clear: "clear",
  success: "check_circle",
  info: "info",
  warning: "priority_high",
  error: "warning",
  prev: "chevron_left",
  next: "chevron_right",
  checkboxOn: "check_box",
  checkboxOff: "check_box_outline_blank",
  checkboxIndeterminate: "indeterminate_check_box",
  delimiter: "fiber_manual_record",
  sort: "arrow_upward",
  expand: "keyboard_arrow_down",
  menu: "menu",
  subgroup: "arrow_drop_down",
  dropdown: "arrow_drop_down",
  radioOn: "radio_button_checked",
  radioOff: "radio_button_unchecked",
  edit: "edit",
  ratingEmpty: "star_border",
  ratingFull: "star",
  ratingHalf: "star_half",
  loading: "cached",
  first: "first_page",
  last: "last_page",
  unfold: "unfold_more",
  file: "attach_file",
  plus: "add",
  minus: "remove"
};
var md_default = icons2;

// node_modules/vuetify/lib/services/icons/presets/mdi.js
var icons3 = {
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  clear: "mdi-close",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-exclamation",
  error: "mdi-alert",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  sort: "mdi-arrow-up",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus"
};
var mdi_default = icons3;

// node_modules/vuetify/lib/services/icons/presets/fa.js
var icons4 = {
  complete: "fas fa-check",
  cancel: "fas fa-times-circle",
  close: "fas fa-times",
  delete: "fas fa-times-circle",
  clear: "fas fa-times-circle",
  success: "fas fa-check-circle",
  info: "fas fa-info-circle",
  warning: "fas fa-exclamation",
  error: "fas fa-exclamation-triangle",
  prev: "fas fa-chevron-left",
  next: "fas fa-chevron-right",
  checkboxOn: "fas fa-check-square",
  checkboxOff: "far fa-square",
  checkboxIndeterminate: "fas fa-minus-square",
  delimiter: "fas fa-circle",
  sort: "fas fa-sort-up",
  expand: "fas fa-chevron-down",
  menu: "fas fa-bars",
  subgroup: "fas fa-caret-down",
  dropdown: "fas fa-caret-down",
  radioOn: "far fa-dot-circle",
  radioOff: "far fa-circle",
  edit: "fas fa-edit",
  ratingEmpty: "far fa-star",
  ratingFull: "fas fa-star",
  ratingHalf: "fas fa-star-half",
  loading: "fas fa-sync",
  first: "fas fa-step-backward",
  last: "fas fa-step-forward",
  unfold: "fas fa-arrows-alt-v",
  file: "fas fa-paperclip",
  plus: "fas fa-plus",
  minus: "fas fa-minus"
};
var fa_default = icons4;

// node_modules/vuetify/lib/services/icons/presets/fa4.js
var icons5 = {
  complete: "fa fa-check",
  cancel: "fa fa-times-circle",
  close: "fa fa-times",
  delete: "fa fa-times-circle",
  clear: "fa fa-times-circle",
  success: "fa fa-check-circle",
  info: "fa fa-info-circle",
  warning: "fa fa-exclamation",
  error: "fa fa-exclamation-triangle",
  prev: "fa fa-chevron-left",
  next: "fa fa-chevron-right",
  checkboxOn: "fa fa-check-square",
  checkboxOff: "fa fa-square-o",
  checkboxIndeterminate: "fa fa-minus-square",
  delimiter: "fa fa-circle",
  sort: "fa fa-sort-up",
  expand: "fa fa-chevron-down",
  menu: "fa fa-bars",
  subgroup: "fa fa-caret-down",
  dropdown: "fa fa-caret-down",
  radioOn: "fa fa-dot-circle-o",
  radioOff: "fa fa-circle-o",
  edit: "fa fa-pencil",
  ratingEmpty: "fa fa-star-o",
  ratingFull: "fa fa-star",
  ratingHalf: "fa fa-star-half-o",
  loading: "fa fa-refresh",
  first: "fa fa-step-backward",
  last: "fa fa-step-forward",
  unfold: "fa fa-angle-double-down",
  file: "fa fa-paperclip",
  plus: "fa fa-plus",
  minus: "fa fa-minus"
};
var fa4_default = icons5;

// node_modules/vuetify/lib/services/icons/presets/fa-svg.js
function convertToComponentDeclarations(component, iconSet) {
  const result = {};
  for (const key in iconSet) {
    result[key] = {
      component,
      props: {
        icon: iconSet[key].split(" fa-")
      }
    };
  }
  return result;
}
var fa_svg_default = convertToComponentDeclarations("font-awesome-icon", fa_default);

// node_modules/vuetify/lib/services/icons/presets/index.js
var presets_default = Object.freeze({
  mdiSvg: mdi_svg_default,
  md: md_default,
  mdi: mdi_default,
  fa: fa_default,
  fa4: fa4_default,
  faSvg: fa_svg_default
});

// node_modules/vuetify/lib/services/icons/index.js
var Icons = class extends Service {
  constructor(preset2) {
    super();
    const {
      iconfont,
      values,
      component
    } = preset2[Icons.property];
    this.component = component;
    this.iconfont = iconfont;
    this.values = mergeDeep(presets_default[iconfont], values);
  }
};
Icons.property = "icons";

// node_modules/vuetify/lib/services/lang/index.js
var LANG_PREFIX = "$vuetify.";
var fallback = Symbol("Lang fallback");
function getTranslation(locale, key, usingDefault = false, defaultLocale) {
  const shortKey = key.replace(LANG_PREFIX, "");
  let translation = getObjectValueByPath(locale, shortKey, fallback);
  if (translation === fallback) {
    if (usingDefault) {
      consoleError(`Translation key "${shortKey}" not found in fallback`);
      translation = key;
    } else {
      consoleWarn(`Translation key "${shortKey}" not found, falling back to default`);
      translation = getTranslation(defaultLocale, key, true, defaultLocale);
    }
  }
  return translation;
}
var Lang = class extends Service {
  constructor(preset2) {
    super();
    this.defaultLocale = "en";
    const {
      current,
      locales,
      t
    } = preset2[Lang.property];
    this.current = current;
    this.locales = locales;
    this.translator = t || this.defaultTranslator;
  }
  currentLocale(key) {
    const translation = this.locales[this.current];
    const defaultLocale = this.locales[this.defaultLocale];
    return getTranslation(translation, key, false, defaultLocale);
  }
  t(key, ...params) {
    if (!key.startsWith(LANG_PREFIX))
      return this.replace(key, params);
    return this.translator(key, ...params);
  }
  defaultTranslator(key, ...params) {
    return this.replace(this.currentLocale(key), params);
  }
  replace(str, params) {
    return str.replace(/\{(\d+)\}/g, (match, index2) => {
      return String(params[+index2]);
    });
  }
};
Lang.property = "lang";

// node_modules/vuetify/lib/locale/en.js
var en_default = {
  badge: "Badge",
  close: "Close",
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    nextMonthAriaLabel: "Next month",
    nextYearAriaLabel: "Next year",
    prevMonthAriaLabel: "Previous month",
    prevYearAriaLabel: "Previous year"
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      wrapper: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Goto Page {0}",
      currentPage: "Current Page, Page {0}"
    }
  },
  rating: {
    ariaLabel: {
      icon: "Rating {0} of {1}"
    }
  }
};

// node_modules/vuetify/lib/presets/default/index.js
var preset = {
  breakpoint: {
    mobileBreakpoint: 1264,
    scrollBarWidth: 16,
    thresholds: {
      xs: 600,
      sm: 960,
      md: 1280,
      lg: 1920
    }
  },
  icons: {
    iconfont: "mdi",
    values: {}
  },
  lang: {
    current: "en",
    locales: {
      en: en_default
    },
    t: void 0
  },
  rtl: false,
  theme: {
    dark: false,
    default: "light",
    disable: false,
    options: {
      cspNonce: void 0,
      customProperties: void 0,
      minifyTheme: void 0,
      themeCache: void 0,
      variations: true
    },
    themes: {
      light: {
        primary: "#1976D2",
        secondary: "#424242",
        accent: "#82B1FF",
        error: "#FF5252",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      dark: {
        primary: "#2196F3",
        secondary: "#424242",
        accent: "#FF4081",
        error: "#FF5252",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      }
    }
  }
};

// node_modules/vuetify/lib/services/presets/index.js
var Presets = class extends Service {
  constructor(parentPreset, parent) {
    super();
    const defaultPreset = mergeDeep({}, preset);
    const {
      userPreset
    } = parent;
    const _a = userPreset, {
      preset: globalPreset = {}
    } = _a, preset2 = __objRest(_a, [
      "preset"
    ]);
    if (globalPreset.preset != null) {
      consoleWarn("Global presets do not support the **preset** option, it can be safely omitted");
    }
    parent.preset = mergeDeep(mergeDeep(defaultPreset, globalPreset), preset2);
  }
};
Presets.property = "presets";

// node_modules/vuetify/lib/util/color/transformSRGB.js
var srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
var srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
var srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
var srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
  const rgb = Array(3);
  const transform2 = srgbForwardTransform;
  const matrix = srgbForwardMatrix;
  for (let i = 0; i < 3; ++i) {
    rgb[i] = Math.round(clamp(transform2(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
  }
  return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0);
}
function toXYZ(rgb) {
  const xyz = [0, 0, 0];
  const transform2 = srgbReverseTransform;
  const matrix = srgbReverseMatrix;
  const r = transform2((rgb >> 16 & 255) / 255);
  const g = transform2((rgb >> 8 & 255) / 255);
  const b = transform2((rgb >> 0 & 255) / 255);
  for (let i = 0; i < 3; ++i) {
    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;
  }
  return xyz;
}

// node_modules/vuetify/lib/util/colorUtils.js
function isCssColor(color) {
  return !!color && !!color.match(/^(#|var\(--|(rgb|hsl)a?\()/);
}
function colorToInt(color) {
  let rgb;
  if (typeof color === "number") {
    rgb = color;
  } else if (typeof color === "string") {
    let c = color[0] === "#" ? color.substring(1) : color;
    if (c.length === 3) {
      c = c.split("").map((char) => char + char).join("");
    }
    if (c.length !== 6) {
      consoleWarn(`'${color}' is not a valid rgb color`);
    }
    rgb = parseInt(c, 16);
  } else {
    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`);
  }
  if (rgb < 0) {
    consoleWarn(`Colors cannot be negative: '${color}'`);
    rgb = 0;
  } else if (rgb > 16777215 || isNaN(rgb)) {
    consoleWarn(`'${color}' is not a valid rgb color`);
    rgb = 16777215;
  }
  return rgb;
}
function intToHex(color) {
  let hexColor = color.toString(16);
  if (hexColor.length < 6)
    hexColor = "0".repeat(6 - hexColor.length) + hexColor;
  return "#" + hexColor;
}
function colorToHex(color) {
  return intToHex(colorToInt(color));
}

// node_modules/vuetify/lib/util/color/transformCIELAB.js
var delta = 0.20689655172413793;
var cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
var cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ2(xyz) {
  const transform2 = cielabForwardTransform;
  const transformedY = transform2(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
}
function toXYZ2(lab) {
  const transform2 = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
}

// node_modules/vuetify/lib/services/theme/utils.js
function parse(theme, isItem = false, variations = true) {
  const _a = theme, {
    anchor
  } = _a, variant = __objRest(_a, [
    "anchor"
  ]);
  const colors = Object.keys(variant);
  const parsedTheme = {};
  for (let i = 0; i < colors.length; ++i) {
    const name = colors[i];
    const value = theme[name];
    if (value == null)
      continue;
    if (!variations) {
      parsedTheme[name] = {
        base: intToHex(colorToInt(value))
      };
    } else if (isItem) {
      if (name === "base" || name.startsWith("lighten") || name.startsWith("darken")) {
        parsedTheme[name] = colorToHex(value);
      }
    } else if (typeof value === "object") {
      parsedTheme[name] = parse(value, true, variations);
    } else {
      parsedTheme[name] = genVariations(name, colorToInt(value));
    }
  }
  if (!isItem) {
    parsedTheme.anchor = anchor || parsedTheme.base || parsedTheme.primary.base;
  }
  return parsedTheme;
}
var genBaseColor = (name, value) => {
  return `
.v-application .${name} {
  background-color: ${value} !important;
  border-color: ${value} !important;
}
.v-application .${name}--text {
  color: ${value} !important;
  caret-color: ${value} !important;
}`;
};
var genVariantColor = (name, variant, value) => {
  const [type2, n] = variant.split(/(\d)/, 2);
  return `
.v-application .${name}.${type2}-${n} {
  background-color: ${value} !important;
  border-color: ${value} !important;
}
.v-application .${name}--text.text--${type2}-${n} {
  color: ${value} !important;
  caret-color: ${value} !important;
}`;
};
var genColorVariableName = (name, variant = "base") => `--v-${name}-${variant}`;
var genColorVariable = (name, variant = "base") => `var(${genColorVariableName(name, variant)})`;
function genStyles(theme, cssVar = false) {
  const _a = theme, {
    anchor
  } = _a, variant = __objRest(_a, [
    "anchor"
  ]);
  const colors = Object.keys(variant);
  if (!colors.length)
    return "";
  let variablesCss = "";
  let css = "";
  const aColor = cssVar ? genColorVariable("anchor") : anchor;
  css += `.v-application a { color: ${aColor}; }`;
  cssVar && (variablesCss += `  ${genColorVariableName("anchor")}: ${anchor};
`);
  for (let i = 0; i < colors.length; ++i) {
    const name = colors[i];
    const value = theme[name];
    css += genBaseColor(name, cssVar ? genColorVariable(name) : value.base);
    cssVar && (variablesCss += `  ${genColorVariableName(name)}: ${value.base};
`);
    const variants = keys(value);
    for (let i2 = 0; i2 < variants.length; ++i2) {
      const variant2 = variants[i2];
      const variantValue = value[variant2];
      if (variant2 === "base")
        continue;
      css += genVariantColor(name, variant2, cssVar ? genColorVariable(name, variant2) : variantValue);
      cssVar && (variablesCss += `  ${genColorVariableName(name, variant2)}: ${variantValue};
`);
    }
  }
  if (cssVar) {
    variablesCss = `:root {
${variablesCss}}

`;
  }
  return variablesCss + css;
}
function genVariations(name, value) {
  const values = {
    base: intToHex(value)
  };
  for (let i = 5; i > 0; --i) {
    values[`lighten${i}`] = intToHex(lighten(value, i));
  }
  for (let i = 1; i <= 4; ++i) {
    values[`darken${i}`] = intToHex(darken(value, i));
  }
  return values;
}
function lighten(value, amount) {
  const lab = fromXYZ2(toXYZ(value));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ(toXYZ2(lab));
}
function darken(value, amount) {
  const lab = fromXYZ2(toXYZ(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(toXYZ2(lab));
}

// node_modules/vuetify/lib/services/theme/index.js
var Theme = class extends Service {
  constructor(preset2) {
    super();
    this.disabled = false;
    this.isDark = null;
    this.unwatch = null;
    this.vueMeta = null;
    const {
      dark,
      disable,
      options,
      themes
    } = preset2[Theme.property];
    this.dark = Boolean(dark);
    this.defaults = this.themes = themes;
    this.options = options;
    if (disable) {
      this.disabled = true;
      return;
    }
    this.themes = {
      dark: this.fillVariant(themes.dark, true),
      light: this.fillVariant(themes.light, false)
    };
  }
  set css(val) {
    if (this.vueMeta) {
      if (this.isVueMeta23) {
        this.applyVueMeta23();
      }
      return;
    }
    this.checkOrCreateStyleElement() && (this.styleEl.innerHTML = val);
  }
  set dark(val) {
    const oldDark = this.isDark;
    this.isDark = val;
    oldDark != null && this.applyTheme();
  }
  get dark() {
    return Boolean(this.isDark);
  }
  applyTheme() {
    if (this.disabled)
      return this.clearCss();
    this.css = this.generatedStyles;
  }
  clearCss() {
    this.css = "";
  }
  init(root, ssrContext) {
    if (this.disabled)
      return;
    if (root.$meta) {
      this.initVueMeta(root);
    } else if (ssrContext) {
      this.initSSR(ssrContext);
    }
    this.initTheme(root);
  }
  setTheme(theme, value) {
    this.themes[theme] = Object.assign(this.themes[theme], value);
    this.applyTheme();
  }
  resetThemes() {
    this.themes.light = Object.assign({}, this.defaults.light);
    this.themes.dark = Object.assign({}, this.defaults.dark);
    this.applyTheme();
  }
  checkOrCreateStyleElement() {
    this.styleEl = document.getElementById("vuetify-theme-stylesheet");
    if (this.styleEl)
      return true;
    this.genStyleElement();
    return Boolean(this.styleEl);
  }
  fillVariant(theme = {}, dark) {
    const defaultTheme = this.themes[dark ? "dark" : "light"];
    return Object.assign({}, defaultTheme, theme);
  }
  genStyleElement() {
    if (typeof document === "undefined")
      return;
    this.styleEl = document.createElement("style");
    this.styleEl.type = "text/css";
    this.styleEl.id = "vuetify-theme-stylesheet";
    if (this.options.cspNonce) {
      this.styleEl.setAttribute("nonce", this.options.cspNonce);
    }
    document.head.appendChild(this.styleEl);
  }
  initVueMeta(root) {
    this.vueMeta = root.$meta();
    if (this.isVueMeta23) {
      root.$nextTick(() => {
        this.applyVueMeta23();
      });
      return;
    }
    const metaKeyName = typeof this.vueMeta.getOptions === "function" ? this.vueMeta.getOptions().keyName : "metaInfo";
    const metaInfo = root.$options[metaKeyName] || {};
    root.$options[metaKeyName] = () => {
      metaInfo.style = metaInfo.style || [];
      const vuetifyStylesheet = metaInfo.style.find((s) => s.id === "vuetify-theme-stylesheet");
      if (!vuetifyStylesheet) {
        metaInfo.style.push({
          cssText: this.generatedStyles,
          type: "text/css",
          id: "vuetify-theme-stylesheet",
          nonce: (this.options || {}).cspNonce
        });
      } else {
        vuetifyStylesheet.cssText = this.generatedStyles;
      }
      return metaInfo;
    };
  }
  applyVueMeta23() {
    const {
      set: set2
    } = this.vueMeta.addApp("vuetify");
    set2({
      style: [{
        cssText: this.generatedStyles,
        type: "text/css",
        id: "vuetify-theme-stylesheet",
        nonce: this.options.cspNonce
      }]
    });
  }
  initSSR(ssrContext) {
    const nonce = this.options.cspNonce ? ` nonce="${this.options.cspNonce}"` : "";
    ssrContext.head = ssrContext.head || "";
    ssrContext.head += `<style type="text/css" id="vuetify-theme-stylesheet"${nonce}>${this.generatedStyles}</style>`;
  }
  initTheme(root) {
    if (typeof document === "undefined")
      return;
    if (this.unwatch) {
      this.unwatch();
      this.unwatch = null;
    }
    root.$once("hook:created", () => {
      const obs = vue_runtime_esm_default.observable({
        themes: this.themes
      });
      this.unwatch = root.$watch(() => obs.themes, () => this.applyTheme(), {
        deep: true
      });
    });
    this.applyTheme();
  }
  get currentTheme() {
    const target2 = this.dark ? "dark" : "light";
    return this.themes[target2];
  }
  get generatedStyles() {
    const theme = this.parsedTheme;
    const options = this.options || {};
    let css;
    if (options.themeCache != null) {
      css = options.themeCache.get(theme);
      if (css != null)
        return css;
    }
    css = genStyles(theme, options.customProperties);
    if (options.minifyTheme != null) {
      css = options.minifyTheme(css);
    }
    if (options.themeCache != null) {
      options.themeCache.set(theme, css);
    }
    return css;
  }
  get parsedTheme() {
    return parse(this.currentTheme || {}, void 0, getNestedValue(this.options, ["variations"], true));
  }
  get isVueMeta23() {
    return typeof this.vueMeta.addApp === "function";
  }
};
Theme.property = "theme";

// node_modules/vuetify/lib/framework.js
var Vuetify = class {
  constructor(userPreset = {}) {
    this.framework = {
      isHydrating: false
    };
    this.installed = [];
    this.preset = {};
    this.userPreset = {};
    this.userPreset = userPreset;
    this.use(Presets);
    this.use(Application);
    this.use(Breakpoint);
    this.use(Goto);
    this.use(Icons);
    this.use(Lang);
    this.use(Theme);
  }
  init(root, ssrContext) {
    this.installed.forEach((property) => {
      const service = this.framework[property];
      service.framework = this.framework;
      service.init(root, ssrContext);
    });
    this.framework.rtl = Boolean(this.preset.rtl);
  }
  use(Service2) {
    const property = Service2.property;
    if (this.installed.includes(property))
      return;
    this.framework[property] = new Service2(this.preset, this);
    this.installed.push(property);
  }
};
Vuetify.install = install;
Vuetify.installed = false;
Vuetify.version = "2.6.4";
Vuetify.config = {
  silent: false
};

// node_modules/vuetify/lib/util/console.js
function createMessage(message, vm, parent) {
  if (Vuetify.config.silent)
    return;
  if (parent) {
    vm = {
      _isVue: true,
      $parent: parent,
      $options: vm
    };
  }
  if (vm) {
    vm.$_alreadyWarned = vm.$_alreadyWarned || [];
    if (vm.$_alreadyWarned.includes(message))
      return;
    vm.$_alreadyWarned.push(message);
  }
  return `[Vuetify] ${message}` + (vm ? generateComponentTrace2(vm) : "");
}
function consoleWarn(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.warn(newMessage);
}
function consoleError(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.error(newMessage);
}
function deprecate(original, replacement, vm, parent) {
  consoleWarn(`[UPGRADE] '${original}' is deprecated, use '${replacement}' instead.`, vm, parent);
}
function breaking(original, replacement, vm, parent) {
  consoleError(`[BREAKING] '${original}' has been removed, use '${replacement}' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide`, vm, parent);
}
function removed(original, vm, parent) {
  consoleWarn(`[REMOVED] '${original}' has been removed. You can safely omit it.`, vm, parent);
}
var classifyRE = /(?:^|[-_])(\w)/g;
var classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function formatComponentName2(vm, includeFile) {
  if (vm.$root === vm) {
    return "<Root>";
  }
  const options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
  let name = options.name || options._componentTag;
  const file = options.__file;
  if (!name && file) {
    const match = file.match(/([^/\\]+)\.vue$/);
    name = match && match[1];
  }
  return (name ? `<${classify(name)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
}
function generateComponentTrace2(vm) {
  if (vm._isVue && vm.$parent) {
    const tree = [];
    let currentRecursiveSequence = 0;
    while (vm) {
      if (tree.length > 0) {
        const last = tree[tree.length - 1];
        if (last.constructor === vm.constructor) {
          currentRecursiveSequence++;
          vm = vm.$parent;
          continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }
      tree.push(vm);
      vm = vm.$parent;
    }
    return "\n\nfound in\n\n" + tree.map((vm2, i) => `${i === 0 ? "---> " : " ".repeat(5 + i * 2)}${Array.isArray(vm2) ? `${formatComponentName2(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName2(vm2)}`).join("\n");
  } else {
    return `

(found in ${formatComponentName2(vm)})`;
  }
}

// node_modules/vuetify/lib/mixins/colorable/index.js
var colorable_default = vue_runtime_esm_default.extend({
  name: "colorable",
  props: {
    color: String
  },
  methods: {
    setBackgroundColor(color, data = {}) {
      if (typeof data.style === "string") {
        consoleError("style must be an object", this);
        return data;
      }
      if (typeof data.class === "string") {
        consoleError("class must be an object", this);
        return data;
      }
      if (isCssColor(color)) {
        data.style = __spreadProps(__spreadValues({}, data.style), {
          "background-color": `${color}`,
          "border-color": `${color}`
        });
      } else if (color) {
        data.class = __spreadProps(__spreadValues({}, data.class), {
          [color]: true
        });
      }
      return data;
    },
    setTextColor(color, data = {}) {
      if (typeof data.style === "string") {
        consoleError("style must be an object", this);
        return data;
      }
      if (typeof data.class === "string") {
        consoleError("class must be an object", this);
        return data;
      }
      if (isCssColor(color)) {
        data.style = __spreadProps(__spreadValues({}, data.style), {
          color: `${color}`,
          "caret-color": `${color}`
        });
      } else if (color) {
        const [colorName, colorModifier] = color.toString().trim().split(" ", 2);
        data.class = __spreadProps(__spreadValues({}, data.class), {
          [colorName + "--text"]: true
        });
        if (colorModifier) {
          data.class["text--" + colorModifier] = true;
        }
      }
      return data;
    }
  }
});

// node_modules/vuetify/lib/mixins/elevatable/index.js
var elevatable_default = vue_runtime_esm_default.extend({
  name: "elevatable",
  props: {
    elevation: [Number, String]
  },
  computed: {
    computedElevation() {
      return this.elevation;
    },
    elevationClasses() {
      const elevation = this.computedElevation;
      if (elevation == null)
        return {};
      if (isNaN(parseInt(elevation)))
        return {};
      return {
        [`elevation-${this.elevation}`]: true
      };
    }
  }
});

// node_modules/vuetify/lib/mixins/measurable/index.js
var measurable_default = vue_runtime_esm_default.extend({
  name: "measurable",
  props: {
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
  },
  computed: {
    measurableStyles() {
      const styles = {};
      const height = convertToUnit(this.height);
      const minHeight = convertToUnit(this.minHeight);
      const minWidth = convertToUnit(this.minWidth);
      const maxHeight = convertToUnit(this.maxHeight);
      const maxWidth = convertToUnit(this.maxWidth);
      const width = convertToUnit(this.width);
      if (height)
        styles.height = height;
      if (minHeight)
        styles.minHeight = minHeight;
      if (minWidth)
        styles.minWidth = minWidth;
      if (maxHeight)
        styles.maxHeight = maxHeight;
      if (maxWidth)
        styles.maxWidth = maxWidth;
      if (width)
        styles.width = width;
      return styles;
    }
  }
});

// node_modules/vuetify/lib/mixins/roundable/index.js
var roundable_default = vue_runtime_esm_default.extend({
  name: "roundable",
  props: {
    rounded: [Boolean, String],
    tile: Boolean
  },
  computed: {
    roundedClasses() {
      const composite = [];
      const rounded = typeof this.rounded === "string" ? String(this.rounded) : this.rounded === true;
      if (this.tile) {
        composite.push("rounded-0");
      } else if (typeof rounded === "string") {
        const values = rounded.split(" ");
        for (const value of values) {
          composite.push(`rounded-${value}`);
        }
      } else if (rounded) {
        composite.push("rounded");
      }
      return composite.length > 0 ? {
        [composite.join(" ")]: true
      } : {};
    }
  }
});

// node_modules/vuetify/lib/components/VSheet/VSheet.js
var VSheet_default = mixins(binds_attrs_default, colorable_default, elevatable_default, measurable_default, roundable_default, themeable_default).extend({
  name: "v-sheet",
  props: {
    outlined: Boolean,
    shaped: Boolean,
    tag: {
      type: String,
      default: "div"
    }
  },
  computed: {
    classes() {
      return __spreadValues(__spreadValues(__spreadValues({
        "v-sheet": true,
        "v-sheet--outlined": this.outlined,
        "v-sheet--shaped": this.shaped
      }, this.themeClasses), this.elevationClasses), this.roundedClasses);
    },
    styles() {
      return this.measurableStyles;
    }
  },
  render(h) {
    const data = {
      class: this.classes,
      style: this.styles,
      on: this.listeners$
    };
    return h(this.tag, this.setBackgroundColor(this.color, data), this.$slots.default);
  }
});

// node_modules/vuetify/lib/directives/intersect/index.js
function inserted2(el, binding, vnode) {
  if (typeof window === "undefined" || !("IntersectionObserver" in window))
    return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === "object" ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver((entries = [], observer2) => {
    var _el$_observe;
    const _observe = (_el$_observe = el._observe) == null ? void 0 : _el$_observe[vnode.context._uid];
    if (!_observe)
      return;
    const isIntersecting = entries.some((entry) => entry.isIntersecting);
    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(entries, observer2, isIntersecting);
    }
    if (isIntersecting && modifiers.once)
      unbind2(el, binding, vnode);
    else
      _observe.init = true;
  }, options);
  el._observe = Object(el._observe);
  el._observe[vnode.context._uid] = {
    init: false,
    observer
  };
  observer.observe(el);
}
function unbind2(el, binding, vnode) {
  var _el$_observe2;
  const observe2 = (_el$_observe2 = el._observe) == null ? void 0 : _el$_observe2[vnode.context._uid];
  if (!observe2)
    return;
  observe2.observer.unobserve(el);
  delete el._observe[vnode.context._uid];
}
var Intersect = {
  inserted: inserted2,
  unbind: unbind2
};
var intersect_default = Intersect;

// node_modules/vuetify/lib/components/VResponsive/VResponsive.js
var VResponsive_default = mixins(measurable_default).extend({
  name: "v-responsive",
  props: {
    aspectRatio: [String, Number],
    contentClass: String
  },
  computed: {
    computedAspectRatio() {
      return Number(this.aspectRatio);
    },
    aspectStyle() {
      return this.computedAspectRatio ? {
        paddingBottom: 1 / this.computedAspectRatio * 100 + "%"
      } : void 0;
    },
    __cachedSizer() {
      if (!this.aspectStyle)
        return [];
      return this.$createElement("div", {
        style: this.aspectStyle,
        staticClass: "v-responsive__sizer"
      });
    }
  },
  methods: {
    genContent() {
      return this.$createElement("div", {
        staticClass: "v-responsive__content",
        class: this.contentClass
      }, this.$slots.default);
    }
  },
  render(h) {
    return h("div", {
      staticClass: "v-responsive",
      style: this.measurableStyles,
      on: this.$listeners
    }, [this.__cachedSizer, this.genContent()]);
  }
});

// node_modules/vuetify/lib/components/VResponsive/index.js
var VResponsive_default2 = VResponsive_default;

// node_modules/vuetify/lib/util/mergeData.js
var pattern = {
  styleList: /;(?![^(]*\))/g,
  styleProp: /:(.*)/
};
function parseStyle(style2) {
  const styleMap = {};
  for (const s of style2.split(pattern.styleList)) {
    let [key, val] = s.split(pattern.styleProp);
    key = key.trim();
    if (!key) {
      continue;
    }
    if (typeof val === "string") {
      val = val.trim();
    }
    styleMap[camelize2(key)] = val;
  }
  return styleMap;
}
function mergeData2() {
  const mergeTarget = {};
  let i = arguments.length;
  let prop;
  while (i--) {
    for (prop of Object.keys(arguments[i])) {
      switch (prop) {
        case "class":
        case "directives":
          if (arguments[i][prop]) {
            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);
          }
          break;
        case "style":
          if (arguments[i][prop]) {
            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);
          }
          break;
        case "staticClass":
          if (!arguments[i][prop]) {
            break;
          }
          if (mergeTarget[prop] === void 0) {
            mergeTarget[prop] = "";
          }
          if (mergeTarget[prop]) {
            mergeTarget[prop] += " ";
          }
          mergeTarget[prop] += arguments[i][prop].trim();
          break;
        case "on":
        case "nativeOn":
          if (arguments[i][prop]) {
            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);
          }
          break;
        case "attrs":
        case "props":
        case "domProps":
        case "scopedSlots":
        case "staticStyle":
        case "hook":
        case "transition":
          if (!arguments[i][prop]) {
            break;
          }
          if (!mergeTarget[prop]) {
            mergeTarget[prop] = {};
          }
          mergeTarget[prop] = __spreadValues(__spreadValues({}, arguments[i][prop]), mergeTarget[prop]);
          break;
        default:
          if (!mergeTarget[prop]) {
            mergeTarget[prop] = arguments[i][prop];
          }
      }
    }
  }
  return mergeTarget;
}
function mergeStyles(target2, source) {
  if (!target2)
    return source;
  if (!source)
    return target2;
  target2 = wrapInArray(typeof target2 === "string" ? parseStyle(target2) : target2);
  return target2.concat(typeof source === "string" ? parseStyle(source) : source);
}
function mergeClasses(target2, source) {
  if (!source)
    return target2;
  if (!target2)
    return source;
  return target2 ? wrapInArray(target2).concat(source) : source;
}
function mergeListeners(...args) {
  if (!args[0])
    return args[1];
  if (!args[1])
    return args[0];
  const dest = {};
  for (let i = 2; i--; ) {
    const arg = args[i];
    for (const event in arg) {
      if (!arg[event])
        continue;
      if (dest[event]) {
        dest[event] = [].concat(arg[event], dest[event]);
      } else {
        dest[event] = arg[event];
      }
    }
  }
  return dest;
}

// node_modules/vuetify/lib/components/VImg/VImg.js
var hasIntersect = typeof window !== "undefined" && "IntersectionObserver" in window;
var VImg_default = mixins(VResponsive_default2, themeable_default).extend({
  name: "v-img",
  directives: {
    intersect: intersect_default
  },
  props: {
    alt: String,
    contain: Boolean,
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    position: {
      type: String,
      default: "center center"
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    srcset: String,
    transition: {
      type: [Boolean, String],
      default: "fade-transition"
    }
  },
  data() {
    return {
      currentSrc: "",
      image: null,
      isLoading: true,
      calculatedAspectRatio: void 0,
      naturalWidth: void 0,
      hasError: false
    };
  },
  computed: {
    computedAspectRatio() {
      return Number(this.normalisedSrc.aspect || this.calculatedAspectRatio);
    },
    normalisedSrc() {
      return this.src && typeof this.src === "object" ? {
        src: this.src.src,
        srcset: this.srcset || this.src.srcset,
        lazySrc: this.lazySrc || this.src.lazySrc,
        aspect: Number(this.aspectRatio || this.src.aspect)
      } : {
        src: this.src,
        srcset: this.srcset,
        lazySrc: this.lazySrc,
        aspect: Number(this.aspectRatio || 0)
      };
    },
    __cachedImage() {
      if (!(this.normalisedSrc.src || this.normalisedSrc.lazySrc || this.gradient))
        return [];
      const backgroundImage = [];
      const src = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc;
      if (this.gradient)
        backgroundImage.push(`linear-gradient(${this.gradient})`);
      if (src)
        backgroundImage.push(`url("${src}")`);
      const image = this.$createElement("div", {
        staticClass: "v-image__image",
        class: {
          "v-image__image--preload": this.isLoading,
          "v-image__image--contain": this.contain,
          "v-image__image--cover": !this.contain
        },
        style: {
          backgroundImage: backgroundImage.join(", "),
          backgroundPosition: this.position
        },
        key: +this.isLoading
      });
      if (!this.transition)
        return image;
      return this.$createElement("transition", {
        attrs: {
          name: this.transition,
          mode: "in-out"
        }
      }, [image]);
    }
  },
  watch: {
    src() {
      if (!this.isLoading)
        this.init(void 0, void 0, true);
      else
        this.loadImage();
    },
    "$vuetify.breakpoint.width": "getSrc"
  },
  mounted() {
    this.init();
  },
  methods: {
    init(entries, observer, isIntersecting) {
      if (hasIntersect && !isIntersecting && !this.eager)
        return;
      if (this.normalisedSrc.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = this.normalisedSrc.lazySrc;
        this.pollForSize(lazyImg, null);
      }
      if (this.normalisedSrc.src)
        this.loadImage();
    },
    onLoad() {
      this.getSrc();
      this.isLoading = false;
      this.$emit("load", this.src);
      if (this.image && (this.normalisedSrc.src.endsWith(".svg") || this.normalisedSrc.src.startsWith("data:image/svg+xml"))) {
        if (this.image.naturalHeight && this.image.naturalWidth) {
          this.naturalWidth = this.image.naturalWidth;
          this.calculatedAspectRatio = this.image.naturalWidth / this.image.naturalHeight;
        } else {
          this.calculatedAspectRatio = 1;
        }
      }
    },
    onError() {
      this.hasError = true;
      this.$emit("error", this.src);
    },
    getSrc() {
      if (this.image)
        this.currentSrc = this.image.currentSrc || this.image.src;
    },
    loadImage() {
      const image = new Image();
      this.image = image;
      image.onload = () => {
        if (image.decode) {
          image.decode().catch((err) => {
            consoleWarn(`Failed to decode image, trying to render anyway

src: ${this.normalisedSrc.src}` + (err.message ? `
Original error: ${err.message}` : ""), this);
          }).then(this.onLoad);
        } else {
          this.onLoad();
        }
      };
      image.onerror = this.onError;
      this.hasError = false;
      this.sizes && (image.sizes = this.sizes);
      this.normalisedSrc.srcset && (image.srcset = this.normalisedSrc.srcset);
      image.src = this.normalisedSrc.src;
      this.$emit("loadstart", this.normalisedSrc.src);
      this.aspectRatio || this.pollForSize(image);
      this.getSrc();
    },
    pollForSize(img, timeout = 100) {
      const poll = () => {
        const {
          naturalHeight,
          naturalWidth
        } = img;
        if (naturalHeight || naturalWidth) {
          this.naturalWidth = naturalWidth;
          this.calculatedAspectRatio = naturalWidth / naturalHeight;
        } else if (!img.complete && this.isLoading && !this.hasError && timeout != null) {
          setTimeout(poll, timeout);
        }
      };
      poll();
    },
    genContent() {
      const content = VResponsive_default2.options.methods.genContent.call(this);
      if (this.naturalWidth) {
        this._b(content.data, "div", {
          style: {
            width: `${this.naturalWidth}px`
          }
        });
      }
      return content;
    },
    __genPlaceholder() {
      if (this.$slots.placeholder) {
        const placeholder2 = this.isLoading ? [this.$createElement("div", {
          staticClass: "v-image__placeholder"
        }, this.$slots.placeholder)] : [];
        if (!this.transition)
          return placeholder2[0];
        return this.$createElement("transition", {
          props: {
            appear: true,
            name: this.transition
          }
        }, placeholder2);
      }
    }
  },
  render(h) {
    const node = VResponsive_default2.options.render.call(this, h);
    const data = mergeData2(node.data, {
      staticClass: "v-image",
      attrs: {
        "aria-label": this.alt,
        role: this.alt ? "img" : void 0
      },
      class: this.themeClasses,
      directives: hasIntersect ? [{
        name: "intersect",
        modifiers: {
          once: true
        },
        value: {
          handler: this.init,
          options: this.options
        }
      }] : void 0
    });
    node.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()];
    return h(node.tag, data, node.children);
  }
});

// node_modules/vuetify/lib/mixins/positionable/index.js
var availableProps = {
  absolute: Boolean,
  bottom: Boolean,
  fixed: Boolean,
  left: Boolean,
  right: Boolean,
  top: Boolean
};
function factory(selected = []) {
  return vue_runtime_esm_default.extend({
    name: "positionable",
    props: selected.length ? filterObjectOnKeys(availableProps, selected) : availableProps
  });
}
var positionable_default = factory();

// node_modules/vuetify/lib/util/dom.js
function attachedRoot(node) {
  if (typeof node.getRootNode !== "function") {
    while (node.parentNode)
      node = node.parentNode;
    if (node !== document)
      return null;
    return document;
  }
  const root = node.getRootNode();
  if (root !== document && root.getRootNode({
    composed: true
  }) !== document)
    return null;
  return root;
}

// node_modules/vuetify/lib/directives/click-outside/index.js
function defaultConditional() {
  return true;
}
function checkEvent(e, el, binding) {
  if (!e || checkIsActive(e, binding) === false)
    return false;
  const root = attachedRoot(el);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el);
  return !elements.some((el2) => el2.contains(e.target));
}
function checkIsActive(e, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}
function directive2(e, el, binding, vnode) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}
function handleShadow(el, callback) {
  const root = attachedRoot(el);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
    callback(root);
  }
}
var ClickOutside = {
  inserted(el, binding, vnode) {
    const onClick = (e) => directive2(e, el, binding, vnode);
    const onMousedown = (e) => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };
    handleShadow(el, (app) => {
      app.addEventListener("click", onClick, true);
      app.addEventListener("mousedown", onMousedown, true);
    });
    if (!el._clickOutside) {
      el._clickOutside = {
        lastMousedownWasOutside: true
      };
    }
    el._clickOutside[vnode.context._uid] = {
      onClick,
      onMousedown
    };
  },
  unbind(el, binding, vnode) {
    if (!el._clickOutside)
      return;
    handleShadow(el, (app) => {
      var _el$_clickOutside;
      if (!app || !((_el$_clickOutside = el._clickOutside) != null && _el$_clickOutside[vnode.context._uid]))
        return;
      const {
        onClick,
        onMousedown
      } = el._clickOutside[vnode.context._uid];
      app.removeEventListener("click", onClick, true);
      app.removeEventListener("mousedown", onMousedown, true);
    });
    delete el._clickOutside[vnode.context._uid];
  }
};
var click_outside_default = ClickOutside;

// node_modules/vuetify/lib/directives/resize/index.js
function inserted3(el, binding, vnode) {
  const callback = binding.value;
  const options = binding.options || {
    passive: true
  };
  window.addEventListener("resize", callback, options);
  el._onResize = Object(el._onResize);
  el._onResize[vnode.context._uid] = {
    callback,
    options
  };
  if (!binding.modifiers || !binding.modifiers.quiet) {
    callback();
  }
}
function unbind3(el, binding, vnode) {
  var _el$_onResize;
  if (!((_el$_onResize = el._onResize) != null && _el$_onResize[vnode.context._uid]))
    return;
  const {
    callback,
    options
  } = el._onResize[vnode.context._uid];
  window.removeEventListener("resize", callback, options);
  delete el._onResize[vnode.context._uid];
}
var Resize = {
  inserted: inserted3,
  unbind: unbind3
};
var resize_default = Resize;

// node_modules/vuetify/lib/directives/ripple/index.js
var DELAY_RIPPLE = 80;
function transform(el, value) {
  el.style.transform = value;
  el.style.webkitTransform = value;
}
function isTouchEvent(e) {
  return e.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e) {
  return e.constructor.name === "KeyboardEvent";
}
var calculate = (e, el, value = {}) => {
  let localX = 0;
  let localY = 0;
  if (!isKeyboardEvent(e)) {
    const offset = el.getBoundingClientRect();
    const target2 = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    localX = target2.clientX - offset.left;
    localY = target2.clientY - offset.top;
  }
  let radius = 0;
  let scale = 0.3;
  if (el._ripple && el._ripple.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }
  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
  const x = value.center ? centerX : `${localX - radius}px`;
  const y = value.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x,
    y,
    centerX,
    centerY
  };
};
var ripples = {
  show(e, el, value = {}) {
    if (!el._ripple || !el._ripple.enabled) {
      return;
    }
    const container = document.createElement("span");
    const animation = document.createElement("span");
    container.appendChild(animation);
    container.className = "v-ripple__container";
    if (value.class) {
      container.className += ` ${value.class}`;
    }
    const {
      radius,
      scale,
      x,
      y,
      centerX,
      centerY
    } = calculate(e, el, value);
    const size = `${radius * 2}px`;
    animation.className = "v-ripple__animation";
    animation.style.width = size;
    animation.style.height = size;
    el.appendChild(container);
    const computed = window.getComputedStyle(el);
    if (computed && computed.position === "static") {
      el.style.position = "relative";
      el.dataset.previousPosition = "static";
    }
    animation.classList.add("v-ripple__animation--enter");
    animation.classList.add("v-ripple__animation--visible");
    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--in");
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(el) {
    if (!el || !el._ripple || !el._ripple.enabled)
      return;
    const ripples2 = el.getElementsByClassName("v-ripple__animation");
    if (ripples2.length === 0)
      return;
    const animation = ripples2[ripples2.length - 1];
    if (animation.dataset.isHiding)
      return;
    else
      animation.dataset.isHiding = "true";
    const diff = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--in");
      animation.classList.add("v-ripple__animation--out");
      setTimeout(() => {
        const ripples3 = el.getElementsByClassName("v-ripple__animation");
        if (ripples3.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }
        animation.parentNode && el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};
function isRippleEnabled(value) {
  return typeof value === "undefined" || !!value;
}
function rippleShow(e) {
  const value = {};
  const element = e.currentTarget;
  if (!element || !element._ripple || element._ripple.touched || e.rippleStop)
    return;
  e.rippleStop = true;
  if (isTouchEvent(e)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    if (element._ripple.isTouch)
      return;
  }
  value.center = element._ripple.centered || isKeyboardEvent(e);
  if (element._ripple.class) {
    value.class = element._ripple.class;
  }
  if (isTouchEvent(e)) {
    if (element._ripple.showTimerCommit)
      return;
    element._ripple.showTimerCommit = () => {
      ripples.show(e, element, value);
    };
    element._ripple.showTimer = window.setTimeout(() => {
      if (element && element._ripple && element._ripple.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e, element, value);
  }
}
function rippleHide(e) {
  const element = e.currentTarget;
  if (!element || !element._ripple)
    return;
  window.clearTimeout(element._ripple.showTimer);
  if (e.type === "touchend" && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();
    element._ripple.showTimerCommit = null;
    element._ripple.showTimer = setTimeout(() => {
      rippleHide(e);
    });
    return;
  }
  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}
function rippleCancelShow(e) {
  const element = e.currentTarget;
  if (!element || !element._ripple)
    return;
  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }
  window.clearTimeout(element._ripple.showTimer);
}
var keyboardRipple = false;
function keyboardRippleShow(e) {
  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e);
  }
}
function keyboardRippleHide(e) {
  keyboardRipple = false;
  rippleHide(e);
}
function focusRippleHide(e) {
  if (keyboardRipple === true) {
    keyboardRipple = false;
    rippleHide(e);
  }
}
function updateRipple(el, binding, wasEnabled) {
  const enabled = isRippleEnabled(binding.value);
  if (!enabled) {
    ripples.hide(el);
  }
  el._ripple = el._ripple || {};
  el._ripple.enabled = enabled;
  const value = binding.value || {};
  if (value.center) {
    el._ripple.centered = true;
  }
  if (value.class) {
    el._ripple.class = binding.value.class;
  }
  if (value.circle) {
    el._ripple.circle = value.circle;
  }
  if (enabled && !wasEnabled) {
    el.addEventListener("touchstart", rippleShow, {
      passive: true
    });
    el.addEventListener("touchend", rippleHide, {
      passive: true
    });
    el.addEventListener("touchmove", rippleCancelShow, {
      passive: true
    });
    el.addEventListener("touchcancel", rippleHide);
    el.addEventListener("mousedown", rippleShow);
    el.addEventListener("mouseup", rippleHide);
    el.addEventListener("mouseleave", rippleHide);
    el.addEventListener("keydown", keyboardRippleShow);
    el.addEventListener("keyup", keyboardRippleHide);
    el.addEventListener("blur", focusRippleHide);
    el.addEventListener("dragstart", rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}
function removeListeners(el) {
  el.removeEventListener("mousedown", rippleShow);
  el.removeEventListener("touchstart", rippleShow);
  el.removeEventListener("touchend", rippleHide);
  el.removeEventListener("touchmove", rippleCancelShow);
  el.removeEventListener("touchcancel", rippleHide);
  el.removeEventListener("mouseup", rippleHide);
  el.removeEventListener("mouseleave", rippleHide);
  el.removeEventListener("keydown", keyboardRippleShow);
  el.removeEventListener("keyup", keyboardRippleHide);
  el.removeEventListener("dragstart", rippleHide);
  el.removeEventListener("blur", focusRippleHide);
}
function directive3(el, binding, node) {
  updateRipple(el, binding, false);
  if (true) {
    node.context && node.context.$nextTick(() => {
      const computed = window.getComputedStyle(el);
      if (computed && computed.display === "inline") {
        const context = node.fnOptions ? [node.fnOptions, node.context] : [node.componentInstance];
        consoleWarn("v-ripple can only be used on block-level elements", ...context);
      }
    });
  }
}
function unbind4(el) {
  delete el._ripple;
  removeListeners(el);
}
function update4(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }
  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}
var Ripple = {
  bind: directive3,
  unbind: unbind4,
  update: update4
};
var ripple_default = Ripple;

// node_modules/vuetify/lib/mixins/toggleable/index.js
function factory2(prop = "value", event = "input") {
  return vue_runtime_esm_default.extend({
    name: "toggleable",
    model: {
      prop,
      event
    },
    props: {
      [prop]: {
        required: false
      }
    },
    data() {
      return {
        isActive: !!this[prop]
      };
    },
    watch: {
      [prop](val) {
        this.isActive = !!val;
      },
      isActive(val) {
        !!val !== this[prop] && this.$emit(event, val);
      }
    }
  });
}
var Toggleable = factory2();
var toggleable_default = Toggleable;

// node_modules/vuetify/lib/mixins/sizeable/index.js
var sizeable_default = vue_runtime_esm_default.extend({
  name: "sizeable",
  props: {
    large: Boolean,
    small: Boolean,
    xLarge: Boolean,
    xSmall: Boolean
  },
  computed: {
    medium() {
      return Boolean(!this.xSmall && !this.small && !this.large && !this.xLarge);
    },
    sizeableClasses() {
      return {
        "v-size--x-small": this.xSmall,
        "v-size--small": this.small,
        "v-size--default": this.medium,
        "v-size--large": this.large,
        "v-size--x-large": this.xLarge
      };
    }
  }
});

// node_modules/vuetify/lib/components/VIcon/VIcon.js
var SIZE_MAP;
(function(SIZE_MAP2) {
  SIZE_MAP2["xSmall"] = "12px";
  SIZE_MAP2["small"] = "16px";
  SIZE_MAP2["default"] = "24px";
  SIZE_MAP2["medium"] = "28px";
  SIZE_MAP2["large"] = "36px";
  SIZE_MAP2["xLarge"] = "40px";
})(SIZE_MAP || (SIZE_MAP = {}));
function isFontAwesome5(iconType) {
  return ["fas", "far", "fal", "fab", "fad", "fak"].some((val) => iconType.includes(val));
}
function isSvgPath(icon) {
  return /^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(icon) && /[\dz]$/i.test(icon) && icon.length > 4;
}
var VIcon = mixins(binds_attrs_default, colorable_default, sizeable_default, themeable_default).extend({
  name: "v-icon",
  props: {
    dense: Boolean,
    disabled: Boolean,
    left: Boolean,
    right: Boolean,
    size: [Number, String],
    tag: {
      type: String,
      required: false,
      default: "i"
    }
  },
  computed: {
    medium() {
      return false;
    },
    hasClickListener() {
      return Boolean(this.listeners$.click || this.listeners$["!click"]);
    }
  },
  methods: {
    getIcon() {
      let iconName = "";
      if (this.$slots.default)
        iconName = this.$slots.default[0].text.trim();
      return remapInternalIcon(this, iconName);
    },
    getSize() {
      const sizes = {
        xSmall: this.xSmall,
        small: this.small,
        medium: this.medium,
        large: this.large,
        xLarge: this.xLarge
      };
      const explicitSize = keys(sizes).find((key) => sizes[key]);
      return explicitSize && SIZE_MAP[explicitSize] || convertToUnit(this.size);
    },
    getDefaultData() {
      return {
        staticClass: "v-icon notranslate",
        class: {
          "v-icon--disabled": this.disabled,
          "v-icon--left": this.left,
          "v-icon--link": this.hasClickListener,
          "v-icon--right": this.right,
          "v-icon--dense": this.dense
        },
        attrs: __spreadValues({
          "aria-hidden": !this.hasClickListener,
          disabled: this.hasClickListener && this.disabled,
          type: this.hasClickListener ? "button" : void 0
        }, this.attrs$),
        on: this.listeners$
      };
    },
    getSvgWrapperData() {
      const fontSize = this.getSize();
      const wrapperData = __spreadProps(__spreadValues({}, this.getDefaultData()), {
        style: fontSize ? {
          fontSize,
          height: fontSize,
          width: fontSize
        } : void 0
      });
      this.applyColors(wrapperData);
      return wrapperData;
    },
    applyColors(data) {
      data.class = __spreadValues(__spreadValues({}, data.class), this.themeClasses);
      this.setTextColor(this.color, data);
    },
    renderFontIcon(icon, h) {
      const newChildren = [];
      const data = this.getDefaultData();
      let iconType = "material-icons";
      const delimiterIndex = icon.indexOf("-");
      const isMaterialIcon = delimiterIndex <= -1;
      if (isMaterialIcon) {
        newChildren.push(icon);
      } else {
        iconType = icon.slice(0, delimiterIndex);
        if (isFontAwesome5(iconType))
          iconType = "";
      }
      data.class[iconType] = true;
      data.class[icon] = !isMaterialIcon;
      const fontSize = this.getSize();
      if (fontSize)
        data.style = {
          fontSize
        };
      this.applyColors(data);
      return h(this.hasClickListener ? "button" : this.tag, data, newChildren);
    },
    renderSvgIcon(icon, h) {
      const svgData = {
        class: "v-icon__svg",
        attrs: {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          role: "img",
          "aria-hidden": true
        }
      };
      const size = this.getSize();
      if (size) {
        svgData.style = {
          fontSize: size,
          height: size,
          width: size
        };
      }
      return h(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [h("svg", svgData, [h("path", {
        attrs: {
          d: icon
        }
      })])]);
    },
    renderSvgIconComponent(icon, h) {
      const data = {
        class: {
          "v-icon__component": true
        }
      };
      const size = this.getSize();
      if (size) {
        data.style = {
          fontSize: size,
          height: size,
          width: size
        };
      }
      this.applyColors(data);
      const component = icon.component;
      data.props = icon.props;
      data.nativeOn = data.on;
      return h(this.hasClickListener ? "button" : "span", this.getSvgWrapperData(), [h(component, data)]);
    }
  },
  render(h) {
    const icon = this.getIcon();
    if (typeof icon === "string") {
      if (isSvgPath(icon)) {
        return this.renderSvgIcon(icon, h);
      }
      return this.renderFontIcon(icon, h);
    }
    return this.renderSvgIconComponent(icon, h);
  }
});
var VIcon_default = vue_runtime_esm_default.extend({
  name: "v-icon",
  $_wrapperFor: VIcon,
  functional: true,
  render(h, {
    data,
    children
  }) {
    let iconName = "";
    if (data.domProps) {
      iconName = data.domProps.textContent || data.domProps.innerHTML || iconName;
      delete data.domProps.textContent;
      delete data.domProps.innerHTML;
    }
    return h(VIcon, data, iconName ? [iconName] : children);
  }
});

// node_modules/vuetify/lib/components/VIcon/index.js
var VIcon_default2 = VIcon_default;

// node_modules/vuetify/lib/components/VSheet/index.js
var VSheet_default2 = VSheet_default;

// node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.js
var VProgressCircular_default = colorable_default.extend({
  name: "v-progress-circular",
  directives: {
    intersect: intersect_default
  },
  props: {
    button: Boolean,
    indeterminate: Boolean,
    rotate: {
      type: [Number, String],
      default: 0
    },
    size: {
      type: [Number, String],
      default: 32
    },
    width: {
      type: [Number, String],
      default: 4
    },
    value: {
      type: [Number, String],
      default: 0
    }
  },
  data: () => ({
    radius: 20,
    isVisible: true
  }),
  computed: {
    calculatedSize() {
      return Number(this.size) + (this.button ? 8 : 0);
    },
    circumference() {
      return 2 * Math.PI * this.radius;
    },
    classes() {
      return {
        "v-progress-circular--visible": this.isVisible,
        "v-progress-circular--indeterminate": this.indeterminate,
        "v-progress-circular--button": this.button
      };
    },
    normalizedValue() {
      if (this.value < 0) {
        return 0;
      }
      if (this.value > 100) {
        return 100;
      }
      return parseFloat(this.value);
    },
    strokeDashArray() {
      return Math.round(this.circumference * 1e3) / 1e3;
    },
    strokeDashOffset() {
      return (100 - this.normalizedValue) / 100 * this.circumference + "px";
    },
    strokeWidth() {
      return Number(this.width) / +this.size * this.viewBoxSize * 2;
    },
    styles() {
      return {
        height: convertToUnit(this.calculatedSize),
        width: convertToUnit(this.calculatedSize)
      };
    },
    svgStyles() {
      return {
        transform: `rotate(${Number(this.rotate)}deg)`
      };
    },
    viewBoxSize() {
      return this.radius / (1 - Number(this.width) / +this.size);
    }
  },
  methods: {
    genCircle(name, offset) {
      return this.$createElement("circle", {
        class: `v-progress-circular__${name}`,
        attrs: {
          fill: "transparent",
          cx: 2 * this.viewBoxSize,
          cy: 2 * this.viewBoxSize,
          r: this.radius,
          "stroke-width": this.strokeWidth,
          "stroke-dasharray": this.strokeDashArray,
          "stroke-dashoffset": offset
        }
      });
    },
    genSvg() {
      const children = [this.indeterminate || this.genCircle("underlay", 0), this.genCircle("overlay", this.strokeDashOffset)];
      return this.$createElement("svg", {
        style: this.svgStyles,
        attrs: {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: `${this.viewBoxSize} ${this.viewBoxSize} ${2 * this.viewBoxSize} ${2 * this.viewBoxSize}`
        }
      }, children);
    },
    genInfo() {
      return this.$createElement("div", {
        staticClass: "v-progress-circular__info"
      }, this.$slots.default);
    },
    onObserve(entries, observer, isIntersecting) {
      this.isVisible = isIntersecting;
    }
  },
  render(h) {
    return h("div", this.setTextColor(this.color, {
      staticClass: "v-progress-circular",
      attrs: {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
      },
      class: this.classes,
      directives: [{
        name: "intersect",
        value: this.onObserve
      }],
      style: this.styles,
      on: this.$listeners
    }), [this.genSvg(), this.genInfo()]);
  }
});

// node_modules/vuetify/lib/components/VProgressCircular/index.js
var VProgressCircular_default2 = VProgressCircular_default;

// node_modules/vuetify/lib/mixins/registrable/index.js
function generateWarning(child, parent) {
  return () => consoleWarn(`The ${child} component must be used inside a ${parent}`);
}
function inject(namespace, child, parent) {
  const defaultImpl = child && parent ? {
    register: generateWarning(child, parent),
    unregister: generateWarning(child, parent)
  } : null;
  return vue_runtime_esm_default.extend({
    name: "registrable-inject",
    inject: {
      [namespace]: {
        default: defaultImpl
      }
    }
  });
}

// node_modules/vuetify/lib/mixins/groupable/index.js
function factory3(namespace, child, parent) {
  return inject(namespace, child, parent).extend({
    name: "groupable",
    props: {
      activeClass: {
        type: String,
        default() {
          if (!this[namespace])
            return void 0;
          return this[namespace].activeClass;
        }
      },
      disabled: Boolean
    },
    data() {
      return {
        isActive: false
      };
    },
    computed: {
      groupClasses() {
        if (!this.activeClass)
          return {};
        return {
          [this.activeClass]: this.isActive
        };
      }
    },
    created() {
      this[namespace] && this[namespace].register(this);
    },
    beforeDestroy() {
      this[namespace] && this[namespace].unregister(this);
    },
    methods: {
      toggle() {
        this.$emit("change");
      }
    }
  });
}
var Groupable = factory3("itemGroup");

// node_modules/vuetify/lib/mixins/routable/index.js
var routable_default = vue_runtime_esm_default.extend({
  name: "routable",
  directives: {
    Ripple: ripple_default
  },
  props: {
    activeClass: String,
    append: Boolean,
    disabled: Boolean,
    exact: {
      type: Boolean,
      default: void 0
    },
    exactPath: Boolean,
    exactActiveClass: String,
    link: Boolean,
    href: [String, Object],
    to: [String, Object],
    nuxt: Boolean,
    replace: Boolean,
    ripple: {
      type: [Boolean, Object],
      default: null
    },
    tag: String,
    target: String
  },
  data: () => ({
    isActive: false,
    proxyClass: ""
  }),
  computed: {
    classes() {
      const classes = {};
      if (this.to)
        return classes;
      if (this.activeClass)
        classes[this.activeClass] = this.isActive;
      if (this.proxyClass)
        classes[this.proxyClass] = this.isActive;
      return classes;
    },
    computedRipple() {
      var _this$ripple;
      return (_this$ripple = this.ripple) != null ? _this$ripple : !this.disabled && this.isClickable;
    },
    isClickable() {
      if (this.disabled)
        return false;
      return Boolean(this.isLink || this.$listeners.click || this.$listeners["!click"] || this.$attrs.tabindex);
    },
    isLink() {
      return this.to || this.href || this.link;
    },
    styles: () => ({})
  },
  watch: {
    $route: "onRouteChange"
  },
  mounted() {
    this.onRouteChange();
  },
  methods: {
    generateRouteLink() {
      let exact = this.exact;
      let tag;
      const data = {
        attrs: {
          tabindex: "tabindex" in this.$attrs ? this.$attrs.tabindex : void 0
        },
        class: this.classes,
        style: this.styles,
        props: {},
        directives: [{
          name: "ripple",
          value: this.computedRipple
        }],
        [this.to ? "nativeOn" : "on"]: __spreadValues(__spreadValues({}, this.$listeners), "click" in this ? {
          click: this.click
        } : void 0),
        ref: "link"
      };
      if (typeof this.exact === "undefined") {
        exact = this.to === "/" || this.to === Object(this.to) && this.to.path === "/";
      }
      if (this.to) {
        let activeClass = this.activeClass;
        let exactActiveClass = this.exactActiveClass || activeClass;
        if (this.proxyClass) {
          activeClass = `${activeClass} ${this.proxyClass}`.trim();
          exactActiveClass = `${exactActiveClass} ${this.proxyClass}`.trim();
        }
        tag = this.nuxt ? "nuxt-link" : "router-link";
        Object.assign(data.props, {
          to: this.to,
          exact,
          exactPath: this.exactPath,
          activeClass,
          exactActiveClass,
          append: this.append,
          replace: this.replace
        });
      } else {
        tag = this.href && "a" || this.tag || "div";
        if (tag === "a" && this.href)
          data.attrs.href = this.href;
      }
      if (this.target)
        data.attrs.target = this.target;
      return {
        tag,
        data
      };
    },
    onRouteChange() {
      if (!this.to || !this.$refs.link || !this.$route)
        return;
      const activeClass = `${this.activeClass || ""} ${this.proxyClass || ""}`.trim();
      const exactActiveClass = `${this.exactActiveClass || ""} ${this.proxyClass || ""}`.trim() || activeClass;
      const path = "_vnode.data.class." + (this.exact ? exactActiveClass : activeClass);
      this.$nextTick(() => {
        if (!getObjectValueByPath(this.$refs.link, path) === this.isActive) {
          this.toggle();
        }
      });
    },
    toggle() {
      this.isActive = !this.isActive;
    }
  }
});

// node_modules/vuetify/lib/components/VBtn/VBtn.js
var baseMixins = mixins(VSheet_default2, routable_default, positionable_default, sizeable_default, factory3("btnToggle"), factory2("inputValue"));
var VBtn_default = baseMixins.extend().extend({
  name: "v-btn",
  props: {
    activeClass: {
      type: String,
      default() {
        if (!this.btnToggle)
          return "";
        return this.btnToggle.activeClass;
      }
    },
    block: Boolean,
    depressed: Boolean,
    fab: Boolean,
    icon: Boolean,
    loading: Boolean,
    outlined: Boolean,
    plain: Boolean,
    retainFocusOnClick: Boolean,
    rounded: Boolean,
    tag: {
      type: String,
      default: "button"
    },
    text: Boolean,
    tile: Boolean,
    type: {
      type: String,
      default: "button"
    },
    value: null
  },
  data: () => ({
    proxyClass: "v-btn--active"
  }),
  computed: {
    classes() {
      return __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({
        "v-btn": true
      }, routable_default.options.computed.classes.call(this)), {
        "v-btn--absolute": this.absolute,
        "v-btn--block": this.block,
        "v-btn--bottom": this.bottom,
        "v-btn--disabled": this.disabled,
        "v-btn--is-elevated": this.isElevated,
        "v-btn--fab": this.fab,
        "v-btn--fixed": this.fixed,
        "v-btn--has-bg": this.hasBg,
        "v-btn--icon": this.icon,
        "v-btn--left": this.left,
        "v-btn--loading": this.loading,
        "v-btn--outlined": this.outlined,
        "v-btn--plain": this.plain,
        "v-btn--right": this.right,
        "v-btn--round": this.isRound,
        "v-btn--rounded": this.rounded,
        "v-btn--router": this.to,
        "v-btn--text": this.text,
        "v-btn--tile": this.tile,
        "v-btn--top": this.top
      }), this.themeClasses), this.groupClasses), this.elevationClasses), this.sizeableClasses);
    },
    computedElevation() {
      if (this.disabled)
        return void 0;
      return elevatable_default.options.computed.computedElevation.call(this);
    },
    computedRipple() {
      var _this$ripple;
      const defaultRipple = this.icon || this.fab ? {
        circle: true
      } : true;
      if (this.disabled)
        return false;
      else
        return (_this$ripple = this.ripple) != null ? _this$ripple : defaultRipple;
    },
    hasBg() {
      return !this.text && !this.plain && !this.outlined && !this.icon;
    },
    isElevated() {
      return Boolean(!this.icon && !this.text && !this.outlined && !this.depressed && !this.disabled && !this.plain && (this.elevation == null || Number(this.elevation) > 0));
    },
    isRound() {
      return Boolean(this.icon || this.fab);
    },
    styles() {
      return __spreadValues({}, this.measurableStyles);
    }
  },
  created() {
    const breakingProps = [["flat", "text"], ["outline", "outlined"], ["round", "rounded"]];
    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original))
        breaking(original, replacement, this);
    });
  },
  methods: {
    click(e) {
      !this.retainFocusOnClick && !this.fab && e.detail && this.$el.blur();
      this.$emit("click", e);
      this.btnToggle && this.toggle();
    },
    genContent() {
      return this.$createElement("span", {
        staticClass: "v-btn__content"
      }, this.$slots.default);
    },
    genLoader() {
      return this.$createElement("span", {
        class: "v-btn__loader"
      }, this.$slots.loader || [this.$createElement(VProgressCircular_default2, {
        props: {
          indeterminate: true,
          size: 23,
          width: 2
        }
      })]);
    }
  },
  render(h) {
    const children = [this.genContent(), this.loading && this.genLoader()];
    const {
      tag,
      data
    } = this.generateRouteLink();
    const setColor = this.hasBg ? this.setBackgroundColor : this.setTextColor;
    if (tag === "button") {
      data.attrs.type = this.type;
      data.attrs.disabled = this.disabled;
    }
    data.attrs.value = ["string", "number"].includes(typeof this.value) ? this.value : JSON.stringify(this.value);
    return h(tag, this.disabled ? data : setColor(this.color, data), children);
  }
});

// node_modules/vuetify/lib/components/VBtn/index.js
var VBtn_default2 = VBtn_default;

// node_modules/vuetify/lib/mixins/transitionable/index.js
var transitionable_default = vue_runtime_esm_default.extend({
  name: "transitionable",
  props: {
    mode: String,
    origin: String,
    transition: String
  }
});

// node_modules/vuetify/lib/components/VAlert/VAlert.js
var VAlert_default = mixins(VSheet_default2, toggleable_default, transitionable_default).extend({
  name: "v-alert",
  props: {
    border: {
      type: String,
      validator(val) {
        return ["top", "right", "bottom", "left"].includes(val);
      }
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    coloredBorder: Boolean,
    dense: Boolean,
    dismissible: Boolean,
    closeIcon: {
      type: String,
      default: "$cancel"
    },
    icon: {
      default: "",
      type: [Boolean, String],
      validator(val) {
        return typeof val === "string" || val === false;
      }
    },
    outlined: Boolean,
    prominent: Boolean,
    text: Boolean,
    type: {
      type: String,
      validator(val) {
        return ["info", "error", "success", "warning"].includes(val);
      }
    },
    value: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    __cachedBorder() {
      if (!this.border)
        return null;
      let data = {
        staticClass: "v-alert__border",
        class: {
          [`v-alert__border--${this.border}`]: true
        }
      };
      if (this.coloredBorder) {
        data = this.setBackgroundColor(this.computedColor, data);
        data.class["v-alert__border--has-color"] = true;
      }
      return this.$createElement("div", data);
    },
    __cachedDismissible() {
      if (!this.dismissible)
        return null;
      const color = this.iconColor;
      return this.$createElement(VBtn_default2, {
        staticClass: "v-alert__dismissible",
        props: {
          color,
          icon: true,
          small: true
        },
        attrs: {
          "aria-label": this.$vuetify.lang.t(this.closeLabel)
        },
        on: {
          click: () => this.isActive = false
        }
      }, [this.$createElement(VIcon_default2, {
        props: {
          color
        }
      }, this.closeIcon)]);
    },
    __cachedIcon() {
      if (!this.computedIcon)
        return null;
      return this.$createElement(VIcon_default2, {
        staticClass: "v-alert__icon",
        props: {
          color: this.iconColor
        }
      }, this.computedIcon);
    },
    classes() {
      const classes = __spreadProps(__spreadValues({}, VSheet_default2.options.computed.classes.call(this)), {
        "v-alert--border": Boolean(this.border),
        "v-alert--dense": this.dense,
        "v-alert--outlined": this.outlined,
        "v-alert--prominent": this.prominent,
        "v-alert--text": this.text
      });
      if (this.border) {
        classes[`v-alert--border-${this.border}`] = true;
      }
      return classes;
    },
    computedColor() {
      return this.color || this.type;
    },
    computedIcon() {
      if (this.icon === false)
        return false;
      if (typeof this.icon === "string" && this.icon)
        return this.icon;
      if (!["error", "info", "success", "warning"].includes(this.type))
        return false;
      return `$${this.type}`;
    },
    hasColoredIcon() {
      return this.hasText || Boolean(this.border) && this.coloredBorder;
    },
    hasText() {
      return this.text || this.outlined;
    },
    iconColor() {
      return this.hasColoredIcon ? this.computedColor : void 0;
    },
    isDark() {
      if (this.type && !this.coloredBorder && !this.outlined)
        return true;
      return themeable_default.options.computed.isDark.call(this);
    }
  },
  created() {
    if (this.$attrs.hasOwnProperty("outline")) {
      breaking("outline", "outlined", this);
    }
  },
  methods: {
    genWrapper() {
      const children = [this.$slots.prepend || this.__cachedIcon, this.genContent(), this.__cachedBorder, this.$slots.append, this.$scopedSlots.close ? this.$scopedSlots.close({
        toggle: this.toggle
      }) : this.__cachedDismissible];
      const data = {
        staticClass: "v-alert__wrapper"
      };
      return this.$createElement("div", data, children);
    },
    genContent() {
      return this.$createElement("div", {
        staticClass: "v-alert__content"
      }, this.$slots.default);
    },
    genAlert() {
      let data = {
        staticClass: "v-alert",
        attrs: {
          role: "alert"
        },
        on: this.listeners$,
        class: this.classes,
        style: this.styles,
        directives: [{
          name: "show",
          value: this.isActive
        }]
      };
      if (!this.coloredBorder) {
        const setColor = this.hasText ? this.setTextColor : this.setBackgroundColor;
        data = setColor(this.computedColor, data);
      }
      return this.$createElement("div", data, [this.genWrapper()]);
    },
    toggle() {
      this.isActive = !this.isActive;
    }
  },
  render(h) {
    const render4 = this.genAlert();
    if (!this.transition)
      return render4;
    return h("transition", {
      props: {
        name: this.transition,
        origin: this.origin,
        mode: this.mode
      }
    }, [render4]);
  }
});

// node_modules/vuetify/lib/components/transitions/createTransition.js
function mergeTransitions(dest = [], ...transitions) {
  return Array().concat(dest, ...transitions);
}
function createSimpleTransition(name, origin = "top center 0", mode) {
  return {
    name,
    functional: true,
    props: {
      group: {
        type: Boolean,
        default: false
      },
      hideOnLeave: {
        type: Boolean,
        default: false
      },
      leaveAbsolute: {
        type: Boolean,
        default: false
      },
      mode: {
        type: String,
        default: mode
      },
      origin: {
        type: String,
        default: origin
      }
    },
    render(h, context) {
      const tag = `transition${context.props.group ? "-group" : ""}`;
      const data = {
        props: {
          name,
          mode: context.props.mode
        },
        on: {
          beforeEnter(el) {
            el.style.transformOrigin = context.props.origin;
            el.style.webkitTransformOrigin = context.props.origin;
          }
        }
      };
      if (context.props.leaveAbsolute) {
        data.on.leave = mergeTransitions(data.on.leave, (el) => {
          const {
            offsetTop,
            offsetLeft,
            offsetWidth,
            offsetHeight
          } = el;
          el._transitionInitialStyles = {
            position: el.style.position,
            top: el.style.top,
            left: el.style.left,
            width: el.style.width,
            height: el.style.height
          };
          el.style.position = "absolute";
          el.style.top = offsetTop + "px";
          el.style.left = offsetLeft + "px";
          el.style.width = offsetWidth + "px";
          el.style.height = offsetHeight + "px";
        });
        data.on.afterLeave = mergeTransitions(data.on.afterLeave, (el) => {
          if (el && el._transitionInitialStyles) {
            const {
              position,
              top,
              left,
              width,
              height
            } = el._transitionInitialStyles;
            delete el._transitionInitialStyles;
            el.style.position = position || "";
            el.style.top = top || "";
            el.style.left = left || "";
            el.style.width = width || "";
            el.style.height = height || "";
          }
        });
      }
      if (context.props.hideOnLeave) {
        data.on.leave = mergeTransitions(data.on.leave, (el) => {
          el.style.setProperty("display", "none", "important");
        });
      }
      return h(tag, mergeData2(context.data, data), context.children);
    }
  };
}
function createJavascriptTransition(name, functions, mode = "in-out") {
  return {
    name,
    functional: true,
    props: {
      mode: {
        type: String,
        default: mode
      }
    },
    render(h, context) {
      return h("transition", mergeData2(context.data, {
        props: {
          name
        },
        on: functions
      }), context.children);
    }
  };
}

// node_modules/vuetify/lib/components/transitions/expand-transition.js
function expand_transition_default(expandedParentClass = "", x = false) {
  const sizeProperty = x ? "width" : "height";
  const offsetProperty = `offset${upperFirst(sizeProperty)}`;
  return {
    beforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },
    enter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty("transition", "none", "important");
      el.style.overflow = "hidden";
      const offset = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = "0";
      void el.offsetHeight;
      el.style.transition = initialStyle.transition;
      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset;
      });
    },
    afterEnter: resetStyles,
    enterCancelled: resetStyles,
    leave(el) {
      el._initialStyle = {
        transition: "",
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = "hidden";
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight;
      requestAnimationFrame(() => el.style[sizeProperty] = "0");
    },
    afterLeave,
    leaveCancelled: afterLeave
  };
  function afterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el);
  }
  function resetStyles(el) {
    const size = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size != null)
      el.style[sizeProperty] = size;
    delete el._initialStyle;
  }
}

// node_modules/vuetify/lib/components/transitions/index.js
var VCarouselTransition = createSimpleTransition("carousel-transition");
var VCarouselReverseTransition = createSimpleTransition("carousel-reverse-transition");
var VTabTransition = createSimpleTransition("tab-transition");
var VTabReverseTransition = createSimpleTransition("tab-reverse-transition");
var VMenuTransition = createSimpleTransition("menu-transition");
var VFabTransition = createSimpleTransition("fab-transition", "center center", "out-in");
var VDialogTransition = createSimpleTransition("dialog-transition");
var VDialogBottomTransition = createSimpleTransition("dialog-bottom-transition");
var VDialogTopTransition = createSimpleTransition("dialog-top-transition");
var VFadeTransition = createSimpleTransition("fade-transition");
var VScaleTransition = createSimpleTransition("scale-transition");
var VScrollXTransition = createSimpleTransition("scroll-x-transition");
var VScrollXReverseTransition = createSimpleTransition("scroll-x-reverse-transition");
var VScrollYTransition = createSimpleTransition("scroll-y-transition");
var VScrollYReverseTransition = createSimpleTransition("scroll-y-reverse-transition");
var VSlideXTransition = createSimpleTransition("slide-x-transition");
var VSlideXReverseTransition = createSimpleTransition("slide-x-reverse-transition");
var VSlideYTransition = createSimpleTransition("slide-y-transition");
var VSlideYReverseTransition = createSimpleTransition("slide-y-reverse-transition");
var VExpandTransition = createJavascriptTransition("expand-transition", expand_transition_default());
var VExpandXTransition = createJavascriptTransition("expand-x-transition", expand_transition_default("", true));

// node_modules/vuetify/lib/components/VChip/VChip.js
var VChip_default = mixins(colorable_default, sizeable_default, routable_default, themeable_default, factory3("chipGroup"), factory2("inputValue")).extend({
  name: "v-chip",
  props: {
    active: {
      type: Boolean,
      default: true
    },
    activeClass: {
      type: String,
      default() {
        if (!this.chipGroup)
          return "";
        return this.chipGroup.activeClass;
      }
    },
    close: Boolean,
    closeIcon: {
      type: String,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    disabled: Boolean,
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: Boolean,
    outlined: Boolean,
    pill: Boolean,
    tag: {
      type: String,
      default: "span"
    },
    textColor: String,
    value: null
  },
  data: () => ({
    proxyClass: "v-chip--active"
  }),
  computed: {
    classes() {
      return __spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues({
        "v-chip": true
      }, routable_default.options.computed.classes.call(this)), {
        "v-chip--clickable": this.isClickable,
        "v-chip--disabled": this.disabled,
        "v-chip--draggable": this.draggable,
        "v-chip--label": this.label,
        "v-chip--link": this.isLink,
        "v-chip--no-color": !this.color,
        "v-chip--outlined": this.outlined,
        "v-chip--pill": this.pill,
        "v-chip--removable": this.hasClose
      }), this.themeClasses), this.sizeableClasses), this.groupClasses);
    },
    hasClose() {
      return Boolean(this.close);
    },
    isClickable() {
      return Boolean(routable_default.options.computed.isClickable.call(this) || this.chipGroup);
    }
  },
  created() {
    const breakingProps = [["outline", "outlined"], ["selected", "input-value"], ["value", "active"], ["@input", "@active.sync"]];
    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original))
        breaking(original, replacement, this);
    });
  },
  methods: {
    click(e) {
      this.$emit("click", e);
      this.chipGroup && this.toggle();
    },
    genFilter() {
      const children = [];
      if (this.isActive) {
        children.push(this.$createElement(VIcon_default2, {
          staticClass: "v-chip__filter",
          props: {
            left: true
          }
        }, this.filterIcon));
      }
      return this.$createElement(VExpandXTransition, children);
    },
    genClose() {
      return this.$createElement(VIcon_default2, {
        staticClass: "v-chip__close",
        props: {
          right: true,
          size: 18
        },
        attrs: {
          "aria-label": this.$vuetify.lang.t(this.closeLabel)
        },
        on: {
          click: (e) => {
            e.stopPropagation();
            e.preventDefault();
            this.$emit("click:close");
            this.$emit("update:active", false);
          }
        }
      }, this.closeIcon);
    },
    genContent() {
      return this.$createElement("span", {
        staticClass: "v-chip__content"
      }, [this.filter && this.genFilter(), this.$slots.default, this.hasClose && this.genClose()]);
    }
  },
  render(h) {
    const children = [this.genContent()];
    let {
      tag,
      data
    } = this.generateRouteLink();
    data.attrs = __spreadProps(__spreadValues({}, data.attrs), {
      draggable: this.draggable ? "true" : void 0,
      tabindex: this.chipGroup && !this.disabled ? 0 : data.attrs.tabindex
    });
    data.directives.push({
      name: "show",
      value: this.active
    });
    data = this.setBackgroundColor(this.color, data);
    const color = this.textColor || this.outlined && this.color;
    return h(tag, this.setTextColor(color, data), children);
  }
});

// node_modules/vuetify/lib/components/VChip/index.js
var VChip_default2 = VChip_default;

// node_modules/vuetify/lib/components/VThemeProvider/VThemeProvider.js
var VThemeProvider_default = themeable_default.extend({
  name: "v-theme-provider",
  props: {
    root: Boolean
  },
  computed: {
    isDark() {
      return this.root ? this.rootIsDark : themeable_default.options.computed.isDark.call(this);
    }
  },
  render() {
    return this.$slots.default && this.$slots.default.find((node) => !node.isComment && node.text !== " ");
  }
});

// node_modules/vuetify/lib/mixins/delayable/index.js
var delayable_default = vue_runtime_esm_default.extend().extend({
  name: "delayable",
  props: {
    openDelay: {
      type: [Number, String],
      default: 0
    },
    closeDelay: {
      type: [Number, String],
      default: 0
    }
  },
  data: () => ({
    openTimeout: void 0,
    closeTimeout: void 0
  }),
  methods: {
    clearDelay() {
      clearTimeout(this.openTimeout);
      clearTimeout(this.closeTimeout);
    },
    runDelay(type2, cb) {
      this.clearDelay();
      const delay = parseInt(this[`${type2}Delay`], 10);
      this[`${type2}Timeout`] = setTimeout(cb || (() => {
        this.isActive = {
          open: true,
          close: false
        }[type2];
      }), delay);
    }
  }
});

// node_modules/vuetify/lib/mixins/activatable/index.js
var baseMixins2 = mixins(delayable_default, toggleable_default);
var activatable_default = baseMixins2.extend({
  name: "activatable",
  props: {
    activator: {
      default: null,
      validator: (val) => {
        return ["string", "object"].includes(typeof val);
      }
    },
    disabled: Boolean,
    internalActivator: Boolean,
    openOnClick: {
      type: Boolean,
      default: true
    },
    openOnHover: Boolean,
    openOnFocus: Boolean
  },
  data: () => ({
    activatorElement: null,
    activatorNode: [],
    events: ["click", "mouseenter", "mouseleave", "focus"],
    listeners: {}
  }),
  watch: {
    activator: "resetActivator",
    openOnFocus: "resetActivator",
    openOnHover: "resetActivator"
  },
  mounted() {
    const slotType = getSlotType(this, "activator", true);
    if (slotType && ["v-slot", "normal"].includes(slotType)) {
      consoleError(`The activator slot must be bound, try '<template v-slot:activator="{ on }"><v-btn v-on="on">'`, this);
    }
    this.addActivatorEvents();
  },
  beforeDestroy() {
    this.removeActivatorEvents();
  },
  methods: {
    addActivatorEvents() {
      if (!this.activator || this.disabled || !this.getActivator())
        return;
      this.listeners = this.genActivatorListeners();
      const keys2 = Object.keys(this.listeners);
      for (const key of keys2) {
        this.getActivator().addEventListener(key, this.listeners[key]);
      }
    },
    genActivator() {
      const node = getSlot(this, "activator", Object.assign(this.getValueProxy(), {
        on: this.genActivatorListeners(),
        attrs: this.genActivatorAttributes()
      })) || [];
      this.activatorNode = node;
      return node;
    },
    genActivatorAttributes() {
      return {
        role: this.openOnClick && !this.openOnHover ? "button" : void 0,
        "aria-haspopup": true,
        "aria-expanded": String(this.isActive)
      };
    },
    genActivatorListeners() {
      if (this.disabled)
        return {};
      const listeners = {};
      if (this.openOnHover) {
        listeners.mouseenter = (e) => {
          this.getActivator(e);
          this.runDelay("open");
        };
        listeners.mouseleave = (e) => {
          this.getActivator(e);
          this.runDelay("close");
        };
      } else if (this.openOnClick) {
        listeners.click = (e) => {
          const activator = this.getActivator(e);
          if (activator)
            activator.focus();
          e.stopPropagation();
          this.isActive = !this.isActive;
        };
      }
      if (this.openOnFocus) {
        listeners.focus = (e) => {
          this.getActivator(e);
          e.stopPropagation();
          this.isActive = !this.isActive;
        };
      }
      return listeners;
    },
    getActivator(e) {
      var _activator;
      if (this.activatorElement)
        return this.activatorElement;
      let activator = null;
      if (this.activator) {
        const target2 = this.internalActivator ? this.$el : document;
        if (typeof this.activator === "string") {
          activator = target2.querySelector(this.activator);
        } else if (this.activator.$el) {
          activator = this.activator.$el;
        } else {
          activator = this.activator;
        }
      } else if (this.activatorNode.length === 1 || this.activatorNode.length && !e) {
        const vm = this.activatorNode[0].componentInstance;
        if (vm && vm.$options.mixins && vm.$options.mixins.some((m) => m.options && ["activatable", "menuable"].includes(m.options.name))) {
          activator = vm.getActivator();
        } else {
          activator = this.activatorNode[0].elm;
        }
      } else if (e) {
        activator = e.currentTarget || e.target;
      }
      this.activatorElement = ((_activator = activator) == null ? void 0 : _activator.nodeType) === Node.ELEMENT_NODE ? activator : null;
      return this.activatorElement;
    },
    getContentSlot() {
      return getSlot(this, "default", this.getValueProxy(), true);
    },
    getValueProxy() {
      const self = this;
      return {
        get value() {
          return self.isActive;
        },
        set value(isActive) {
          self.isActive = isActive;
        }
      };
    },
    removeActivatorEvents() {
      if (!this.activator || !this.activatorElement)
        return;
      const keys2 = Object.keys(this.listeners);
      for (const key of keys2) {
        this.activatorElement.removeEventListener(key, this.listeners[key]);
      }
      this.listeners = {};
    },
    resetActivator() {
      this.removeActivatorEvents();
      this.activatorElement = null;
      this.getActivator();
      this.addActivatorEvents();
    }
  }
});

// node_modules/vuetify/lib/mixins/dependent/index.js
function searchChildren(children) {
  const results = [];
  for (let index2 = 0; index2 < children.length; index2++) {
    const child = children[index2];
    if (child.isActive && child.isDependent) {
      results.push(child);
    } else {
      results.push(...searchChildren(child.$children));
    }
  }
  return results;
}
var dependent_default = mixins().extend({
  name: "dependent",
  data() {
    return {
      closeDependents: true,
      isActive: false,
      isDependent: true
    };
  },
  watch: {
    isActive(val) {
      if (val)
        return;
      const openDependents = this.getOpenDependents();
      for (let index2 = 0; index2 < openDependents.length; index2++) {
        openDependents[index2].isActive = false;
      }
    }
  },
  methods: {
    getOpenDependents() {
      if (this.closeDependents)
        return searchChildren(this.$children);
      return [];
    },
    getOpenDependentElements() {
      const result = [];
      const openDependents = this.getOpenDependents();
      for (let index2 = 0; index2 < openDependents.length; index2++) {
        result.push(...openDependents[index2].getClickableDependentElements());
      }
      return result;
    },
    getClickableDependentElements() {
      const result = [this.$el];
      if (this.$refs.content)
        result.push(this.$refs.content);
      if (this.overlay)
        result.push(this.overlay.$el);
      result.push(...this.getOpenDependentElements());
      return result;
    }
  }
});

// node_modules/vuetify/lib/mixins/stackable/index.js
var stackable_default = vue_runtime_esm_default.extend().extend({
  name: "stackable",
  data() {
    return {
      stackElement: null,
      stackExclude: null,
      stackMinZIndex: 0,
      isActive: false
    };
  },
  computed: {
    activeZIndex() {
      if (typeof window === "undefined")
        return 0;
      const content = this.stackElement || this.$refs.content;
      const index2 = !this.isActive ? getZIndex(content) : this.getMaxZIndex(this.stackExclude || [content]) + 2;
      if (index2 == null)
        return index2;
      return parseInt(index2);
    }
  },
  methods: {
    getMaxZIndex(exclude = []) {
      const base = this.$el;
      const zis = [this.stackMinZIndex, getZIndex(base)];
      const activeElements = [...document.getElementsByClassName("v-menu__content--active"), ...document.getElementsByClassName("v-dialog__content--active")];
      for (let index2 = 0; index2 < activeElements.length; index2++) {
        if (!exclude.includes(activeElements[index2])) {
          zis.push(getZIndex(activeElements[index2]));
        }
      }
      return Math.max(...zis);
    }
  }
});

// node_modules/vuetify/lib/mixins/bootable/index.js
var bootable_default = vue_runtime_esm_default.extend().extend({
  name: "bootable",
  props: {
    eager: Boolean
  },
  data: () => ({
    isBooted: false
  }),
  computed: {
    hasContent() {
      return this.isBooted || this.eager || this.isActive;
    }
  },
  watch: {
    isActive() {
      this.isBooted = true;
    }
  },
  created() {
    if ("lazy" in this.$attrs) {
      removed("lazy", this);
    }
  },
  methods: {
    showLazyContent(content) {
      return this.hasContent && content ? content() : [this.$createElement()];
    }
  }
});

// node_modules/vuetify/lib/mixins/detachable/index.js
function validateAttachTarget(val) {
  const type2 = typeof val;
  if (type2 === "boolean" || type2 === "string")
    return true;
  return val.nodeType === Node.ELEMENT_NODE;
}
function removeActivator(activator) {
  activator.forEach((node) => {
    node.elm && node.elm.parentNode && node.elm.parentNode.removeChild(node.elm);
  });
}
var detachable_default = mixins(bootable_default).extend({
  name: "detachable",
  props: {
    attach: {
      default: false,
      validator: validateAttachTarget
    },
    contentClass: {
      type: String,
      default: ""
    }
  },
  data: () => ({
    activatorNode: null,
    hasDetached: false
  }),
  watch: {
    attach() {
      this.hasDetached = false;
      this.initDetach();
    },
    hasContent() {
      this.$nextTick(this.initDetach);
    }
  },
  beforeMount() {
    this.$nextTick(() => {
      if (this.activatorNode) {
        const activator = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];
        activator.forEach((node) => {
          if (!node.elm)
            return;
          if (!this.$el.parentNode)
            return;
          const target2 = this.$el === this.$el.parentNode.firstChild ? this.$el : this.$el.nextSibling;
          this.$el.parentNode.insertBefore(node.elm, target2);
        });
      }
    });
  },
  mounted() {
    this.hasContent && this.initDetach();
  },
  deactivated() {
    this.isActive = false;
  },
  beforeDestroy() {
    if (this.$refs.content && this.$refs.content.parentNode) {
      this.$refs.content.parentNode.removeChild(this.$refs.content);
    }
  },
  destroyed() {
    if (this.activatorNode) {
      const activator = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];
      if (this.$el.isConnected) {
        const observer = new MutationObserver((list) => {
          if (list.some((record) => Array.from(record.removedNodes).includes(this.$el))) {
            observer.disconnect();
            removeActivator(activator);
          }
        });
        observer.observe(this.$el.parentNode, {
          subtree: false,
          childList: true
        });
      } else {
        removeActivator(activator);
      }
    }
  },
  methods: {
    getScopeIdAttrs() {
      const scopeId = getObjectValueByPath(this.$vnode, "context.$options._scopeId");
      return scopeId && {
        [scopeId]: ""
      };
    },
    initDetach() {
      if (this._isDestroyed || !this.$refs.content || this.hasDetached || this.attach === "" || this.attach === true || this.attach === "attach")
        return;
      let target2;
      if (this.attach === false) {
        target2 = document.querySelector("[data-app]");
      } else if (typeof this.attach === "string") {
        target2 = document.querySelector(this.attach);
      } else {
        target2 = this.attach;
      }
      if (!target2) {
        consoleWarn(`Unable to locate target ${this.attach || "[data-app]"}`, this);
        return;
      }
      target2.appendChild(this.$refs.content);
      this.hasDetached = true;
    }
  }
});

// node_modules/vuetify/lib/mixins/menuable/index.js
var baseMixins3 = mixins(stackable_default, factory(["top", "right", "bottom", "left", "absolute"]), activatable_default, detachable_default);
var menuable_default = baseMixins3.extend().extend({
  name: "menuable",
  props: {
    allowOverflow: Boolean,
    light: Boolean,
    dark: Boolean,
    maxWidth: {
      type: [Number, String],
      default: "auto"
    },
    minWidth: [Number, String],
    nudgeBottom: {
      type: [Number, String],
      default: 0
    },
    nudgeLeft: {
      type: [Number, String],
      default: 0
    },
    nudgeRight: {
      type: [Number, String],
      default: 0
    },
    nudgeTop: {
      type: [Number, String],
      default: 0
    },
    nudgeWidth: {
      type: [Number, String],
      default: 0
    },
    offsetOverflow: Boolean,
    positionX: {
      type: Number,
      default: null
    },
    positionY: {
      type: Number,
      default: null
    },
    zIndex: {
      type: [Number, String],
      default: null
    }
  },
  data: () => ({
    activatorNode: [],
    absoluteX: 0,
    absoluteY: 0,
    activatedBy: null,
    activatorFixed: false,
    dimensions: {
      activator: {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0,
        offsetTop: 0,
        scrollHeight: 0,
        offsetLeft: 0
      },
      content: {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0,
        offsetTop: 0,
        scrollHeight: 0
      }
    },
    relativeYOffset: 0,
    hasJustFocused: false,
    hasWindow: false,
    inputActivator: false,
    isContentActive: false,
    pageWidth: 0,
    pageYOffset: 0,
    stackClass: "v-menu__content--active",
    stackMinZIndex: 6
  }),
  computed: {
    computedLeft() {
      const a = this.dimensions.activator;
      const c = this.dimensions.content;
      const activatorLeft = (this.attach !== false ? a.offsetLeft : a.left) || 0;
      const minWidth = Math.max(a.width, c.width);
      let left = 0;
      left += activatorLeft;
      if (this.left || this.$vuetify.rtl && !this.right)
        left -= minWidth - a.width;
      if (this.offsetX) {
        const maxWidth = isNaN(Number(this.maxWidth)) ? a.width : Math.min(a.width, Number(this.maxWidth));
        left += this.left ? -maxWidth : a.width;
      }
      if (this.nudgeLeft)
        left -= parseInt(this.nudgeLeft);
      if (this.nudgeRight)
        left += parseInt(this.nudgeRight);
      return left;
    },
    computedTop() {
      const a = this.dimensions.activator;
      const c = this.dimensions.content;
      let top = 0;
      if (this.top)
        top += a.height - c.height;
      if (this.attach !== false)
        top += a.offsetTop;
      else
        top += a.top + this.pageYOffset;
      if (this.offsetY)
        top += this.top ? -a.height : a.height;
      if (this.nudgeTop)
        top -= parseInt(this.nudgeTop);
      if (this.nudgeBottom)
        top += parseInt(this.nudgeBottom);
      return top;
    },
    hasActivator() {
      return !!this.$slots.activator || !!this.$scopedSlots.activator || !!this.activator || !!this.inputActivator;
    },
    absoluteYOffset() {
      return this.pageYOffset - this.relativeYOffset;
    }
  },
  watch: {
    disabled(val) {
      val && this.callDeactivate();
    },
    isActive(val) {
      if (this.disabled)
        return;
      val ? this.callActivate() : this.callDeactivate();
    },
    positionX: "updateDimensions",
    positionY: "updateDimensions"
  },
  beforeMount() {
    this.hasWindow = typeof window !== "undefined";
    if (this.hasWindow) {
      window.addEventListener("resize", this.updateDimensions, false);
    }
  },
  beforeDestroy() {
    if (this.hasWindow) {
      window.removeEventListener("resize", this.updateDimensions, false);
    }
  },
  methods: {
    absolutePosition() {
      return {
        offsetTop: this.positionY || this.absoluteY,
        offsetLeft: this.positionX || this.absoluteX,
        scrollHeight: 0,
        top: this.positionY || this.absoluteY,
        bottom: this.positionY || this.absoluteY,
        left: this.positionX || this.absoluteX,
        right: this.positionX || this.absoluteX,
        height: 0,
        width: 0
      };
    },
    activate() {
    },
    calcLeft(menuWidth) {
      return convertToUnit(this.attach !== false ? this.computedLeft : this.calcXOverflow(this.computedLeft, menuWidth));
    },
    calcTop() {
      return convertToUnit(this.attach !== false ? this.computedTop : this.calcYOverflow(this.computedTop));
    },
    calcXOverflow(left, menuWidth) {
      const xOverflow = left + menuWidth - this.pageWidth + 12;
      if ((!this.left || this.right) && xOverflow > 0) {
        left = Math.max(left - xOverflow, 0);
      } else {
        left = Math.max(left, 12);
      }
      return left + this.getOffsetLeft();
    },
    calcYOverflow(top) {
      const documentHeight = this.getInnerHeight();
      const toTop = this.absoluteYOffset + documentHeight;
      const activator = this.dimensions.activator;
      const contentHeight = this.dimensions.content.height;
      const totalHeight = top + contentHeight;
      const isOverflowing = toTop < totalHeight;
      if (isOverflowing && this.offsetOverflow && activator.top > contentHeight) {
        top = this.pageYOffset + (activator.top - contentHeight);
      } else if (isOverflowing && !this.allowOverflow) {
        top = toTop - contentHeight - 12;
      } else if (top < this.absoluteYOffset && !this.allowOverflow) {
        top = this.absoluteYOffset + 12;
      }
      return top < 12 ? 12 : top;
    },
    callActivate() {
      if (!this.hasWindow)
        return;
      this.activate();
    },
    callDeactivate() {
      this.isContentActive = false;
      this.deactivate();
    },
    checkForPageYOffset() {
      if (this.hasWindow) {
        this.pageYOffset = this.activatorFixed ? 0 : this.getOffsetTop();
      }
    },
    checkActivatorFixed() {
      if (this.attach !== false)
        return;
      let el = this.getActivator();
      while (el) {
        if (window.getComputedStyle(el).position === "fixed") {
          this.activatorFixed = true;
          return;
        }
        el = el.offsetParent;
      }
      this.activatorFixed = false;
    },
    deactivate() {
    },
    genActivatorListeners() {
      const listeners = activatable_default.options.methods.genActivatorListeners.call(this);
      const onClick = listeners.click;
      if (onClick) {
        listeners.click = (e) => {
          if (this.openOnClick) {
            onClick && onClick(e);
          }
          this.absoluteX = e.clientX;
          this.absoluteY = e.clientY;
        };
      }
      return listeners;
    },
    getInnerHeight() {
      if (!this.hasWindow)
        return 0;
      return window.innerHeight || document.documentElement.clientHeight;
    },
    getOffsetLeft() {
      if (!this.hasWindow)
        return 0;
      return window.pageXOffset || document.documentElement.scrollLeft;
    },
    getOffsetTop() {
      if (!this.hasWindow)
        return 0;
      return window.pageYOffset || document.documentElement.scrollTop;
    },
    getRoundedBoundedClientRect(el) {
      const rect = el.getBoundingClientRect();
      return {
        top: Math.round(rect.top),
        left: Math.round(rect.left),
        bottom: Math.round(rect.bottom),
        right: Math.round(rect.right),
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
    },
    measure(el) {
      if (!el || !this.hasWindow)
        return null;
      const rect = this.getRoundedBoundedClientRect(el);
      if (this.attach !== false) {
        const style2 = window.getComputedStyle(el);
        rect.left = parseInt(style2.marginLeft);
        rect.top = parseInt(style2.marginTop);
      }
      return rect;
    },
    sneakPeek(cb) {
      requestAnimationFrame(() => {
        const el = this.$refs.content;
        if (!el || el.style.display !== "none") {
          cb();
          return;
        }
        el.style.display = "inline-block";
        cb();
        el.style.display = "none";
      });
    },
    startTransition() {
      return new Promise((resolve) => requestAnimationFrame(() => {
        this.isContentActive = this.hasJustFocused = this.isActive;
        resolve();
      }));
    },
    updateDimensions() {
      this.hasWindow = typeof window !== "undefined";
      this.checkActivatorFixed();
      this.checkForPageYOffset();
      this.pageWidth = document.documentElement.clientWidth;
      const dimensions = {
        activator: __spreadValues({}, this.dimensions.activator),
        content: __spreadValues({}, this.dimensions.content)
      };
      if (!this.hasActivator || this.absolute) {
        dimensions.activator = this.absolutePosition();
      } else {
        const activator = this.getActivator();
        if (!activator)
          return;
        dimensions.activator = this.measure(activator);
        dimensions.activator.offsetLeft = activator.offsetLeft;
        if (this.attach !== false) {
          dimensions.activator.offsetTop = activator.offsetTop;
        } else {
          dimensions.activator.offsetTop = 0;
        }
      }
      this.sneakPeek(() => {
        if (this.$refs.content) {
          if (this.$refs.content.offsetParent) {
            const offsetRect = this.getRoundedBoundedClientRect(this.$refs.content.offsetParent);
            this.relativeYOffset = window.pageYOffset + offsetRect.top;
            dimensions.activator.top -= this.relativeYOffset;
            dimensions.activator.left -= window.pageXOffset + offsetRect.left;
          }
          dimensions.content = this.measure(this.$refs.content);
        }
        this.dimensions = dimensions;
      });
    }
  }
});

// node_modules/vuetify/lib/mixins/returnable/index.js
var returnable_default = vue_runtime_esm_default.extend({
  name: "returnable",
  props: {
    returnValue: null
  },
  data: () => ({
    isActive: false,
    originalValue: null
  }),
  watch: {
    isActive(val) {
      if (val) {
        this.originalValue = this.returnValue;
      } else {
        this.$emit("update:return-value", this.originalValue);
      }
    }
  },
  methods: {
    save(value) {
      this.originalValue = value;
      setTimeout(() => {
        this.isActive = false;
      });
    }
  }
});

// node_modules/vuetify/lib/components/VMenu/VMenu.js
var baseMixins4 = mixins(dependent_default, delayable_default, returnable_default, roundable_default, themeable_default, menuable_default);
var VMenu_default = baseMixins4.extend({
  name: "v-menu",
  directives: {
    ClickOutside: click_outside_default,
    Resize: resize_default
  },
  provide() {
    return {
      isInMenu: true,
      theme: this.theme
    };
  },
  props: {
    auto: Boolean,
    closeOnClick: {
      type: Boolean,
      default: true
    },
    closeOnContentClick: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    disableKeys: Boolean,
    maxHeight: {
      type: [Number, String],
      default: "auto"
    },
    offsetX: Boolean,
    offsetY: Boolean,
    openOnHover: Boolean,
    origin: {
      type: String,
      default: "top left"
    },
    transition: {
      type: [Boolean, String],
      default: "v-menu-transition"
    }
  },
  data() {
    return {
      calculatedTopAuto: 0,
      defaultOffset: 8,
      hasJustFocused: false,
      listIndex: -1,
      resizeTimeout: 0,
      selectedIndex: null,
      tiles: []
    };
  },
  computed: {
    activeTile() {
      return this.tiles[this.listIndex];
    },
    calculatedLeft() {
      const menuWidth = Math.max(this.dimensions.content.width, parseFloat(this.calculatedMinWidth));
      if (!this.auto)
        return this.calcLeft(menuWidth) || "0";
      return convertToUnit(this.calcXOverflow(this.calcLeftAuto(), menuWidth)) || "0";
    },
    calculatedMaxHeight() {
      const height = this.auto ? "200px" : convertToUnit(this.maxHeight);
      return height || "0";
    },
    calculatedMaxWidth() {
      return convertToUnit(this.maxWidth) || "0";
    },
    calculatedMinWidth() {
      if (this.minWidth) {
        return convertToUnit(this.minWidth) || "0";
      }
      const minWidth = Math.min(this.dimensions.activator.width + Number(this.nudgeWidth) + (this.auto ? 16 : 0), Math.max(this.pageWidth - 24, 0));
      const calculatedMaxWidth = isNaN(parseInt(this.calculatedMaxWidth)) ? minWidth : parseInt(this.calculatedMaxWidth);
      return convertToUnit(Math.min(calculatedMaxWidth, minWidth)) || "0";
    },
    calculatedTop() {
      const top = !this.auto ? this.calcTop() : convertToUnit(this.calcYOverflow(this.calculatedTopAuto));
      return top || "0";
    },
    hasClickableTiles() {
      return Boolean(this.tiles.find((tile) => tile.tabIndex > -1));
    },
    styles() {
      return {
        maxHeight: this.calculatedMaxHeight,
        minWidth: this.calculatedMinWidth,
        maxWidth: this.calculatedMaxWidth,
        top: this.calculatedTop,
        left: this.calculatedLeft,
        transformOrigin: this.origin,
        zIndex: this.zIndex || this.activeZIndex
      };
    }
  },
  watch: {
    isActive(val) {
      if (!val)
        this.listIndex = -1;
    },
    isContentActive(val) {
      this.hasJustFocused = val;
    },
    listIndex(next, prev) {
      if (next in this.tiles) {
        const tile = this.tiles[next];
        tile.classList.add("v-list-item--highlighted");
        const scrollTop = this.$refs.content.scrollTop;
        const contentHeight = this.$refs.content.clientHeight;
        if (scrollTop > tile.offsetTop - 8) {
          goTo(tile.offsetTop - tile.clientHeight, {
            appOffset: false,
            duration: 300,
            container: this.$refs.content
          });
        } else if (scrollTop + contentHeight < tile.offsetTop + tile.clientHeight + 8) {
          goTo(tile.offsetTop - contentHeight + tile.clientHeight * 2, {
            appOffset: false,
            duration: 300,
            container: this.$refs.content
          });
        }
      }
      prev in this.tiles && this.tiles[prev].classList.remove("v-list-item--highlighted");
    }
  },
  created() {
    if (this.$attrs.hasOwnProperty("full-width")) {
      removed("full-width", this);
    }
  },
  mounted() {
    this.isActive && this.callActivate();
  },
  methods: {
    activate() {
      this.updateDimensions();
      requestAnimationFrame(() => {
        this.startTransition().then(() => {
          if (this.$refs.content) {
            this.calculatedTopAuto = this.calcTopAuto();
            this.auto && (this.$refs.content.scrollTop = this.calcScrollPosition());
          }
        });
      });
    },
    calcScrollPosition() {
      const $el = this.$refs.content;
      const activeTile = $el.querySelector(".v-list-item--active");
      const maxScrollTop = $el.scrollHeight - $el.offsetHeight;
      return activeTile ? Math.min(maxScrollTop, Math.max(0, activeTile.offsetTop - $el.offsetHeight / 2 + activeTile.offsetHeight / 2)) : $el.scrollTop;
    },
    calcLeftAuto() {
      return parseInt(this.dimensions.activator.left - this.defaultOffset * 2);
    },
    calcTopAuto() {
      const $el = this.$refs.content;
      const activeTile = $el.querySelector(".v-list-item--active");
      if (!activeTile) {
        this.selectedIndex = null;
      }
      if (this.offsetY || !activeTile) {
        return this.computedTop;
      }
      this.selectedIndex = Array.from(this.tiles).indexOf(activeTile);
      const tileDistanceFromMenuTop = activeTile.offsetTop - this.calcScrollPosition();
      const firstTileOffsetTop = $el.querySelector(".v-list-item").offsetTop;
      return this.computedTop - tileDistanceFromMenuTop - firstTileOffsetTop - 1;
    },
    changeListIndex(e) {
      this.getTiles();
      if (!this.isActive || !this.hasClickableTiles) {
        return;
      } else if (e.keyCode === keyCodes.tab) {
        this.isActive = false;
        return;
      } else if (e.keyCode === keyCodes.down) {
        this.nextTile();
      } else if (e.keyCode === keyCodes.up) {
        this.prevTile();
      } else if (e.keyCode === keyCodes.end) {
        this.lastTile();
      } else if (e.keyCode === keyCodes.home) {
        this.firstTile();
      } else if (e.keyCode === keyCodes.enter && this.listIndex !== -1) {
        this.tiles[this.listIndex].click();
      } else {
        return;
      }
      e.preventDefault();
    },
    closeConditional(e) {
      const target2 = e.target;
      return this.isActive && !this._isDestroyed && this.closeOnClick && !this.$refs.content.contains(target2);
    },
    genActivatorAttributes() {
      const attributes = activatable_default.options.methods.genActivatorAttributes.call(this);
      if (this.activeTile && this.activeTile.id) {
        return __spreadProps(__spreadValues({}, attributes), {
          "aria-activedescendant": this.activeTile.id
        });
      }
      return attributes;
    },
    genActivatorListeners() {
      const listeners = menuable_default.options.methods.genActivatorListeners.call(this);
      if (!this.disableKeys) {
        listeners.keydown = this.onKeyDown;
      }
      return listeners;
    },
    genTransition() {
      const content = this.genContent();
      if (!this.transition)
        return content;
      return this.$createElement("transition", {
        props: {
          name: this.transition
        }
      }, [content]);
    },
    genDirectives() {
      const directives2 = [{
        name: "show",
        value: this.isContentActive
      }];
      if (!this.openOnHover && this.closeOnClick) {
        directives2.push({
          name: "click-outside",
          value: {
            handler: () => {
              this.isActive = false;
            },
            closeConditional: this.closeConditional,
            include: () => [this.$el, ...this.getOpenDependentElements()]
          }
        });
      }
      return directives2;
    },
    genContent() {
      const options = {
        attrs: __spreadProps(__spreadValues({}, this.getScopeIdAttrs()), {
          role: "role" in this.$attrs ? this.$attrs.role : "menu"
        }),
        staticClass: "v-menu__content",
        class: __spreadProps(__spreadValues(__spreadValues({}, this.rootThemeClasses), this.roundedClasses), {
          "v-menu__content--auto": this.auto,
          "v-menu__content--fixed": this.activatorFixed,
          menuable__content__active: this.isActive,
          [this.contentClass.trim()]: true
        }),
        style: this.styles,
        directives: this.genDirectives(),
        ref: "content",
        on: {
          click: (e) => {
            const target2 = e.target;
            if (target2.getAttribute("disabled"))
              return;
            if (this.closeOnContentClick)
              this.isActive = false;
          },
          keydown: this.onKeyDown
        }
      };
      if (this.$listeners.scroll) {
        options.on = options.on || {};
        options.on.scroll = this.$listeners.scroll;
      }
      if (!this.disabled && this.openOnHover) {
        options.on = options.on || {};
        options.on.mouseenter = this.mouseEnterHandler;
      }
      if (this.openOnHover) {
        options.on = options.on || {};
        options.on.mouseleave = this.mouseLeaveHandler;
      }
      return this.$createElement("div", options, this.getContentSlot());
    },
    getTiles() {
      if (!this.$refs.content)
        return;
      this.tiles = Array.from(this.$refs.content.querySelectorAll(".v-list-item, .v-divider, .v-subheader"));
    },
    mouseEnterHandler() {
      this.runDelay("open", () => {
        if (this.hasJustFocused)
          return;
        this.hasJustFocused = true;
      });
    },
    mouseLeaveHandler(e) {
      this.runDelay("close", () => {
        var _this$$refs$content;
        if ((_this$$refs$content = this.$refs.content) != null && _this$$refs$content.contains(e.relatedTarget))
          return;
        requestAnimationFrame(() => {
          this.isActive = false;
          this.callDeactivate();
        });
      });
    },
    nextTile() {
      const tile = this.tiles[this.listIndex + 1];
      if (!tile) {
        if (!this.tiles.length)
          return;
        this.listIndex = -1;
        this.nextTile();
        return;
      }
      this.listIndex++;
      if (tile.tabIndex === -1)
        this.nextTile();
    },
    prevTile() {
      const tile = this.tiles[this.listIndex - 1];
      if (!tile) {
        if (!this.tiles.length)
          return;
        this.listIndex = this.tiles.length;
        this.prevTile();
        return;
      }
      this.listIndex--;
      if (tile.tabIndex === -1)
        this.prevTile();
    },
    lastTile() {
      const tile = this.tiles[this.tiles.length - 1];
      if (!tile)
        return;
      this.listIndex = this.tiles.length - 1;
      if (tile.tabIndex === -1)
        this.prevTile();
    },
    firstTile() {
      const tile = this.tiles[0];
      if (!tile)
        return;
      this.listIndex = 0;
      if (tile.tabIndex === -1)
        this.nextTile();
    },
    onKeyDown(e) {
      if (e.keyCode === keyCodes.esc) {
        setTimeout(() => {
          this.isActive = false;
        });
        const activator = this.getActivator();
        this.$nextTick(() => activator && activator.focus());
      } else if (!this.isActive && [keyCodes.up, keyCodes.down].includes(e.keyCode)) {
        this.isActive = true;
      }
      this.$nextTick(() => this.changeListIndex(e));
    },
    onResize() {
      if (!this.isActive)
        return;
      this.$refs.content.offsetWidth;
      this.updateDimensions();
      clearTimeout(this.resizeTimeout);
      this.resizeTimeout = window.setTimeout(this.updateDimensions, 100);
    }
  },
  render(h) {
    const data = {
      staticClass: "v-menu",
      class: {
        "v-menu--attached": this.attach === "" || this.attach === true || this.attach === "attach"
      },
      directives: [{
        arg: "500",
        name: "resize",
        value: this.onResize
      }]
    };
    return h("div", data, [!this.activator && this.genActivator(), this.showLazyContent(() => [this.$createElement(VThemeProvider_default, {
      props: {
        root: true,
        light: this.light,
        dark: this.dark
      }
    }, [this.genTransition()])])]);
  }
});

// node_modules/vuetify/lib/components/VMenu/index.js
var VMenu_default2 = VMenu_default;

// node_modules/vuetify/lib/components/VCheckbox/VSimpleCheckbox.js
var VSimpleCheckbox_default = vue_runtime_esm_default.extend({
  name: "v-simple-checkbox",
  functional: true,
  directives: {
    ripple: ripple_default
  },
  props: __spreadProps(__spreadValues(__spreadValues({}, colorable_default.options.props), themeable_default.options.props), {
    disabled: Boolean,
    ripple: {
      type: Boolean,
      default: true
    },
    value: Boolean,
    indeterminate: Boolean,
    indeterminateIcon: {
      type: String,
      default: "$checkboxIndeterminate"
    },
    onIcon: {
      type: String,
      default: "$checkboxOn"
    },
    offIcon: {
      type: String,
      default: "$checkboxOff"
    }
  }),
  render(h, {
    props: props2,
    data,
    listeners
  }) {
    const children = [];
    let icon = props2.offIcon;
    if (props2.indeterminate)
      icon = props2.indeterminateIcon;
    else if (props2.value)
      icon = props2.onIcon;
    children.push(h(VIcon_default, colorable_default.options.methods.setTextColor(props2.value && props2.color, {
      props: {
        disabled: props2.disabled,
        dark: props2.dark,
        light: props2.light
      }
    }), icon));
    if (props2.ripple && !props2.disabled) {
      const ripple = h("div", colorable_default.options.methods.setTextColor(props2.color, {
        staticClass: "v-input--selection-controls__ripple",
        directives: [{
          name: "ripple",
          value: {
            center: true
          }
        }]
      }));
      children.push(ripple);
    }
    return h("div", mergeData2(data, {
      class: {
        "v-simple-checkbox": true,
        "v-simple-checkbox--disabled": props2.disabled
      },
      on: {
        click: (e) => {
          e.stopPropagation();
          if (data.on && data.on.input && !props2.disabled) {
            wrapInArray(data.on.input).forEach((f) => f(!props2.value));
          }
        }
      }
    }), [h("div", {
      staticClass: "v-input--selection-controls__input"
    }, children)]);
  }
});

// node_modules/vuetify/lib/components/VDivider/VDivider.js
var VDivider_default = themeable_default.extend({
  name: "v-divider",
  props: {
    inset: Boolean,
    vertical: Boolean
  },
  render(h) {
    let orientation;
    if (!this.$attrs.role || this.$attrs.role === "separator") {
      orientation = this.vertical ? "vertical" : "horizontal";
    }
    return h("hr", {
      class: __spreadValues({
        "v-divider": true,
        "v-divider--inset": this.inset,
        "v-divider--vertical": this.vertical
      }, this.themeClasses),
      attrs: __spreadValues({
        role: "separator",
        "aria-orientation": orientation
      }, this.$attrs),
      on: this.$listeners
    });
  }
});

// node_modules/vuetify/lib/components/VDivider/index.js
var VDivider_default2 = VDivider_default;

// node_modules/vuetify/lib/components/VSubheader/VSubheader.js
var VSubheader_default = mixins(themeable_default).extend({
  name: "v-subheader",
  props: {
    inset: Boolean
  },
  render(h) {
    return h("div", {
      staticClass: "v-subheader",
      class: __spreadValues({
        "v-subheader--inset": this.inset
      }, this.themeClasses),
      attrs: this.$attrs,
      on: this.$listeners
    }, this.$slots.default);
  }
});

// node_modules/vuetify/lib/components/VSubheader/index.js
var VSubheader_default2 = VSubheader_default;

// node_modules/vuetify/lib/components/VList/VList.js
var VList_default = VSheet_default.extend().extend({
  name: "v-list",
  provide() {
    return {
      isInList: true,
      list: this
    };
  },
  inject: {
    isInMenu: {
      default: false
    },
    isInNav: {
      default: false
    }
  },
  props: {
    dense: Boolean,
    disabled: Boolean,
    expand: Boolean,
    flat: Boolean,
    nav: Boolean,
    rounded: Boolean,
    subheader: Boolean,
    threeLine: Boolean,
    twoLine: Boolean
  },
  data: () => ({
    groups: []
  }),
  computed: {
    classes() {
      return __spreadProps(__spreadValues({}, VSheet_default.options.computed.classes.call(this)), {
        "v-list--dense": this.dense,
        "v-list--disabled": this.disabled,
        "v-list--flat": this.flat,
        "v-list--nav": this.nav,
        "v-list--rounded": this.rounded,
        "v-list--subheader": this.subheader,
        "v-list--two-line": this.twoLine,
        "v-list--three-line": this.threeLine
      });
    }
  },
  methods: {
    register(content) {
      this.groups.push(content);
    },
    unregister(content) {
      const index2 = this.groups.findIndex((g) => g._uid === content._uid);
      if (index2 > -1)
        this.groups.splice(index2, 1);
    },
    listClick(uid2) {
      if (this.expand)
        return;
      for (const group of this.groups) {
        group.toggle(uid2);
      }
    }
  },
  render(h) {
    const data = {
      staticClass: "v-list",
      class: this.classes,
      style: this.styles,
      attrs: __spreadValues({
        role: this.isInNav || this.isInMenu ? void 0 : "list"
      }, this.attrs$)
    };
    return h(this.tag, this.setBackgroundColor(this.color, data), [this.$slots.default]);
  }
});

// node_modules/vuetify/lib/components/VList/VListItem.js
var baseMixins5 = mixins(colorable_default, routable_default, themeable_default, factory3("listItemGroup"), factory2("inputValue"));
var VListItem_default = baseMixins5.extend().extend({
  name: "v-list-item",
  directives: {
    Ripple: ripple_default
  },
  inject: {
    isInGroup: {
      default: false
    },
    isInList: {
      default: false
    },
    isInMenu: {
      default: false
    },
    isInNav: {
      default: false
    }
  },
  inheritAttrs: false,
  props: {
    activeClass: {
      type: String,
      default() {
        if (!this.listItemGroup)
          return "";
        return this.listItemGroup.activeClass;
      }
    },
    dense: Boolean,
    inactive: Boolean,
    link: Boolean,
    selectable: {
      type: Boolean
    },
    tag: {
      type: String,
      default: "div"
    },
    threeLine: Boolean,
    twoLine: Boolean,
    value: null
  },
  data: () => ({
    proxyClass: "v-list-item--active"
  }),
  computed: {
    classes() {
      return __spreadValues(__spreadProps(__spreadValues({
        "v-list-item": true
      }, routable_default.options.computed.classes.call(this)), {
        "v-list-item--dense": this.dense,
        "v-list-item--disabled": this.disabled,
        "v-list-item--link": this.isClickable && !this.inactive,
        "v-list-item--selectable": this.selectable,
        "v-list-item--three-line": this.threeLine,
        "v-list-item--two-line": this.twoLine
      }), this.themeClasses);
    },
    isClickable() {
      return Boolean(routable_default.options.computed.isClickable.call(this) || this.listItemGroup);
    }
  },
  created() {
    if (this.$attrs.hasOwnProperty("avatar")) {
      removed("avatar", this);
    }
  },
  methods: {
    click(e) {
      if (e.detail)
        this.$el.blur();
      this.$emit("click", e);
      this.to || this.toggle();
    },
    genAttrs() {
      const attrs2 = __spreadValues({
        "aria-disabled": this.disabled ? true : void 0,
        tabindex: this.isClickable && !this.disabled ? 0 : -1
      }, this.$attrs);
      if (this.$attrs.hasOwnProperty("role")) {
      } else if (this.isInNav) {
      } else if (this.isInGroup) {
        attrs2.role = "option";
        attrs2["aria-selected"] = String(this.isActive);
      } else if (this.isInMenu) {
        attrs2.role = this.isClickable ? "menuitem" : void 0;
        attrs2.id = attrs2.id || `list-item-${this._uid}`;
      } else if (this.isInList) {
        attrs2.role = "listitem";
      }
      return attrs2;
    },
    toggle() {
      if (this.to && this.inputValue === void 0) {
        this.isActive = !this.isActive;
      }
      this.$emit("change");
    }
  },
  render(h) {
    let {
      tag,
      data
    } = this.generateRouteLink();
    data.attrs = __spreadValues(__spreadValues({}, data.attrs), this.genAttrs());
    data[this.to ? "nativeOn" : "on"] = __spreadProps(__spreadValues({}, data[this.to ? "nativeOn" : "on"]), {
      keydown: (e) => {
        if (e.keyCode === keyCodes.enter)
          this.click(e);
        this.$emit("keydown", e);
      }
    });
    if (this.inactive)
      tag = "div";
    if (this.inactive && this.to) {
      data.on = data.nativeOn;
      delete data.nativeOn;
    }
    const children = this.$scopedSlots.default ? this.$scopedSlots.default({
      active: this.isActive,
      toggle: this.toggle
    }) : this.$slots.default;
    return h(tag, this.isActive ? this.setTextColor(this.color, data) : data, children);
  }
});

// node_modules/vuetify/lib/mixins/comparable/index.js
var comparable_default = vue_runtime_esm_default.extend({
  name: "comparable",
  props: {
    valueComparator: {
      type: Function,
      default: deepEqual
    }
  }
});

// node_modules/vuetify/lib/mixins/proxyable/index.js
function factory4(prop = "value", event = "change") {
  return vue_runtime_esm_default.extend({
    name: "proxyable",
    model: {
      prop,
      event
    },
    props: {
      [prop]: {
        required: false
      }
    },
    data() {
      return {
        internalLazyValue: this[prop]
      };
    },
    computed: {
      internalValue: {
        get() {
          return this.internalLazyValue;
        },
        set(val) {
          if (val === this.internalLazyValue)
            return;
          this.internalLazyValue = val;
          this.$emit(event, val);
        }
      }
    },
    watch: {
      [prop](val) {
        this.internalLazyValue = val;
      }
    }
  });
}
var Proxyable = factory4();
var proxyable_default = Proxyable;

// node_modules/vuetify/lib/components/VList/VListItemAction.js
var VListItemAction_default = vue_runtime_esm_default.extend({
  name: "v-list-item-action",
  functional: true,
  render(h, {
    data,
    children = []
  }) {
    data.staticClass = data.staticClass ? `v-list-item__action ${data.staticClass}` : "v-list-item__action";
    const filteredChild = children.filter((VNode3) => {
      return VNode3.isComment === false && VNode3.text !== " ";
    });
    if (filteredChild.length > 1)
      data.staticClass += " v-list-item__action--stack";
    return h("div", data, children);
  }
});

// node_modules/vuetify/lib/components/VList/index.js
var VListItemActionText = createSimpleFunctional("v-list-item__action-text", "span");
var VListItemContent = createSimpleFunctional("v-list-item__content", "div");
var VListItemTitle = createSimpleFunctional("v-list-item__title", "div");
var VListItemSubtitle = createSimpleFunctional("v-list-item__subtitle", "div");

// node_modules/vuetify/lib/components/VSelect/VSelectList.js
var VSelectList_default = mixins(colorable_default, themeable_default).extend({
  name: "v-select-list",
  directives: {
    ripple: ripple_default
  },
  props: {
    action: Boolean,
    dense: Boolean,
    hideSelected: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemDisabled: {
      type: [String, Array, Function],
      default: "disabled"
    },
    itemText: {
      type: [String, Array, Function],
      default: "text"
    },
    itemValue: {
      type: [String, Array, Function],
      default: "value"
    },
    noDataText: String,
    noFilter: Boolean,
    searchInput: null,
    selectedItems: {
      type: Array,
      default: () => []
    }
  },
  computed: {
    parsedItems() {
      return this.selectedItems.map((item) => this.getValue(item));
    },
    tileActiveClass() {
      return Object.keys(this.setTextColor(this.color).class || {}).join(" ");
    },
    staticNoDataTile() {
      const tile = {
        attrs: {
          role: void 0
        },
        on: {
          mousedown: (e) => e.preventDefault()
        }
      };
      return this.$createElement(VListItem_default, tile, [this.genTileContent(this.noDataText)]);
    }
  },
  methods: {
    genAction(item, inputValue) {
      return this.$createElement(VListItemAction_default, [this.$createElement(VSimpleCheckbox_default, {
        props: {
          color: this.color,
          value: inputValue,
          ripple: false
        },
        on: {
          input: () => this.$emit("select", item)
        }
      })]);
    },
    genDivider(props2) {
      return this.$createElement(VDivider_default2, {
        props: props2
      });
    },
    genFilteredText(text) {
      text = text || "";
      if (!this.searchInput || this.noFilter)
        return escapeHTML(text);
      const {
        start,
        middle,
        end
      } = this.getMaskedCharacters(text);
      return `${escapeHTML(start)}${this.genHighlight(middle)}${escapeHTML(end)}`;
    },
    genHeader(props2) {
      return this.$createElement(VSubheader_default2, {
        props: props2
      }, props2.header);
    },
    genHighlight(text) {
      return `<span class="v-list-item__mask">${escapeHTML(text)}</span>`;
    },
    getMaskedCharacters(text) {
      const searchInput = (this.searchInput || "").toString().toLocaleLowerCase();
      const index2 = text.toLocaleLowerCase().indexOf(searchInput);
      if (index2 < 0)
        return {
          start: text,
          middle: "",
          end: ""
        };
      const start = text.slice(0, index2);
      const middle = text.slice(index2, index2 + searchInput.length);
      const end = text.slice(index2 + searchInput.length);
      return {
        start,
        middle,
        end
      };
    },
    genTile({
      item,
      index: index2,
      disabled = null,
      value = false
    }) {
      if (!value)
        value = this.hasItem(item);
      if (item === Object(item)) {
        disabled = disabled !== null ? disabled : this.getDisabled(item);
      }
      const tile = {
        attrs: {
          "aria-selected": String(value),
          id: `list-item-${this._uid}-${index2}`,
          role: "option"
        },
        on: {
          mousedown: (e) => {
            e.preventDefault();
          },
          click: () => disabled || this.$emit("select", item)
        },
        props: {
          activeClass: this.tileActiveClass,
          disabled,
          ripple: true,
          inputValue: value
        }
      };
      if (!this.$scopedSlots.item) {
        return this.$createElement(VListItem_default, tile, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(item, value) : null, this.genTileContent(item, index2)]);
      }
      const parent = this;
      const scopedSlot = this.$scopedSlots.item({
        parent,
        item,
        attrs: __spreadValues(__spreadValues({}, tile.attrs), tile.props),
        on: tile.on
      });
      return this.needsTile(scopedSlot) ? this.$createElement(VListItem_default, tile, scopedSlot) : scopedSlot;
    },
    genTileContent(item, index2 = 0) {
      const innerHTML = this.genFilteredText(this.getText(item));
      return this.$createElement(VListItemContent, [this.$createElement(VListItemTitle, {
        domProps: {
          innerHTML
        }
      })]);
    },
    hasItem(item) {
      return this.parsedItems.indexOf(this.getValue(item)) > -1;
    },
    needsTile(slot) {
      return slot.length !== 1 || slot[0].componentOptions == null || slot[0].componentOptions.Ctor.options.name !== "v-list-item";
    },
    getDisabled(item) {
      return Boolean(getPropertyFromItem(item, this.itemDisabled, false));
    },
    getText(item) {
      return String(getPropertyFromItem(item, this.itemText, item));
    },
    getValue(item) {
      return getPropertyFromItem(item, this.itemValue, this.getText(item));
    }
  },
  render() {
    const children = [];
    const itemsLength = this.items.length;
    for (let index2 = 0; index2 < itemsLength; index2++) {
      const item = this.items[index2];
      if (this.hideSelected && this.hasItem(item))
        continue;
      if (item == null)
        children.push(this.genTile({
          item,
          index: index2
        }));
      else if (item.header)
        children.push(this.genHeader(item));
      else if (item.divider)
        children.push(this.genDivider(item));
      else
        children.push(this.genTile({
          item,
          index: index2
        }));
    }
    children.length || children.push(this.$slots["no-data"] || this.staticNoDataTile);
    this.$slots["prepend-item"] && children.unshift(this.$slots["prepend-item"]);
    this.$slots["append-item"] && children.push(this.$slots["append-item"]);
    return this.$createElement(VList_default, {
      staticClass: "v-select-list",
      class: this.themeClasses,
      attrs: {
        role: "listbox",
        tabindex: -1
      },
      props: {
        dense: this.dense
      }
    }, children);
  }
});

// node_modules/vuetify/lib/components/VLabel/VLabel.js
var VLabel_default = mixins(themeable_default).extend({
  name: "v-label",
  functional: true,
  props: {
    absolute: Boolean,
    color: {
      type: String,
      default: "primary"
    },
    disabled: Boolean,
    focused: Boolean,
    for: String,
    left: {
      type: [Number, String],
      default: 0
    },
    right: {
      type: [Number, String],
      default: "auto"
    },
    value: Boolean
  },
  render(h, ctx) {
    const {
      children,
      listeners,
      props: props2
    } = ctx;
    const data = {
      staticClass: "v-label",
      class: __spreadValues({
        "v-label--active": props2.value,
        "v-label--is-disabled": props2.disabled
      }, functionalThemeClasses(ctx)),
      attrs: {
        for: props2.for,
        "aria-hidden": !props2.for
      },
      on: listeners,
      style: {
        left: convertToUnit(props2.left),
        right: convertToUnit(props2.right),
        position: props2.absolute ? "absolute" : "relative"
      },
      ref: "label"
    };
    return h("label", colorable_default.options.methods.setTextColor(props2.focused && props2.color, data), children);
  }
});

// node_modules/vuetify/lib/components/VLabel/index.js
var VLabel_default2 = VLabel_default;

// node_modules/vuetify/lib/components/VMessages/VMessages.js
var VMessages_default = mixins(colorable_default, themeable_default).extend({
  name: "v-messages",
  props: {
    value: {
      type: Array,
      default: () => []
    }
  },
  methods: {
    genChildren() {
      return this.$createElement("transition-group", {
        staticClass: "v-messages__wrapper",
        attrs: {
          name: "message-transition",
          tag: "div"
        }
      }, this.value.map(this.genMessage));
    },
    genMessage(message, key) {
      return this.$createElement("div", {
        staticClass: "v-messages__message",
        key
      }, getSlot(this, "default", {
        message,
        key
      }) || [message]);
    }
  },
  render(h) {
    return h("div", this.setTextColor(this.color, {
      staticClass: "v-messages",
      class: this.themeClasses
    }), [this.genChildren()]);
  }
});

// node_modules/vuetify/lib/components/VMessages/index.js
var VMessages_default2 = VMessages_default;

// node_modules/vuetify/lib/mixins/validatable/index.js
var baseMixins6 = mixins(colorable_default, inject("form"), themeable_default);
var validatable_default = baseMixins6.extend({
  name: "validatable",
  props: {
    disabled: Boolean,
    error: Boolean,
    errorCount: {
      type: [Number, String],
      default: 1
    },
    errorMessages: {
      type: [String, Array],
      default: () => []
    },
    messages: {
      type: [String, Array],
      default: () => []
    },
    readonly: Boolean,
    rules: {
      type: Array,
      default: () => []
    },
    success: Boolean,
    successMessages: {
      type: [String, Array],
      default: () => []
    },
    validateOnBlur: Boolean,
    value: {
      required: false
    }
  },
  data() {
    return {
      errorBucket: [],
      hasColor: false,
      hasFocused: false,
      hasInput: false,
      isFocused: false,
      isResetting: false,
      lazyValue: this.value,
      valid: false
    };
  },
  computed: {
    computedColor() {
      if (this.isDisabled)
        return void 0;
      if (this.color)
        return this.color;
      if (this.isDark && !this.appIsDark)
        return "white";
      else
        return "primary";
    },
    hasError() {
      return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error;
    },
    hasSuccess() {
      return this.internalSuccessMessages.length > 0 || this.success;
    },
    externalError() {
      return this.internalErrorMessages.length > 0 || this.error;
    },
    hasMessages() {
      return this.validationTarget.length > 0;
    },
    hasState() {
      if (this.isDisabled)
        return false;
      return this.hasSuccess || this.shouldValidate && this.hasError;
    },
    internalErrorMessages() {
      return this.genInternalMessages(this.errorMessages);
    },
    internalMessages() {
      return this.genInternalMessages(this.messages);
    },
    internalSuccessMessages() {
      return this.genInternalMessages(this.successMessages);
    },
    internalValue: {
      get() {
        return this.lazyValue;
      },
      set(val) {
        this.lazyValue = val;
        this.$emit("input", val);
      }
    },
    isDisabled() {
      return this.disabled || !!this.form && this.form.disabled;
    },
    isInteractive() {
      return !this.isDisabled && !this.isReadonly;
    },
    isReadonly() {
      return this.readonly || !!this.form && this.form.readonly;
    },
    shouldValidate() {
      if (this.externalError)
        return true;
      if (this.isResetting)
        return false;
      return this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused;
    },
    validations() {
      return this.validationTarget.slice(0, Number(this.errorCount));
    },
    validationState() {
      if (this.isDisabled)
        return void 0;
      if (this.hasError && this.shouldValidate)
        return "error";
      if (this.hasSuccess)
        return "success";
      if (this.hasColor)
        return this.computedColor;
      return void 0;
    },
    validationTarget() {
      if (this.internalErrorMessages.length > 0) {
        return this.internalErrorMessages;
      } else if (this.successMessages && this.successMessages.length > 0) {
        return this.internalSuccessMessages;
      } else if (this.messages && this.messages.length > 0) {
        return this.internalMessages;
      } else if (this.shouldValidate) {
        return this.errorBucket;
      } else
        return [];
    }
  },
  watch: {
    rules: {
      handler(newVal, oldVal) {
        if (deepEqual(newVal, oldVal))
          return;
        this.validate();
      },
      deep: true
    },
    internalValue() {
      this.hasInput = true;
      this.validateOnBlur || this.$nextTick(this.validate);
    },
    isFocused(val) {
      if (!val && !this.isDisabled) {
        this.hasFocused = true;
        this.validateOnBlur && this.$nextTick(this.validate);
      }
    },
    isResetting() {
      setTimeout(() => {
        this.hasInput = false;
        this.hasFocused = false;
        this.isResetting = false;
        this.validate();
      }, 0);
    },
    hasError(val) {
      if (this.shouldValidate) {
        this.$emit("update:error", val);
      }
    },
    value(val) {
      this.lazyValue = val;
    }
  },
  beforeMount() {
    this.validate();
  },
  created() {
    this.form && this.form.register(this);
  },
  beforeDestroy() {
    this.form && this.form.unregister(this);
  },
  methods: {
    genInternalMessages(messages) {
      if (!messages)
        return [];
      else if (Array.isArray(messages))
        return messages;
      else
        return [messages];
    },
    reset() {
      this.isResetting = true;
      this.internalValue = Array.isArray(this.internalValue) ? [] : null;
    },
    resetValidation() {
      this.isResetting = true;
    },
    validate(force = false, value) {
      const errorBucket = [];
      value = value || this.internalValue;
      if (force)
        this.hasInput = this.hasFocused = true;
      for (let index2 = 0; index2 < this.rules.length; index2++) {
        const rule = this.rules[index2];
        const valid = typeof rule === "function" ? rule(value) : rule;
        if (valid === false || typeof valid === "string") {
          errorBucket.push(valid || "");
        } else if (typeof valid !== "boolean") {
          consoleError(`Rules should return a string or boolean, received '${typeof valid}' instead`, this);
        }
      }
      this.errorBucket = errorBucket;
      this.valid = errorBucket.length === 0;
      return this.valid;
    }
  }
});

// node_modules/vuetify/lib/components/VInput/VInput.js
var baseMixins7 = mixins(binds_attrs_default, validatable_default);
var VInput_default = baseMixins7.extend().extend({
  name: "v-input",
  inheritAttrs: false,
  props: {
    appendIcon: String,
    backgroundColor: {
      type: String,
      default: ""
    },
    dense: Boolean,
    height: [Number, String],
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    id: String,
    label: String,
    loading: Boolean,
    persistentHint: Boolean,
    prependIcon: String,
    value: null
  },
  data() {
    return {
      lazyValue: this.value,
      hasMouseDown: false
    };
  },
  computed: {
    classes() {
      return __spreadValues({
        "v-input--has-state": this.hasState,
        "v-input--hide-details": !this.showDetails,
        "v-input--is-label-active": this.isLabelActive,
        "v-input--is-dirty": this.isDirty,
        "v-input--is-disabled": this.isDisabled,
        "v-input--is-focused": this.isFocused,
        "v-input--is-loading": this.loading !== false && this.loading != null,
        "v-input--is-readonly": this.isReadonly,
        "v-input--dense": this.dense,
        "v-input--hide-spin-buttons": this.hideSpinButtons
      }, this.themeClasses);
    },
    computedId() {
      return this.id || `input-${this._uid}`;
    },
    hasDetails() {
      return this.messagesToDisplay.length > 0;
    },
    hasHint() {
      return !this.hasMessages && !!this.hint && (this.persistentHint || this.isFocused);
    },
    hasLabel() {
      return !!(this.$slots.label || this.label);
    },
    internalValue: {
      get() {
        return this.lazyValue;
      },
      set(val) {
        this.lazyValue = val;
        this.$emit(this.$_modelEvent, val);
      }
    },
    isDirty() {
      return !!this.lazyValue;
    },
    isLabelActive() {
      return this.isDirty;
    },
    messagesToDisplay() {
      if (this.hasHint)
        return [this.hint];
      if (!this.hasMessages)
        return [];
      return this.validations.map((validation) => {
        if (typeof validation === "string")
          return validation;
        const validationResult = validation(this.internalValue);
        return typeof validationResult === "string" ? validationResult : "";
      }).filter((message) => message !== "");
    },
    showDetails() {
      return this.hideDetails === false || this.hideDetails === "auto" && this.hasDetails;
    }
  },
  watch: {
    value(val) {
      this.lazyValue = val;
    }
  },
  beforeCreate() {
    this.$_modelEvent = this.$options.model && this.$options.model.event || "input";
  },
  methods: {
    genContent() {
      return [this.genPrependSlot(), this.genControl(), this.genAppendSlot()];
    },
    genControl() {
      return this.$createElement("div", {
        staticClass: "v-input__control",
        attrs: {
          title: this.attrs$.title
        }
      }, [this.genInputSlot(), this.genMessages()]);
    },
    genDefaultSlot() {
      return [this.genLabel(), this.$slots.default];
    },
    genIcon(type2, cb, extraData = {}) {
      const icon = this[`${type2}Icon`];
      const eventName = `click:${kebabCase(type2)}`;
      const hasListener = !!(this.listeners$[eventName] || cb);
      const data = mergeData2({
        attrs: {
          "aria-label": hasListener ? kebabCase(type2).split("-")[0] + " icon" : void 0,
          color: this.validationState,
          dark: this.dark,
          disabled: this.isDisabled,
          light: this.light
        },
        on: !hasListener ? void 0 : {
          click: (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.$emit(eventName, e);
            cb && cb(e);
          },
          mouseup: (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }
      }, extraData);
      return this.$createElement("div", {
        staticClass: `v-input__icon`,
        class: type2 ? `v-input__icon--${kebabCase(type2)}` : void 0
      }, [this.$createElement(VIcon_default2, data, icon)]);
    },
    genInputSlot() {
      return this.$createElement("div", this.setBackgroundColor(this.backgroundColor, {
        staticClass: "v-input__slot",
        style: {
          height: convertToUnit(this.height)
        },
        on: {
          click: this.onClick,
          mousedown: this.onMouseDown,
          mouseup: this.onMouseUp
        },
        ref: "input-slot"
      }), [this.genDefaultSlot()]);
    },
    genLabel() {
      if (!this.hasLabel)
        return null;
      return this.$createElement(VLabel_default2, {
        props: {
          color: this.validationState,
          dark: this.dark,
          disabled: this.isDisabled,
          focused: this.hasState,
          for: this.computedId,
          light: this.light
        }
      }, this.$slots.label || this.label);
    },
    genMessages() {
      if (!this.showDetails)
        return null;
      return this.$createElement(VMessages_default2, {
        props: {
          color: this.hasHint ? "" : this.validationState,
          dark: this.dark,
          light: this.light,
          value: this.messagesToDisplay
        },
        attrs: {
          role: this.hasMessages ? "alert" : null
        },
        scopedSlots: {
          default: (props2) => getSlot(this, "message", props2)
        }
      });
    },
    genSlot(type2, location, slot) {
      if (!slot.length)
        return null;
      const ref2 = `${type2}-${location}`;
      return this.$createElement("div", {
        staticClass: `v-input__${ref2}`,
        ref: ref2
      }, slot);
    },
    genPrependSlot() {
      const slot = [];
      if (this.$slots.prepend) {
        slot.push(this.$slots.prepend);
      } else if (this.prependIcon) {
        slot.push(this.genIcon("prepend"));
      }
      return this.genSlot("prepend", "outer", slot);
    },
    genAppendSlot() {
      const slot = [];
      if (this.$slots.append) {
        slot.push(this.$slots.append);
      } else if (this.appendIcon) {
        slot.push(this.genIcon("append"));
      }
      return this.genSlot("append", "outer", slot);
    },
    onClick(e) {
      this.$emit("click", e);
    },
    onMouseDown(e) {
      this.hasMouseDown = true;
      this.$emit("mousedown", e);
    },
    onMouseUp(e) {
      this.hasMouseDown = false;
      this.$emit("mouseup", e);
    }
  },
  render(h) {
    return h("div", this.setTextColor(this.validationState, {
      staticClass: "v-input",
      class: this.classes
    }), this.genContent());
  }
});

// node_modules/vuetify/lib/components/VInput/index.js
var VInput_default2 = VInput_default;

// node_modules/vuetify/lib/components/VCounter/VCounter.js
var VCounter_default = mixins(themeable_default).extend({
  name: "v-counter",
  functional: true,
  props: {
    value: {
      type: [Number, String],
      default: ""
    },
    max: [Number, String]
  },
  render(h, ctx) {
    const {
      props: props2
    } = ctx;
    const max = parseInt(props2.max, 10);
    const value = parseInt(props2.value, 10);
    const content = max ? `${value} / ${max}` : String(props2.value);
    const isGreater = max && value > max;
    return h("div", {
      staticClass: "v-counter",
      class: __spreadValues({
        "error--text": isGreater
      }, functionalThemeClasses(ctx))
    }, content);
  }
});

// node_modules/vuetify/lib/components/VCounter/index.js
var VCounter_default2 = VCounter_default;

// node_modules/vuetify/lib/mixins/intersectable/index.js
function intersectable(options) {
  return vue_runtime_esm_default.extend({
    name: "intersectable",
    data: () => ({
      isIntersecting: false
    }),
    mounted() {
      intersect_default.inserted(this.$el, {
        name: "intersect",
        value: this.onObserve
      }, this.$vnode);
    },
    destroyed() {
      intersect_default.unbind(this.$el, {
        name: "intersect",
        value: this.onObserve
      }, this.$vnode);
    },
    methods: {
      onObserve(entries, observer, isIntersecting) {
        this.isIntersecting = isIntersecting;
        if (!isIntersecting)
          return;
        for (let i = 0, length = options.onVisible.length; i < length; i++) {
          const callback = this[options.onVisible[i]];
          if (typeof callback === "function") {
            callback();
            continue;
          }
          consoleWarn(options.onVisible[i] + " method is not available on the instance but referenced in intersectable mixin options");
        }
      }
    }
  });
}

// node_modules/vuetify/lib/components/VProgressLinear/VProgressLinear.js
var baseMixins8 = mixins(colorable_default, factory(["absolute", "fixed", "top", "bottom"]), proxyable_default, themeable_default);
var VProgressLinear_default = baseMixins8.extend({
  name: "v-progress-linear",
  directives: {
    intersect: intersect_default
  },
  props: {
    active: {
      type: Boolean,
      default: true
    },
    backgroundColor: {
      type: String,
      default: null
    },
    backgroundOpacity: {
      type: [Number, String],
      default: null
    },
    bufferValue: {
      type: [Number, String],
      default: 100
    },
    color: {
      type: String,
      default: "primary"
    },
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    query: Boolean,
    reverse: Boolean,
    rounded: Boolean,
    stream: Boolean,
    striped: Boolean,
    value: {
      type: [Number, String],
      default: 0
    }
  },
  data() {
    return {
      internalLazyValue: this.value || 0,
      isVisible: true
    };
  },
  computed: {
    __cachedBackground() {
      return this.$createElement("div", this.setBackgroundColor(this.backgroundColor || this.color, {
        staticClass: "v-progress-linear__background",
        style: this.backgroundStyle
      }));
    },
    __cachedBar() {
      return this.$createElement(this.computedTransition, [this.__cachedBarType]);
    },
    __cachedBarType() {
      return this.indeterminate ? this.__cachedIndeterminate : this.__cachedDeterminate;
    },
    __cachedBuffer() {
      return this.$createElement("div", {
        staticClass: "v-progress-linear__buffer",
        style: this.styles
      });
    },
    __cachedDeterminate() {
      return this.$createElement("div", this.setBackgroundColor(this.color, {
        staticClass: `v-progress-linear__determinate`,
        style: {
          width: convertToUnit(this.normalizedValue, "%")
        }
      }));
    },
    __cachedIndeterminate() {
      return this.$createElement("div", {
        staticClass: "v-progress-linear__indeterminate",
        class: {
          "v-progress-linear__indeterminate--active": this.active
        }
      }, [this.genProgressBar("long"), this.genProgressBar("short")]);
    },
    __cachedStream() {
      if (!this.stream)
        return null;
      return this.$createElement("div", this.setTextColor(this.color, {
        staticClass: "v-progress-linear__stream",
        style: {
          width: convertToUnit(100 - this.normalizedBuffer, "%")
        }
      }));
    },
    backgroundStyle() {
      const backgroundOpacity = this.backgroundOpacity == null ? this.backgroundColor ? 1 : 0.3 : parseFloat(this.backgroundOpacity);
      return {
        opacity: backgroundOpacity,
        [this.isReversed ? "right" : "left"]: convertToUnit(this.normalizedValue, "%"),
        width: convertToUnit(Math.max(0, this.normalizedBuffer - this.normalizedValue), "%")
      };
    },
    classes() {
      return __spreadValues({
        "v-progress-linear--absolute": this.absolute,
        "v-progress-linear--fixed": this.fixed,
        "v-progress-linear--query": this.query,
        "v-progress-linear--reactive": this.reactive,
        "v-progress-linear--reverse": this.isReversed,
        "v-progress-linear--rounded": this.rounded,
        "v-progress-linear--striped": this.striped,
        "v-progress-linear--visible": this.isVisible
      }, this.themeClasses);
    },
    computedTransition() {
      return this.indeterminate ? VFadeTransition : VSlideXTransition;
    },
    isReversed() {
      return this.$vuetify.rtl !== this.reverse;
    },
    normalizedBuffer() {
      return this.normalize(this.bufferValue);
    },
    normalizedValue() {
      return this.normalize(this.internalLazyValue);
    },
    reactive() {
      return Boolean(this.$listeners.change);
    },
    styles() {
      const styles = {};
      if (!this.active) {
        styles.height = 0;
      }
      if (!this.indeterminate && parseFloat(this.normalizedBuffer) !== 100) {
        styles.width = convertToUnit(this.normalizedBuffer, "%");
      }
      return styles;
    }
  },
  methods: {
    genContent() {
      const slot = getSlot(this, "default", {
        value: this.internalLazyValue
      });
      if (!slot)
        return null;
      return this.$createElement("div", {
        staticClass: "v-progress-linear__content"
      }, slot);
    },
    genListeners() {
      const listeners = this.$listeners;
      if (this.reactive) {
        listeners.click = this.onClick;
      }
      return listeners;
    },
    genProgressBar(name) {
      return this.$createElement("div", this.setBackgroundColor(this.color, {
        staticClass: "v-progress-linear__indeterminate",
        class: {
          [name]: true
        }
      }));
    },
    onClick(e) {
      if (!this.reactive)
        return;
      const {
        width
      } = this.$el.getBoundingClientRect();
      this.internalValue = e.offsetX / width * 100;
    },
    onObserve(entries, observer, isIntersecting) {
      this.isVisible = isIntersecting;
    },
    normalize(value) {
      if (value < 0)
        return 0;
      if (value > 100)
        return 100;
      return parseFloat(value);
    }
  },
  render(h) {
    const data = {
      staticClass: "v-progress-linear",
      attrs: {
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": this.normalizedBuffer,
        "aria-valuenow": this.indeterminate ? void 0 : this.normalizedValue
      },
      class: this.classes,
      directives: [{
        name: "intersect",
        value: this.onObserve
      }],
      style: {
        bottom: this.bottom ? 0 : void 0,
        height: this.active ? convertToUnit(this.height) : 0,
        top: this.top ? 0 : void 0
      },
      on: this.genListeners()
    };
    return h("div", data, [this.__cachedStream, this.__cachedBackground, this.__cachedBuffer, this.__cachedBar, this.genContent()]);
  }
});

// node_modules/vuetify/lib/components/VProgressLinear/index.js
var VProgressLinear_default2 = VProgressLinear_default;

// node_modules/vuetify/lib/mixins/loadable/index.js
var loadable_default = vue_runtime_esm_default.extend().extend({
  name: "loadable",
  props: {
    loading: {
      type: [Boolean, String],
      default: false
    },
    loaderHeight: {
      type: [Number, String],
      default: 2
    }
  },
  methods: {
    genProgress() {
      if (this.loading === false)
        return null;
      return this.$slots.progress || this.$createElement(VProgressLinear_default2, {
        props: {
          absolute: true,
          color: this.loading === true || this.loading === "" ? this.color || "primary" : this.loading,
          height: this.loaderHeight,
          indeterminate: true
        }
      });
    }
  }
});

// node_modules/vuetify/lib/components/VTextField/VTextField.js
var baseMixins9 = mixins(VInput_default2, intersectable({
  onVisible: ["onResize", "tryAutofocus"]
}), loadable_default);
var dirtyTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
var VTextField_default = baseMixins9.extend().extend({
  name: "v-text-field",
  directives: {
    resize: resize_default,
    ripple: ripple_default
  },
  inheritAttrs: false,
  props: {
    appendOuterIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    clearIcon: {
      type: String,
      default: "$clear"
    },
    counter: [Boolean, Number, String],
    counterValue: Function,
    filled: Boolean,
    flat: Boolean,
    fullWidth: Boolean,
    label: String,
    outlined: Boolean,
    placeholder: String,
    prefix: String,
    prependInnerIcon: String,
    persistentPlaceholder: Boolean,
    reverse: Boolean,
    rounded: Boolean,
    shaped: Boolean,
    singleLine: Boolean,
    solo: Boolean,
    soloInverted: Boolean,
    suffix: String,
    type: {
      type: String,
      default: "text"
    }
  },
  data: () => ({
    badInput: false,
    labelWidth: 0,
    prefixWidth: 0,
    prependWidth: 0,
    initialValue: null,
    isBooted: false,
    isClearing: false
  }),
  computed: {
    classes() {
      return __spreadProps(__spreadValues({}, VInput_default2.options.computed.classes.call(this)), {
        "v-text-field": true,
        "v-text-field--full-width": this.fullWidth,
        "v-text-field--prefix": this.prefix,
        "v-text-field--single-line": this.isSingle,
        "v-text-field--solo": this.isSolo,
        "v-text-field--solo-inverted": this.soloInverted,
        "v-text-field--solo-flat": this.flat,
        "v-text-field--filled": this.filled,
        "v-text-field--is-booted": this.isBooted,
        "v-text-field--enclosed": this.isEnclosed,
        "v-text-field--reverse": this.reverse,
        "v-text-field--outlined": this.outlined,
        "v-text-field--placeholder": this.placeholder,
        "v-text-field--rounded": this.rounded,
        "v-text-field--shaped": this.shaped
      });
    },
    computedColor() {
      const computedColor = validatable_default.options.computed.computedColor.call(this);
      if (!this.soloInverted || !this.isFocused)
        return computedColor;
      return this.color || "primary";
    },
    computedCounterValue() {
      if (typeof this.counterValue === "function") {
        return this.counterValue(this.internalValue);
      }
      return [...(this.internalValue || "").toString()].length;
    },
    hasCounter() {
      return this.counter !== false && this.counter != null;
    },
    hasDetails() {
      return VInput_default2.options.computed.hasDetails.call(this) || this.hasCounter;
    },
    internalValue: {
      get() {
        return this.lazyValue;
      },
      set(val) {
        this.lazyValue = val;
        this.$emit("input", this.lazyValue);
      }
    },
    isDirty() {
      var _this$lazyValue;
      return ((_this$lazyValue = this.lazyValue) == null ? void 0 : _this$lazyValue.toString().length) > 0 || this.badInput;
    },
    isEnclosed() {
      return this.filled || this.isSolo || this.outlined;
    },
    isLabelActive() {
      return this.isDirty || dirtyTypes.includes(this.type);
    },
    isSingle() {
      return this.isSolo || this.singleLine || this.fullWidth || this.filled && !this.hasLabel;
    },
    isSolo() {
      return this.solo || this.soloInverted;
    },
    labelPosition() {
      let offset = this.prefix && !this.labelValue ? this.prefixWidth : 0;
      if (this.labelValue && this.prependWidth)
        offset -= this.prependWidth;
      return this.$vuetify.rtl === this.reverse ? {
        left: offset,
        right: "auto"
      } : {
        left: "auto",
        right: offset
      };
    },
    showLabel() {
      return this.hasLabel && !(this.isSingle && this.labelValue);
    },
    labelValue() {
      return this.isFocused || this.isLabelActive || this.persistentPlaceholder;
    }
  },
  watch: {
    outlined: "setLabelWidth",
    label() {
      this.$nextTick(this.setLabelWidth);
    },
    prefix() {
      this.$nextTick(this.setPrefixWidth);
    },
    isFocused: "updateValue",
    value(val) {
      this.lazyValue = val;
    }
  },
  created() {
    if (this.$attrs.hasOwnProperty("box")) {
      breaking("box", "filled", this);
    }
    if (this.$attrs.hasOwnProperty("browser-autocomplete")) {
      breaking("browser-autocomplete", "autocomplete", this);
    }
    if (this.shaped && !(this.filled || this.outlined || this.isSolo)) {
      consoleWarn("shaped should be used with either filled or outlined", this);
    }
  },
  mounted() {
    this.$watch(() => this.labelValue, this.setLabelWidth);
    this.autofocus && this.tryAutofocus();
    requestAnimationFrame(() => {
      this.isBooted = true;
      requestAnimationFrame(() => {
        if (!this.isIntersecting) {
          this.onResize();
        }
      });
    });
  },
  methods: {
    focus() {
      this.onFocus();
    },
    blur(e) {
      window.requestAnimationFrame(() => {
        this.$refs.input && this.$refs.input.blur();
      });
    },
    clearableCallback() {
      this.$refs.input && this.$refs.input.focus();
      this.$nextTick(() => this.internalValue = null);
    },
    genAppendSlot() {
      const slot = [];
      if (this.$slots["append-outer"]) {
        slot.push(this.$slots["append-outer"]);
      } else if (this.appendOuterIcon) {
        slot.push(this.genIcon("appendOuter"));
      }
      return this.genSlot("append", "outer", slot);
    },
    genPrependInnerSlot() {
      const slot = [];
      if (this.$slots["prepend-inner"]) {
        slot.push(this.$slots["prepend-inner"]);
      } else if (this.prependInnerIcon) {
        slot.push(this.genIcon("prependInner"));
      }
      return this.genSlot("prepend", "inner", slot);
    },
    genIconSlot() {
      const slot = [];
      if (this.$slots.append) {
        slot.push(this.$slots.append);
      } else if (this.appendIcon) {
        slot.push(this.genIcon("append"));
      }
      return this.genSlot("append", "inner", slot);
    },
    genInputSlot() {
      const input = VInput_default2.options.methods.genInputSlot.call(this);
      const prepend = this.genPrependInnerSlot();
      if (prepend) {
        input.children = input.children || [];
        input.children.unshift(prepend);
      }
      return input;
    },
    genClearIcon() {
      if (!this.clearable)
        return null;
      if (!this.isDirty) {
        return this.genSlot("append", "inner", [this.$createElement("div")]);
      }
      return this.genSlot("append", "inner", [this.genIcon("clear", this.clearableCallback)]);
    },
    genCounter() {
      var _this$$scopedSlots$co, _this$$scopedSlots$co2, _this$$scopedSlots;
      if (!this.hasCounter)
        return null;
      const max = this.counter === true ? this.attrs$.maxlength : this.counter;
      const props2 = {
        dark: this.dark,
        light: this.light,
        max,
        value: this.computedCounterValue
      };
      return (_this$$scopedSlots$co = (_this$$scopedSlots$co2 = (_this$$scopedSlots = this.$scopedSlots).counter) == null ? void 0 : _this$$scopedSlots$co2.call(_this$$scopedSlots, {
        props: props2
      })) != null ? _this$$scopedSlots$co : this.$createElement(VCounter_default2, {
        props: props2
      });
    },
    genControl() {
      return VInput_default2.options.methods.genControl.call(this);
    },
    genDefaultSlot() {
      return [this.genFieldset(), this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot(), this.genProgress()];
    },
    genFieldset() {
      if (!this.outlined)
        return null;
      return this.$createElement("fieldset", {
        attrs: {
          "aria-hidden": true
        }
      }, [this.genLegend()]);
    },
    genLabel() {
      if (!this.showLabel)
        return null;
      const data = {
        props: {
          absolute: true,
          color: this.validationState,
          dark: this.dark,
          disabled: this.isDisabled,
          focused: !this.isSingle && (this.isFocused || !!this.validationState),
          for: this.computedId,
          left: this.labelPosition.left,
          light: this.light,
          right: this.labelPosition.right,
          value: this.labelValue
        }
      };
      return this.$createElement(VLabel_default2, data, this.$slots.label || this.label);
    },
    genLegend() {
      const width = !this.singleLine && (this.labelValue || this.isDirty) ? this.labelWidth : 0;
      const span = this.$createElement("span", {
        domProps: {
          innerHTML: "&#8203;"
        },
        staticClass: "notranslate"
      });
      return this.$createElement("legend", {
        style: {
          width: !this.isSingle ? convertToUnit(width) : void 0
        }
      }, [span]);
    },
    genInput() {
      const listeners = Object.assign({}, this.listeners$);
      delete listeners.change;
      const _a = this.attrs$, {
        title
      } = _a, inputAttrs = __objRest(_a, [
        "title"
      ]);
      return this.$createElement("input", {
        style: {},
        domProps: {
          value: this.type === "number" && Object.is(this.lazyValue, -0) ? "-0" : this.lazyValue
        },
        attrs: __spreadProps(__spreadValues({}, inputAttrs), {
          autofocus: this.autofocus,
          disabled: this.isDisabled,
          id: this.computedId,
          placeholder: this.persistentPlaceholder || this.isFocused || !this.hasLabel ? this.placeholder : void 0,
          readonly: this.isReadonly,
          type: this.type
        }),
        on: Object.assign(listeners, {
          blur: this.onBlur,
          input: this.onInput,
          focus: this.onFocus,
          keydown: this.onKeyDown
        }),
        ref: "input",
        directives: [{
          name: "resize",
          modifiers: {
            quiet: true
          },
          value: this.onResize
        }]
      });
    },
    genMessages() {
      if (!this.showDetails)
        return null;
      const messagesNode = VInput_default2.options.methods.genMessages.call(this);
      const counterNode = this.genCounter();
      return this.$createElement("div", {
        staticClass: "v-text-field__details"
      }, [messagesNode, counterNode]);
    },
    genTextFieldSlot() {
      return this.$createElement("div", {
        staticClass: "v-text-field__slot"
      }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, this.genInput(), this.suffix ? this.genAffix("suffix") : null]);
    },
    genAffix(type2) {
      return this.$createElement("div", {
        class: `v-text-field__${type2}`,
        ref: type2
      }, this[type2]);
    },
    onBlur(e) {
      this.isFocused = false;
      e && this.$nextTick(() => this.$emit("blur", e));
    },
    onClick() {
      if (this.isFocused || this.isDisabled || !this.$refs.input)
        return;
      this.$refs.input.focus();
    },
    onFocus(e) {
      if (!this.$refs.input)
        return;
      const root = attachedRoot(this.$el);
      if (!root)
        return;
      if (root.activeElement !== this.$refs.input) {
        return this.$refs.input.focus();
      }
      if (!this.isFocused) {
        this.isFocused = true;
        e && this.$emit("focus", e);
      }
    },
    onInput(e) {
      const target2 = e.target;
      this.internalValue = target2.value;
      this.badInput = target2.validity && target2.validity.badInput;
    },
    onKeyDown(e) {
      if (e.keyCode === keyCodes.enter && this.lazyValue !== this.initialValue) {
        this.initialValue = this.lazyValue;
        this.$emit("change", this.initialValue);
      }
      this.$emit("keydown", e);
    },
    onMouseDown(e) {
      if (e.target !== this.$refs.input) {
        e.preventDefault();
        e.stopPropagation();
      }
      VInput_default2.options.methods.onMouseDown.call(this, e);
    },
    onMouseUp(e) {
      if (this.hasMouseDown)
        this.focus();
      VInput_default2.options.methods.onMouseUp.call(this, e);
    },
    setLabelWidth() {
      if (!this.outlined)
        return;
      this.labelWidth = this.$refs.label ? Math.min(this.$refs.label.scrollWidth * 0.75 + 6, this.$el.offsetWidth - 24) : 0;
    },
    setPrefixWidth() {
      if (!this.$refs.prefix)
        return;
      this.prefixWidth = this.$refs.prefix.offsetWidth;
    },
    setPrependWidth() {
      if (!this.outlined || !this.$refs["prepend-inner"])
        return;
      this.prependWidth = this.$refs["prepend-inner"].offsetWidth;
    },
    tryAutofocus() {
      if (!this.autofocus || typeof document === "undefined" || !this.$refs.input)
        return false;
      const root = attachedRoot(this.$el);
      if (!root || root.activeElement === this.$refs.input)
        return false;
      this.$refs.input.focus();
      return true;
    },
    updateValue(val) {
      this.hasColor = val;
      if (val) {
        this.initialValue = this.lazyValue;
      } else if (this.initialValue !== this.lazyValue) {
        this.$emit("change", this.lazyValue);
      }
    },
    onResize() {
      this.setLabelWidth();
      this.setPrefixWidth();
      this.setPrependWidth();
    }
  }
});

// node_modules/vuetify/lib/mixins/filterable/index.js
var filterable_default = vue_runtime_esm_default.extend({
  name: "filterable",
  props: {
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    }
  }
});

// node_modules/vuetify/lib/components/VSelect/VSelect.js
var defaultMenuProps = {
  closeOnClick: false,
  closeOnContentClick: false,
  disableKeys: true,
  openOnClick: false,
  maxHeight: 304
};
var baseMixins10 = mixins(VTextField_default, comparable_default, dependent_default, filterable_default);
var VSelect_default = baseMixins10.extend().extend({
  name: "v-select",
  directives: {
    ClickOutside: click_outside_default
  },
  props: {
    appendIcon: {
      type: String,
      default: "$dropdown"
    },
    attach: {
      type: null,
      default: false
    },
    cacheItems: Boolean,
    chips: Boolean,
    clearable: Boolean,
    deletableChips: Boolean,
    disableLookup: Boolean,
    eager: Boolean,
    hideSelected: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    itemColor: {
      type: String,
      default: "primary"
    },
    itemDisabled: {
      type: [String, Array, Function],
      default: "disabled"
    },
    itemText: {
      type: [String, Array, Function],
      default: "text"
    },
    itemValue: {
      type: [String, Array, Function],
      default: "value"
    },
    menuProps: {
      type: [String, Array, Object],
      default: () => defaultMenuProps
    },
    multiple: Boolean,
    openOnClear: Boolean,
    returnObject: Boolean,
    smallChips: Boolean
  },
  data() {
    return {
      cachedItems: this.cacheItems ? this.items : [],
      menuIsBooted: false,
      isMenuActive: false,
      lastItem: 20,
      lazyValue: this.value !== void 0 ? this.value : this.multiple ? [] : void 0,
      selectedIndex: -1,
      selectedItems: [],
      keyboardLookupPrefix: "",
      keyboardLookupLastTime: 0
    };
  },
  computed: {
    allItems() {
      return this.filterDuplicates(this.cachedItems.concat(this.items));
    },
    classes() {
      return __spreadProps(__spreadValues({}, VTextField_default.options.computed.classes.call(this)), {
        "v-select": true,
        "v-select--chips": this.hasChips,
        "v-select--chips--small": this.smallChips,
        "v-select--is-menu-active": this.isMenuActive,
        "v-select--is-multi": this.multiple
      });
    },
    computedItems() {
      return this.allItems;
    },
    computedOwns() {
      return `list-${this._uid}`;
    },
    computedCounterValue() {
      const value = this.multiple ? this.selectedItems : (this.getText(this.selectedItems[0]) || "").toString();
      if (typeof this.counterValue === "function") {
        return this.counterValue(value);
      }
      return value.length;
    },
    directives() {
      return this.isFocused ? [{
        name: "click-outside",
        value: {
          handler: this.blur,
          closeConditional: this.closeConditional,
          include: () => this.getOpenDependentElements()
        }
      }] : void 0;
    },
    dynamicHeight() {
      return "auto";
    },
    hasChips() {
      return this.chips || this.smallChips;
    },
    hasSlot() {
      return Boolean(this.hasChips || this.$scopedSlots.selection);
    },
    isDirty() {
      return this.selectedItems.length > 0;
    },
    listData() {
      const scopeId = this.$vnode && this.$vnode.context.$options._scopeId;
      const attrs2 = scopeId ? {
        [scopeId]: true
      } : {};
      return {
        attrs: __spreadProps(__spreadValues({}, attrs2), {
          id: this.computedOwns
        }),
        props: {
          action: this.multiple,
          color: this.itemColor,
          dense: this.dense,
          hideSelected: this.hideSelected,
          items: this.virtualizedItems,
          itemDisabled: this.itemDisabled,
          itemText: this.itemText,
          itemValue: this.itemValue,
          noDataText: this.$vuetify.lang.t(this.noDataText),
          selectedItems: this.selectedItems
        },
        on: {
          select: this.selectItem
        },
        scopedSlots: {
          item: this.$scopedSlots.item
        }
      };
    },
    staticList() {
      if (this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"]) {
        consoleError("assert: staticList should not be called if slots are used");
      }
      return this.$createElement(VSelectList_default, this.listData);
    },
    virtualizedItems() {
      return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem);
    },
    menuCanShow: () => true,
    $_menuProps() {
      let normalisedProps = typeof this.menuProps === "string" ? this.menuProps.split(",") : this.menuProps;
      if (Array.isArray(normalisedProps)) {
        normalisedProps = normalisedProps.reduce((acc, p) => {
          acc[p.trim()] = true;
          return acc;
        }, {});
      }
      return __spreadValues(__spreadProps(__spreadValues({}, defaultMenuProps), {
        eager: this.eager,
        value: this.menuCanShow && this.isMenuActive,
        nudgeBottom: normalisedProps.offsetY ? 1 : 0
      }), normalisedProps);
    }
  },
  watch: {
    internalValue(val) {
      this.initialValue = val;
      this.setSelectedItems();
      if (this.multiple) {
        this.$nextTick(() => {
          var _this$$refs$menu;
          (_this$$refs$menu = this.$refs.menu) == null ? void 0 : _this$$refs$menu.updateDimensions();
        });
      }
    },
    isMenuActive(val) {
      window.setTimeout(() => this.onMenuActiveChange(val));
    },
    items: {
      immediate: true,
      handler(val) {
        if (this.cacheItems) {
          this.$nextTick(() => {
            this.cachedItems = this.filterDuplicates(this.cachedItems.concat(val));
          });
        }
        this.setSelectedItems();
      }
    }
  },
  methods: {
    blur(e) {
      VTextField_default.options.methods.blur.call(this, e);
      this.isMenuActive = false;
      this.isFocused = false;
      this.selectedIndex = -1;
      this.setMenuIndex(-1);
    },
    activateMenu() {
      if (!this.isInteractive || this.isMenuActive)
        return;
      this.isMenuActive = true;
    },
    clearableCallback() {
      this.setValue(this.multiple ? [] : null);
      this.setMenuIndex(-1);
      this.$nextTick(() => this.$refs.input && this.$refs.input.focus());
      if (this.openOnClear)
        this.isMenuActive = true;
    },
    closeConditional(e) {
      if (!this.isMenuActive)
        return true;
      return !this._isDestroyed && (!this.getContent() || !this.getContent().contains(e.target)) && this.$el && !this.$el.contains(e.target) && e.target !== this.$el;
    },
    filterDuplicates(arr) {
      const uniqueValues = new Map();
      for (let index2 = 0; index2 < arr.length; ++index2) {
        const item = arr[index2];
        if (item == null) {
          continue;
        }
        if (item.header || item.divider) {
          uniqueValues.set(item, item);
          continue;
        }
        const val = this.getValue(item);
        !uniqueValues.has(val) && uniqueValues.set(val, item);
      }
      return Array.from(uniqueValues.values());
    },
    findExistingIndex(item) {
      const itemValue = this.getValue(item);
      return (this.internalValue || []).findIndex((i) => this.valueComparator(this.getValue(i), itemValue));
    },
    getContent() {
      return this.$refs.menu && this.$refs.menu.$refs.content;
    },
    genChipSelection(item, index2) {
      const isDisabled = this.isDisabled || this.getDisabled(item);
      const isInteractive = !isDisabled && this.isInteractive;
      return this.$createElement(VChip_default2, {
        staticClass: "v-chip--select",
        attrs: {
          tabindex: -1
        },
        props: {
          close: this.deletableChips && isInteractive,
          disabled: isDisabled,
          inputValue: index2 === this.selectedIndex,
          small: this.smallChips
        },
        on: {
          click: (e) => {
            if (!isInteractive)
              return;
            e.stopPropagation();
            this.selectedIndex = index2;
          },
          "click:close": () => this.onChipInput(item)
        },
        key: JSON.stringify(this.getValue(item))
      }, this.getText(item));
    },
    genCommaSelection(item, index2, last) {
      const color = index2 === this.selectedIndex && this.computedColor;
      const isDisabled = this.isDisabled || this.getDisabled(item);
      return this.$createElement("div", this.setTextColor(color, {
        staticClass: "v-select__selection v-select__selection--comma",
        class: {
          "v-select__selection--disabled": isDisabled
        },
        key: JSON.stringify(this.getValue(item))
      }), `${this.getText(item)}${last ? "" : ", "}`);
    },
    genDefaultSlot() {
      const selections = this.genSelections();
      const input = this.genInput();
      if (Array.isArray(selections)) {
        selections.push(input);
      } else {
        selections.children = selections.children || [];
        selections.children.push(input);
      }
      return [this.genFieldset(), this.$createElement("div", {
        staticClass: "v-select__slot",
        directives: this.directives
      }, [this.genLabel(), this.prefix ? this.genAffix("prefix") : null, selections, this.suffix ? this.genAffix("suffix") : null, this.genClearIcon(), this.genIconSlot(), this.genHiddenInput()]), this.genMenu(), this.genProgress()];
    },
    genIcon(type2, cb, extraData) {
      const icon = VInput_default2.options.methods.genIcon.call(this, type2, cb, extraData);
      if (type2 === "append") {
        icon.children[0].data = mergeData2(icon.children[0].data, {
          attrs: {
            tabindex: icon.children[0].componentOptions.listeners && "-1",
            "aria-hidden": "true",
            "aria-label": void 0
          }
        });
      }
      return icon;
    },
    genInput() {
      const input = VTextField_default.options.methods.genInput.call(this);
      delete input.data.attrs.name;
      input.data = mergeData2(input.data, {
        domProps: {
          value: null
        },
        attrs: {
          readonly: true,
          type: "text",
          "aria-readonly": String(this.isReadonly),
          "aria-activedescendant": getObjectValueByPath(this.$refs.menu, "activeTile.id"),
          autocomplete: getObjectValueByPath(input.data, "attrs.autocomplete", "off"),
          placeholder: !this.isDirty && (this.persistentPlaceholder || this.isFocused || !this.hasLabel) ? this.placeholder : void 0
        },
        on: {
          keypress: this.onKeyPress
        }
      });
      return input;
    },
    genHiddenInput() {
      return this.$createElement("input", {
        domProps: {
          value: this.lazyValue
        },
        attrs: {
          type: "hidden",
          name: this.attrs$.name
        }
      });
    },
    genInputSlot() {
      const render4 = VTextField_default.options.methods.genInputSlot.call(this);
      render4.data.attrs = __spreadProps(__spreadValues({}, render4.data.attrs), {
        role: "button",
        "aria-haspopup": "listbox",
        "aria-expanded": String(this.isMenuActive),
        "aria-owns": this.computedOwns
      });
      return render4;
    },
    genList() {
      if (this.$slots["no-data"] || this.$slots["prepend-item"] || this.$slots["append-item"]) {
        return this.genListWithSlot();
      } else {
        return this.staticList;
      }
    },
    genListWithSlot() {
      const slots = ["prepend-item", "no-data", "append-item"].filter((slotName) => this.$slots[slotName]).map((slotName) => this.$createElement("template", {
        slot: slotName
      }, this.$slots[slotName]));
      return this.$createElement(VSelectList_default, __spreadValues({}, this.listData), slots);
    },
    genMenu() {
      const props2 = this.$_menuProps;
      props2.activator = this.$refs["input-slot"];
      if (this.attach === "" || this.attach === true || this.attach === "attach") {
        props2.attach = this.$el;
      } else {
        props2.attach = this.attach;
      }
      return this.$createElement(VMenu_default2, {
        attrs: {
          role: void 0
        },
        props: props2,
        on: {
          input: (val) => {
            this.isMenuActive = val;
            this.isFocused = val;
          },
          scroll: this.onScroll
        },
        ref: "menu"
      }, [this.genList()]);
    },
    genSelections() {
      let length = this.selectedItems.length;
      const children = new Array(length);
      let genSelection;
      if (this.$scopedSlots.selection) {
        genSelection = this.genSlotSelection;
      } else if (this.hasChips) {
        genSelection = this.genChipSelection;
      } else {
        genSelection = this.genCommaSelection;
      }
      while (length--) {
        children[length] = genSelection(this.selectedItems[length], length, length === children.length - 1);
      }
      return this.$createElement("div", {
        staticClass: "v-select__selections"
      }, children);
    },
    genSlotSelection(item, index2) {
      return this.$scopedSlots.selection({
        attrs: {
          class: "v-chip--select"
        },
        parent: this,
        item,
        index: index2,
        select: (e) => {
          e.stopPropagation();
          this.selectedIndex = index2;
        },
        selected: index2 === this.selectedIndex,
        disabled: !this.isInteractive
      });
    },
    getMenuIndex() {
      return this.$refs.menu ? this.$refs.menu.listIndex : -1;
    },
    getDisabled(item) {
      return getPropertyFromItem(item, this.itemDisabled, false);
    },
    getText(item) {
      return getPropertyFromItem(item, this.itemText, item);
    },
    getValue(item) {
      return getPropertyFromItem(item, this.itemValue, this.getText(item));
    },
    onBlur(e) {
      e && this.$emit("blur", e);
    },
    onChipInput(item) {
      if (this.multiple)
        this.selectItem(item);
      else
        this.setValue(null);
      if (this.selectedItems.length === 0) {
        this.isMenuActive = true;
      } else {
        this.isMenuActive = false;
      }
      this.selectedIndex = -1;
    },
    onClick(e) {
      if (!this.isInteractive)
        return;
      if (!this.isAppendInner(e.target)) {
        this.isMenuActive = true;
      }
      if (!this.isFocused) {
        this.isFocused = true;
        this.$emit("focus");
      }
      this.$emit("click", e);
    },
    onEscDown(e) {
      e.preventDefault();
      if (this.isMenuActive) {
        e.stopPropagation();
        this.isMenuActive = false;
      }
    },
    onKeyPress(e) {
      if (this.multiple || !this.isInteractive || this.disableLookup)
        return;
      const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
      const now = performance.now();
      if (now - this.keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        this.keyboardLookupPrefix = "";
      }
      this.keyboardLookupPrefix += e.key.toLowerCase();
      this.keyboardLookupLastTime = now;
      const index2 = this.allItems.findIndex((item2) => {
        const text = (this.getText(item2) || "").toString();
        return text.toLowerCase().startsWith(this.keyboardLookupPrefix);
      });
      const item = this.allItems[index2];
      if (index2 !== -1) {
        this.lastItem = Math.max(this.lastItem, index2 + 5);
        this.setValue(this.returnObject ? item : this.getValue(item));
        this.$nextTick(() => this.$refs.menu.getTiles());
        setTimeout(() => this.setMenuIndex(index2));
      }
    },
    onKeyDown(e) {
      if (this.isReadonly && e.keyCode !== keyCodes.tab)
        return;
      const keyCode = e.keyCode;
      const menu = this.$refs.menu;
      this.$emit("keydown", e);
      if (!menu)
        return;
      if (this.isMenuActive && [keyCodes.up, keyCodes.down, keyCodes.home, keyCodes.end, keyCodes.enter].includes(keyCode)) {
        this.$nextTick(() => {
          menu.changeListIndex(e);
          this.$emit("update:list-index", menu.listIndex);
        });
      }
      if ([keyCodes.enter, keyCodes.space].includes(keyCode))
        this.activateMenu();
      if (!this.isMenuActive && [keyCodes.up, keyCodes.down, keyCodes.home, keyCodes.end].includes(keyCode))
        return this.onUpDown(e);
      if (keyCode === keyCodes.esc)
        return this.onEscDown(e);
      if (keyCode === keyCodes.tab)
        return this.onTabDown(e);
      if (keyCode === keyCodes.space)
        return this.onSpaceDown(e);
    },
    onMenuActiveChange(val) {
      if (this.multiple && !val || this.getMenuIndex() > -1)
        return;
      const menu = this.$refs.menu;
      if (!menu || !this.isDirty)
        return;
      this.$refs.menu.getTiles();
      for (let i = 0; i < menu.tiles.length; i++) {
        if (menu.tiles[i].getAttribute("aria-selected") === "true") {
          this.setMenuIndex(i);
          break;
        }
      }
    },
    onMouseUp(e) {
      if (this.hasMouseDown && e.which !== 3 && this.isInteractive) {
        if (this.isAppendInner(e.target)) {
          this.$nextTick(() => this.isMenuActive = !this.isMenuActive);
        }
      }
      VTextField_default.options.methods.onMouseUp.call(this, e);
    },
    onScroll() {
      if (!this.isMenuActive) {
        requestAnimationFrame(() => this.getContent().scrollTop = 0);
      } else {
        if (this.lastItem > this.computedItems.length)
          return;
        const showMoreItems = this.getContent().scrollHeight - (this.getContent().scrollTop + this.getContent().clientHeight) < 200;
        if (showMoreItems) {
          this.lastItem += 20;
        }
      }
    },
    onSpaceDown(e) {
      e.preventDefault();
    },
    onTabDown(e) {
      const menu = this.$refs.menu;
      if (!menu)
        return;
      const activeTile = menu.activeTile;
      if (!this.multiple && activeTile && this.isMenuActive) {
        e.preventDefault();
        e.stopPropagation();
        activeTile.click();
      } else {
        this.blur(e);
      }
    },
    onUpDown(e) {
      const menu = this.$refs.menu;
      if (!menu)
        return;
      e.preventDefault();
      if (this.multiple)
        return this.activateMenu();
      const keyCode = e.keyCode;
      menu.isBooted = true;
      window.requestAnimationFrame(() => {
        menu.getTiles();
        if (!menu.hasClickableTiles)
          return this.activateMenu();
        switch (keyCode) {
          case keyCodes.up:
            menu.prevTile();
            break;
          case keyCodes.down:
            menu.nextTile();
            break;
          case keyCodes.home:
            menu.firstTile();
            break;
          case keyCodes.end:
            menu.lastTile();
            break;
        }
        this.selectItem(this.allItems[this.getMenuIndex()]);
      });
    },
    selectItem(item) {
      if (!this.multiple) {
        this.setValue(this.returnObject ? item : this.getValue(item));
        this.isMenuActive = false;
      } else {
        const internalValue = (this.internalValue || []).slice();
        const i = this.findExistingIndex(item);
        i !== -1 ? internalValue.splice(i, 1) : internalValue.push(item);
        this.setValue(internalValue.map((i2) => {
          return this.returnObject ? i2 : this.getValue(i2);
        }));
        if (this.hideSelected) {
          this.setMenuIndex(-1);
        } else {
          const index2 = this.allItems.indexOf(item);
          if (~index2) {
            this.$nextTick(() => this.$refs.menu.getTiles());
            setTimeout(() => this.setMenuIndex(index2));
          }
        }
      }
    },
    setMenuIndex(index2) {
      this.$refs.menu && (this.$refs.menu.listIndex = index2);
    },
    setSelectedItems() {
      const selectedItems = [];
      const values = !this.multiple || !Array.isArray(this.internalValue) ? [this.internalValue] : this.internalValue;
      for (const value of values) {
        const index2 = this.allItems.findIndex((v) => this.valueComparator(this.getValue(v), this.getValue(value)));
        if (index2 > -1) {
          selectedItems.push(this.allItems[index2]);
        }
      }
      this.selectedItems = selectedItems;
    },
    setValue(value) {
      if (!this.valueComparator(value, this.internalValue)) {
        this.internalValue = value;
        this.$emit("change", value);
      }
    },
    isAppendInner(target2) {
      const appendInner = this.$refs["append-inner"];
      return appendInner && (appendInner === target2 || appendInner.contains(target2));
    }
  }
});

// node_modules/vuetify/lib/components/VAutocomplete/VAutocomplete.js
var defaultMenuProps2 = __spreadProps(__spreadValues({}, defaultMenuProps), {
  offsetY: true,
  offsetOverflow: true,
  transition: false
});
var VAutocomplete_default = VSelect_default.extend({
  name: "v-autocomplete",
  props: {
    allowOverflow: {
      type: Boolean,
      default: true
    },
    autoSelectFirst: {
      type: Boolean,
      default: false
    },
    filter: {
      type: Function,
      default: (item, queryText, itemText) => {
        return itemText.toLocaleLowerCase().indexOf(queryText.toLocaleLowerCase()) > -1;
      }
    },
    hideNoData: Boolean,
    menuProps: {
      type: VSelect_default.options.props.menuProps.type,
      default: () => defaultMenuProps2
    },
    noFilter: Boolean,
    searchInput: {
      type: String
    }
  },
  data() {
    return {
      lazySearch: this.searchInput
    };
  },
  computed: {
    classes() {
      return __spreadProps(__spreadValues({}, VSelect_default.options.computed.classes.call(this)), {
        "v-autocomplete": true,
        "v-autocomplete--is-selecting-index": this.selectedIndex > -1
      });
    },
    computedItems() {
      return this.filteredItems;
    },
    selectedValues() {
      return this.selectedItems.map((item) => this.getValue(item));
    },
    hasDisplayedItems() {
      return this.hideSelected ? this.filteredItems.some((item) => !this.hasItem(item)) : this.filteredItems.length > 0;
    },
    currentRange() {
      if (this.selectedItem == null)
        return 0;
      return String(this.getText(this.selectedItem)).length;
    },
    filteredItems() {
      if (!this.isSearching || this.noFilter || this.internalSearch == null)
        return this.allItems;
      return this.allItems.filter((item) => {
        const value = getPropertyFromItem(item, this.itemText);
        const text = value != null ? String(value) : "";
        return this.filter(item, String(this.internalSearch), text);
      });
    },
    internalSearch: {
      get() {
        return this.lazySearch;
      },
      set(val) {
        if (this.lazySearch !== val) {
          this.lazySearch = val;
          this.$emit("update:search-input", val);
        }
      }
    },
    isAnyValueAllowed() {
      return false;
    },
    isDirty() {
      return this.searchIsDirty || this.selectedItems.length > 0;
    },
    isSearching() {
      return this.multiple && this.searchIsDirty || this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);
    },
    menuCanShow() {
      if (!this.isFocused)
        return false;
      return this.hasDisplayedItems || !this.hideNoData;
    },
    $_menuProps() {
      const props2 = VSelect_default.options.computed.$_menuProps.call(this);
      props2.contentClass = `v-autocomplete__content ${props2.contentClass || ""}`.trim();
      return __spreadValues(__spreadValues({}, defaultMenuProps2), props2);
    },
    searchIsDirty() {
      return this.internalSearch != null && this.internalSearch !== "";
    },
    selectedItem() {
      if (this.multiple)
        return null;
      return this.selectedItems.find((i) => {
        return this.valueComparator(this.getValue(i), this.getValue(this.internalValue));
      });
    },
    listData() {
      const data = VSelect_default.options.computed.listData.call(this);
      data.props = __spreadProps(__spreadValues({}, data.props), {
        items: this.virtualizedItems,
        noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,
        searchInput: this.internalSearch
      });
      return data;
    }
  },
  watch: {
    filteredItems: "onFilteredItemsChanged",
    internalValue: "setSearch",
    isFocused(val) {
      if (val) {
        document.addEventListener("copy", this.onCopy);
        this.$refs.input && this.$refs.input.select();
      } else {
        document.removeEventListener("copy", this.onCopy);
        this.blur();
        this.updateSelf();
      }
    },
    isMenuActive(val) {
      if (val || !this.hasSlot)
        return;
      this.lazySearch = null;
    },
    items(val, oldVal) {
      if (!(oldVal && oldVal.length) && this.hideNoData && this.isFocused && !this.isMenuActive && val.length)
        this.activateMenu();
    },
    searchInput(val) {
      this.lazySearch = val;
    },
    internalSearch: "onInternalSearchChanged",
    itemText: "updateSelf"
  },
  created() {
    this.setSearch();
  },
  destroyed() {
    document.removeEventListener("copy", this.onCopy);
  },
  methods: {
    onFilteredItemsChanged(val, oldVal) {
      if (val === oldVal)
        return;
      if (!this.autoSelectFirst) {
        const preSelectedItem = oldVal[this.$refs.menu.listIndex];
        if (preSelectedItem) {
          this.setMenuIndex(val.findIndex((i) => i === preSelectedItem));
        } else {
          this.setMenuIndex(-1);
        }
        this.$emit("update:list-index", this.$refs.menu.listIndex);
      }
      this.$nextTick(() => {
        if (!this.internalSearch || val.length !== 1 && !this.autoSelectFirst)
          return;
        this.$refs.menu.getTiles();
        if (this.autoSelectFirst && val.length) {
          this.setMenuIndex(0);
          this.$emit("update:list-index", this.$refs.menu.listIndex);
        }
      });
    },
    onInternalSearchChanged() {
      this.updateMenuDimensions();
    },
    updateMenuDimensions() {
      this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions();
    },
    changeSelectedIndex(keyCode) {
      if (this.searchIsDirty)
        return;
      if (this.multiple && keyCode === keyCodes.left) {
        if (this.selectedIndex === -1) {
          this.selectedIndex = this.selectedItems.length - 1;
        } else {
          this.selectedIndex--;
        }
      } else if (this.multiple && keyCode === keyCodes.right) {
        if (this.selectedIndex >= this.selectedItems.length - 1) {
          this.selectedIndex = -1;
        } else {
          this.selectedIndex++;
        }
      } else if (keyCode === keyCodes.backspace || keyCode === keyCodes.delete) {
        this.deleteCurrentItem();
      }
    },
    deleteCurrentItem() {
      const curIndex = this.selectedIndex;
      const curItem = this.selectedItems[curIndex];
      if (!this.isInteractive || this.getDisabled(curItem))
        return;
      const lastIndex = this.selectedItems.length - 1;
      if (this.selectedIndex === -1 && lastIndex !== 0) {
        this.selectedIndex = lastIndex;
        return;
      }
      const length = this.selectedItems.length;
      const nextIndex = curIndex !== length - 1 ? curIndex : curIndex - 1;
      const nextItem = this.selectedItems[nextIndex];
      if (!nextItem) {
        this.setValue(this.multiple ? [] : null);
      } else {
        this.selectItem(curItem);
      }
      this.selectedIndex = nextIndex;
    },
    clearableCallback() {
      this.internalSearch = null;
      VSelect_default.options.methods.clearableCallback.call(this);
    },
    genInput() {
      const input = VTextField_default.options.methods.genInput.call(this);
      input.data = mergeData2(input.data, {
        attrs: {
          "aria-activedescendant": getObjectValueByPath(this.$refs.menu, "activeTile.id"),
          autocomplete: getObjectValueByPath(input.data, "attrs.autocomplete", "off")
        },
        domProps: {
          value: this.internalSearch
        }
      });
      return input;
    },
    genInputSlot() {
      const slot = VSelect_default.options.methods.genInputSlot.call(this);
      slot.data.attrs.role = "combobox";
      return slot;
    },
    genSelections() {
      return this.hasSlot || this.multiple ? VSelect_default.options.methods.genSelections.call(this) : [];
    },
    onClick(e) {
      if (!this.isInteractive)
        return;
      this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus();
      if (!this.isAppendInner(e.target))
        this.activateMenu();
    },
    onInput(e) {
      if (this.selectedIndex > -1 || !e.target)
        return;
      const target2 = e.target;
      const value = target2.value;
      if (target2.value)
        this.activateMenu();
      if (!this.multiple && value === "")
        this.deleteCurrentItem();
      this.internalSearch = value;
      this.badInput = target2.validity && target2.validity.badInput;
    },
    onKeyDown(e) {
      const keyCode = e.keyCode;
      if (e.ctrlKey || ![keyCodes.home, keyCodes.end].includes(keyCode)) {
        VSelect_default.options.methods.onKeyDown.call(this, e);
      }
      this.changeSelectedIndex(keyCode);
    },
    onSpaceDown(e) {
    },
    onTabDown(e) {
      VSelect_default.options.methods.onTabDown.call(this, e);
      this.updateSelf();
    },
    onUpDown(e) {
      e.preventDefault();
      this.activateMenu();
    },
    selectItem(item) {
      VSelect_default.options.methods.selectItem.call(this, item);
      this.setSearch();
    },
    setSelectedItems() {
      VSelect_default.options.methods.setSelectedItems.call(this);
      if (!this.isFocused)
        this.setSearch();
    },
    setSearch() {
      this.$nextTick(() => {
        if (!this.multiple || !this.internalSearch || !this.isMenuActive) {
          this.internalSearch = !this.selectedItems.length || this.multiple || this.hasSlot ? null : this.getText(this.selectedItem);
        }
      });
    },
    updateSelf() {
      if (!this.searchIsDirty && !this.internalValue)
        return;
      if (!this.multiple && !this.valueComparator(this.internalSearch, this.getValue(this.internalValue))) {
        this.setSearch();
      }
    },
    hasItem(item) {
      return this.selectedValues.indexOf(this.getValue(item)) > -1;
    },
    onCopy(event) {
      var _event$clipboardData, _event$clipboardData2;
      if (this.selectedIndex === -1)
        return;
      const currentItem = this.selectedItems[this.selectedIndex];
      const currentItemText = this.getText(currentItem);
      (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.setData("text/plain", currentItemText);
      (_event$clipboardData2 = event.clipboardData) == null ? void 0 : _event$clipboardData2.setData("text/vnd.vuetify.autocomplete.item+plain", currentItemText);
      event.preventDefault();
    }
  }
});

// node_modules/vuetify/lib/mixins/mobile/index.js
var mobile_default = vue_runtime_esm_default.extend({
  name: "mobile",
  props: {
    mobileBreakpoint: {
      type: [Number, String],
      default() {
        return this.$vuetify ? this.$vuetify.breakpoint.mobileBreakpoint : void 0;
      },
      validator: (v) => !isNaN(Number(v)) || ["xs", "sm", "md", "lg", "xl"].includes(String(v))
    }
  },
  computed: {
    isMobile() {
      const {
        mobile,
        width,
        name,
        mobileBreakpoint
      } = this.$vuetify.breakpoint;
      if (mobileBreakpoint === this.mobileBreakpoint)
        return mobile;
      const mobileWidth = parseInt(this.mobileBreakpoint, 10);
      const isNumber = !isNaN(mobileWidth);
      return isNumber ? width < mobileWidth : name === this.mobileBreakpoint;
    }
  },
  created() {
    if (this.$attrs.hasOwnProperty("mobile-break-point")) {
      deprecate("mobile-break-point", "mobile-breakpoint", this);
    }
  }
});

// node_modules/vuetify/lib/mixins/rippleable/index.js
var rippleable_default = vue_runtime_esm_default.extend({
  name: "rippleable",
  directives: {
    ripple: ripple_default
  },
  props: {
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  },
  methods: {
    genRipple(data = {}) {
      if (!this.ripple)
        return null;
      data.staticClass = "v-input--selection-controls__ripple";
      data.directives = data.directives || [];
      data.directives.push({
        name: "ripple",
        value: {
          center: true
        }
      });
      return this.$createElement("div", data);
    }
  }
});

// node_modules/vuetify/lib/components/VSlider/VSlider.js
var VSlider_default = mixins(VInput_default2, loadable_default).extend({
  name: "v-slider",
  directives: {
    ClickOutside: click_outside_default
  },
  mixins: [loadable_default],
  props: {
    disabled: Boolean,
    inverseLabel: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    min: {
      type: [Number, String],
      default: 0
    },
    step: {
      type: [Number, String],
      default: 1
    },
    thumbColor: String,
    thumbLabel: {
      type: [Boolean, String],
      default: void 0,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    thumbSize: {
      type: [Number, String],
      default: 32
    },
    tickLabels: {
      type: Array,
      default: () => []
    },
    ticks: {
      type: [Boolean, String],
      default: false,
      validator: (v) => typeof v === "boolean" || v === "always"
    },
    tickSize: {
      type: [Number, String],
      default: 2
    },
    trackColor: String,
    trackFillColor: String,
    value: [Number, String],
    vertical: Boolean
  },
  data: () => ({
    app: null,
    oldValue: null,
    thumbPressed: false,
    mouseTimeout: -1,
    isFocused: false,
    isActive: false,
    noClick: false,
    startOffset: 0
  }),
  computed: {
    classes() {
      return __spreadProps(__spreadValues({}, VInput_default2.options.computed.classes.call(this)), {
        "v-input__slider": true,
        "v-input__slider--vertical": this.vertical,
        "v-input__slider--inverse-label": this.inverseLabel
      });
    },
    internalValue: {
      get() {
        return this.lazyValue;
      },
      set(val) {
        val = isNaN(val) ? this.minValue : val;
        const value = this.roundValue(Math.min(Math.max(val, this.minValue), this.maxValue));
        if (value === this.lazyValue)
          return;
        this.lazyValue = value;
        this.$emit("input", value);
      }
    },
    trackTransition() {
      return this.thumbPressed ? this.showTicks || this.stepNumeric ? "0.1s cubic-bezier(0.25, 0.8, 0.5, 1)" : "none" : "";
    },
    minValue() {
      return parseFloat(this.min);
    },
    maxValue() {
      return parseFloat(this.max);
    },
    stepNumeric() {
      return this.step > 0 ? parseFloat(this.step) : 0;
    },
    inputWidth() {
      const inputWidth = (this.roundValue(this.internalValue) - this.minValue) / (this.maxValue - this.minValue) * 100;
      return isNaN(inputWidth) ? 0 : inputWidth;
    },
    trackFillStyles() {
      const startDir = this.vertical ? "bottom" : "left";
      const endDir = this.vertical ? "top" : "right";
      const valueDir = this.vertical ? "height" : "width";
      const start = this.$vuetify.rtl ? "auto" : "0";
      const end = this.$vuetify.rtl ? "0" : "auto";
      const value = this.isDisabled ? `calc(${this.inputWidth}% - 10px)` : `${this.inputWidth}%`;
      return {
        transition: this.trackTransition,
        [startDir]: start,
        [endDir]: end,
        [valueDir]: value
      };
    },
    trackStyles() {
      const startDir = this.vertical ? this.$vuetify.rtl ? "bottom" : "top" : this.$vuetify.rtl ? "left" : "right";
      const endDir = this.vertical ? "height" : "width";
      const start = "0px";
      const end = this.isDisabled ? `calc(${100 - this.inputWidth}% - 10px)` : `calc(${100 - this.inputWidth}%)`;
      return {
        transition: this.trackTransition,
        [startDir]: start,
        [endDir]: end
      };
    },
    showTicks() {
      return this.tickLabels.length > 0 || !!(!this.isDisabled && this.stepNumeric && this.ticks);
    },
    numTicks() {
      return Math.ceil((this.maxValue - this.minValue) / this.stepNumeric);
    },
    showThumbLabel() {
      return !this.isDisabled && !!(this.thumbLabel || this.$scopedSlots["thumb-label"]);
    },
    computedTrackColor() {
      if (this.isDisabled)
        return void 0;
      if (this.trackColor)
        return this.trackColor;
      if (this.isDark)
        return this.validationState;
      return this.validationState || "primary lighten-3";
    },
    computedTrackFillColor() {
      if (this.isDisabled)
        return void 0;
      if (this.trackFillColor)
        return this.trackFillColor;
      return this.validationState || this.computedColor;
    },
    computedThumbColor() {
      if (this.thumbColor)
        return this.thumbColor;
      return this.validationState || this.computedColor;
    }
  },
  watch: {
    min(val) {
      const parsed = parseFloat(val);
      parsed > this.internalValue && this.$emit("input", parsed);
    },
    max(val) {
      const parsed = parseFloat(val);
      parsed < this.internalValue && this.$emit("input", parsed);
    },
    value: {
      handler(v) {
        this.internalValue = v;
      }
    }
  },
  beforeMount() {
    this.internalValue = this.value;
  },
  mounted() {
    this.app = document.querySelector("[data-app]") || consoleWarn("Missing v-app or a non-body wrapping element with the [data-app] attribute", this);
  },
  methods: {
    genDefaultSlot() {
      const children = [this.genLabel()];
      const slider = this.genSlider();
      this.inverseLabel ? children.unshift(slider) : children.push(slider);
      children.push(this.genProgress());
      return children;
    },
    genSlider() {
      return this.$createElement("div", {
        class: __spreadValues({
          "v-slider": true,
          "v-slider--horizontal": !this.vertical,
          "v-slider--vertical": this.vertical,
          "v-slider--focused": this.isFocused,
          "v-slider--active": this.isActive,
          "v-slider--disabled": this.isDisabled,
          "v-slider--readonly": this.isReadonly
        }, this.themeClasses),
        directives: [{
          name: "click-outside",
          value: this.onBlur
        }],
        on: {
          click: this.onSliderClick,
          mousedown: this.onSliderMouseDown,
          touchstart: this.onSliderMouseDown
        }
      }, this.genChildren());
    },
    genChildren() {
      return [this.genInput(), this.genTrackContainer(), this.genSteps(), this.genThumbContainer(this.internalValue, this.inputWidth, this.isActive, this.isFocused, this.onFocus, this.onBlur)];
    },
    genInput() {
      return this.$createElement("input", {
        attrs: __spreadValues({
          value: this.internalValue,
          id: this.computedId,
          disabled: true,
          readonly: true,
          tabindex: -1
        }, this.$attrs)
      });
    },
    genTrackContainer() {
      const children = [this.$createElement("div", this.setBackgroundColor(this.computedTrackColor, {
        staticClass: "v-slider__track-background",
        style: this.trackStyles
      })), this.$createElement("div", this.setBackgroundColor(this.computedTrackFillColor, {
        staticClass: "v-slider__track-fill",
        style: this.trackFillStyles
      }))];
      return this.$createElement("div", {
        staticClass: "v-slider__track-container",
        ref: "track"
      }, children);
    },
    genSteps() {
      if (!this.step || !this.showTicks)
        return null;
      const tickSize = parseFloat(this.tickSize);
      const range = createRange(this.numTicks + 1);
      const direction = this.vertical ? "bottom" : this.$vuetify.rtl ? "right" : "left";
      const offsetDirection = this.vertical ? this.$vuetify.rtl ? "left" : "right" : "top";
      if (this.vertical)
        range.reverse();
      const ticks = range.map((index2) => {
        const children = [];
        if (this.tickLabels[index2]) {
          children.push(this.$createElement("div", {
            staticClass: "v-slider__tick-label"
          }, this.tickLabels[index2]));
        }
        const width = index2 * (100 / this.numTicks);
        const filled = this.$vuetify.rtl ? 100 - this.inputWidth < width : width < this.inputWidth;
        return this.$createElement("span", {
          key: index2,
          staticClass: "v-slider__tick",
          class: {
            "v-slider__tick--filled": filled
          },
          style: {
            width: `${tickSize}px`,
            height: `${tickSize}px`,
            [direction]: `calc(${width}% - ${tickSize / 2}px)`,
            [offsetDirection]: `calc(50% - ${tickSize / 2}px)`
          }
        }, children);
      });
      return this.$createElement("div", {
        staticClass: "v-slider__ticks-container",
        class: {
          "v-slider__ticks-container--always-show": this.ticks === "always" || this.tickLabels.length > 0
        }
      }, ticks);
    },
    genThumbContainer(value, valueWidth, isActive, isFocused, onFocus, onBlur, ref2 = "thumb") {
      const children = [this.genThumb()];
      const thumbLabelContent = this.genThumbLabelContent(value);
      this.showThumbLabel && children.push(this.genThumbLabel(thumbLabelContent));
      return this.$createElement("div", this.setTextColor(this.computedThumbColor, {
        ref: ref2,
        key: ref2,
        staticClass: "v-slider__thumb-container",
        class: {
          "v-slider__thumb-container--active": isActive,
          "v-slider__thumb-container--focused": isFocused,
          "v-slider__thumb-container--show-label": this.showThumbLabel
        },
        style: this.getThumbContainerStyles(valueWidth),
        attrs: {
          role: "slider",
          tabindex: this.isDisabled ? -1 : this.$attrs.tabindex ? this.$attrs.tabindex : 0,
          "aria-label": this.$attrs["aria-label"] || this.label,
          "aria-valuemin": this.min,
          "aria-valuemax": this.max,
          "aria-valuenow": this.internalValue,
          "aria-readonly": String(this.isReadonly),
          "aria-orientation": this.vertical ? "vertical" : "horizontal"
        },
        on: {
          focus: onFocus,
          blur: onBlur,
          keydown: this.onKeyDown
        }
      }), children);
    },
    genThumbLabelContent(value) {
      return this.$scopedSlots["thumb-label"] ? this.$scopedSlots["thumb-label"]({
        value
      }) : [this.$createElement("span", [String(value)])];
    },
    genThumbLabel(content) {
      const size = convertToUnit(this.thumbSize);
      const transform2 = this.vertical ? `translateY(20%) translateY(${Number(this.thumbSize) / 3 - 1}px) translateX(55%) rotate(135deg)` : `translateY(-20%) translateY(-12px) translateX(-50%) rotate(45deg)`;
      return this.$createElement(VScaleTransition, {
        props: {
          origin: "bottom center"
        }
      }, [this.$createElement("div", {
        staticClass: "v-slider__thumb-label-container",
        directives: [{
          name: "show",
          value: this.isFocused || this.isActive || this.thumbLabel === "always"
        }]
      }, [this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
        staticClass: "v-slider__thumb-label",
        style: {
          height: size,
          width: size,
          transform: transform2
        }
      }), [this.$createElement("div", content)])])]);
    },
    genThumb() {
      return this.$createElement("div", this.setBackgroundColor(this.computedThumbColor, {
        staticClass: "v-slider__thumb"
      }));
    },
    getThumbContainerStyles(width) {
      const direction = this.vertical ? "top" : "left";
      let value = this.$vuetify.rtl ? 100 - width : width;
      value = this.vertical ? 100 - value : value;
      return {
        transition: this.trackTransition,
        [direction]: `${value}%`
      };
    },
    onSliderMouseDown(e) {
      var _e$target;
      e.preventDefault();
      this.oldValue = this.internalValue;
      this.isActive = true;
      if ((_e$target = e.target) != null && _e$target.matches(".v-slider__thumb-container, .v-slider__thumb-container *")) {
        this.thumbPressed = true;
        const domRect = e.target.getBoundingClientRect();
        const touch = "touches" in e ? e.touches[0] : e;
        this.startOffset = this.vertical ? touch.clientY - (domRect.top + domRect.height / 2) : touch.clientX - (domRect.left + domRect.width / 2);
      } else {
        this.startOffset = 0;
        window.clearTimeout(this.mouseTimeout);
        this.mouseTimeout = window.setTimeout(() => {
          this.thumbPressed = true;
        }, 300);
      }
      const mouseUpOptions = passiveSupported ? {
        passive: true,
        capture: true
      } : true;
      const mouseMoveOptions = passiveSupported ? {
        passive: true
      } : false;
      const isTouchEvent2 = "touches" in e;
      this.onMouseMove(e);
      this.app.addEventListener(isTouchEvent2 ? "touchmove" : "mousemove", this.onMouseMove, mouseMoveOptions);
      addOnceEventListener(this.app, isTouchEvent2 ? "touchend" : "mouseup", this.onSliderMouseUp, mouseUpOptions);
      this.$emit("start", this.internalValue);
    },
    onSliderMouseUp(e) {
      e.stopPropagation();
      window.clearTimeout(this.mouseTimeout);
      this.thumbPressed = false;
      const mouseMoveOptions = passiveSupported ? {
        passive: true
      } : false;
      this.app.removeEventListener("touchmove", this.onMouseMove, mouseMoveOptions);
      this.app.removeEventListener("mousemove", this.onMouseMove, mouseMoveOptions);
      this.$emit("mouseup", e);
      this.$emit("end", this.internalValue);
      if (!deepEqual(this.oldValue, this.internalValue)) {
        this.$emit("change", this.internalValue);
        this.noClick = true;
      }
      this.isActive = false;
    },
    onMouseMove(e) {
      if (e.type === "mousemove") {
        this.thumbPressed = true;
      }
      this.internalValue = this.parseMouseMove(e);
    },
    onKeyDown(e) {
      if (!this.isInteractive)
        return;
      const value = this.parseKeyDown(e, this.internalValue);
      if (value == null || value < this.minValue || value > this.maxValue)
        return;
      this.internalValue = value;
      this.$emit("change", value);
    },
    onSliderClick(e) {
      if (this.noClick) {
        this.noClick = false;
        return;
      }
      const thumb = this.$refs.thumb;
      thumb.focus();
      this.onMouseMove(e);
      this.$emit("change", this.internalValue);
    },
    onBlur(e) {
      this.isFocused = false;
      this.$emit("blur", e);
    },
    onFocus(e) {
      this.isFocused = true;
      this.$emit("focus", e);
    },
    parseMouseMove(e) {
      const start = this.vertical ? "top" : "left";
      const length = this.vertical ? "height" : "width";
      const click = this.vertical ? "clientY" : "clientX";
      const {
        [start]: trackStart,
        [length]: trackLength
      } = this.$refs.track.getBoundingClientRect();
      const clickOffset = "touches" in e ? e.touches[0][click] : e[click];
      let clickPos = Math.min(Math.max((clickOffset - trackStart - this.startOffset) / trackLength, 0), 1) || 0;
      if (this.vertical)
        clickPos = 1 - clickPos;
      if (this.$vuetify.rtl)
        clickPos = 1 - clickPos;
      return parseFloat(this.min) + clickPos * (this.maxValue - this.minValue);
    },
    parseKeyDown(e, value) {
      if (!this.isInteractive)
        return;
      const {
        pageup,
        pagedown,
        end,
        home,
        left,
        right,
        down,
        up
      } = keyCodes;
      if (![pageup, pagedown, end, home, left, right, down, up].includes(e.keyCode))
        return;
      e.preventDefault();
      const step = this.stepNumeric || 1;
      const steps = (this.maxValue - this.minValue) / step;
      if ([left, right, down, up].includes(e.keyCode)) {
        const increase = this.$vuetify.rtl ? [left, up] : [right, up];
        const direction = increase.includes(e.keyCode) ? 1 : -1;
        const multiplier = e.shiftKey ? 3 : e.ctrlKey ? 2 : 1;
        value = value + direction * step * multiplier;
      } else if (e.keyCode === home) {
        value = this.minValue;
      } else if (e.keyCode === end) {
        value = this.maxValue;
      } else {
        const direction = e.keyCode === pagedown ? 1 : -1;
        value = value - direction * step * (steps > 100 ? steps / 10 : 10);
      }
      return value;
    },
    roundValue(value) {
      if (!this.stepNumeric)
        return value;
      const trimmedStep = this.step.toString().trim();
      const decimals = trimmedStep.indexOf(".") > -1 ? trimmedStep.length - trimmedStep.indexOf(".") - 1 : 0;
      const offset = this.minValue % this.stepNumeric;
      const newValue = Math.round((value - offset) / this.stepNumeric) * this.stepNumeric + offset;
      return parseFloat(Math.min(newValue, this.maxValue).toFixed(decimals));
    }
  }
});

// node_modules/vuetify/lib/components/VCombobox/VCombobox.js
var VCombobox_default = VAutocomplete_default.extend({
  name: "v-combobox",
  props: {
    delimiters: {
      type: Array,
      default: () => []
    },
    returnObject: {
      type: Boolean,
      default: true
    }
  },
  data: () => ({
    editingIndex: -1
  }),
  computed: {
    computedCounterValue() {
      return this.multiple ? this.selectedItems.length : (this.internalSearch || "").toString().length;
    },
    hasSlot() {
      return VSelect_default.options.computed.hasSlot.call(this) || this.multiple;
    },
    isAnyValueAllowed() {
      return true;
    },
    menuCanShow() {
      if (!this.isFocused)
        return false;
      return this.hasDisplayedItems || !!this.$slots["no-data"] && !this.hideNoData;
    },
    searchIsDirty() {
      return this.internalSearch != null;
    }
  },
  methods: {
    onInternalSearchChanged(val) {
      if (val && this.multiple && this.delimiters.length) {
        const delimiter = this.delimiters.find((d) => val.endsWith(d));
        if (delimiter != null) {
          this.internalSearch = val.slice(0, val.length - delimiter.length);
          this.updateTags();
        }
      }
      this.updateMenuDimensions();
    },
    genInput() {
      const input = VAutocomplete_default.options.methods.genInput.call(this);
      delete input.data.attrs.name;
      input.data.on.paste = this.onPaste;
      return input;
    },
    genChipSelection(item, index2) {
      const chip = VSelect_default.options.methods.genChipSelection.call(this, item, index2);
      if (this.multiple) {
        chip.componentOptions.listeners = __spreadProps(__spreadValues({}, chip.componentOptions.listeners), {
          dblclick: () => {
            this.editingIndex = index2;
            this.internalSearch = this.getText(item);
            this.selectedIndex = -1;
          }
        });
      }
      return chip;
    },
    onChipInput(item) {
      VSelect_default.options.methods.onChipInput.call(this, item);
      this.editingIndex = -1;
    },
    onEnterDown(e) {
      e.preventDefault();
      if (this.getMenuIndex() > -1)
        return;
      this.$nextTick(this.updateSelf);
    },
    onKeyDown(e) {
      const keyCode = e.keyCode;
      if (e.ctrlKey || ![keyCodes.home, keyCodes.end].includes(keyCode)) {
        VSelect_default.options.methods.onKeyDown.call(this, e);
      }
      if (this.multiple && keyCode === keyCodes.left && this.$refs.input.selectionStart === 0) {
        this.updateSelf();
      } else if (keyCode === keyCodes.enter) {
        this.onEnterDown(e);
      }
      this.changeSelectedIndex(keyCode);
    },
    onTabDown(e) {
      if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {
        e.preventDefault();
        e.stopPropagation();
        return this.updateTags();
      }
      VAutocomplete_default.options.methods.onTabDown.call(this, e);
    },
    selectItem(item) {
      if (this.editingIndex > -1) {
        this.updateEditing();
      } else {
        VAutocomplete_default.options.methods.selectItem.call(this, item);
        if (this.internalSearch && this.multiple && this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())) {
          this.internalSearch = null;
        }
      }
    },
    setSelectedItems() {
      if (this.internalValue == null || this.internalValue === "") {
        this.selectedItems = [];
      } else {
        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];
      }
    },
    setValue(value) {
      VSelect_default.options.methods.setValue.call(this, value === void 0 ? this.internalSearch : value);
    },
    updateEditing() {
      const value = this.internalValue.slice();
      const index2 = this.selectedItems.findIndex((item) => this.getText(item) === this.internalSearch);
      if (index2 > -1) {
        const item = typeof value[index2] === "object" ? Object.assign({}, value[index2]) : value[index2];
        value.splice(index2, 1);
        value.push(item);
      } else {
        value[this.editingIndex] = this.internalSearch;
      }
      this.setValue(value);
      this.editingIndex = -1;
      this.internalSearch = null;
    },
    updateCombobox() {
      if (!this.searchIsDirty)
        return;
      if (this.internalSearch !== this.getText(this.internalValue))
        this.setValue();
      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips;
      if (isUsingSlot)
        this.internalSearch = null;
    },
    updateSelf() {
      this.multiple ? this.updateTags() : this.updateCombobox();
    },
    updateTags() {
      const menuIndex = this.getMenuIndex();
      if (menuIndex < 0 && !this.searchIsDirty || !this.internalSearch)
        return;
      if (this.editingIndex > -1) {
        return this.updateEditing();
      }
      const index2 = this.selectedItems.findIndex((item) => this.internalSearch === this.getText(item));
      const itemToSelect = index2 > -1 && typeof this.selectedItems[index2] === "object" ? Object.assign({}, this.selectedItems[index2]) : this.internalSearch;
      if (index2 > -1) {
        const internalValue = this.internalValue.slice();
        internalValue.splice(index2, 1);
        this.setValue(internalValue);
      }
      if (menuIndex > -1)
        return this.internalSearch = null;
      this.selectItem(itemToSelect);
      this.internalSearch = null;
    },
    onPaste(event) {
      var _event$clipboardData;
      if (!this.multiple || this.searchIsDirty)
        return;
      const pastedItemText = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData("text/vnd.vuetify.autocomplete.item+plain");
      if (pastedItemText && this.findExistingIndex(pastedItemText) === -1) {
        event.preventDefault();
        VSelect_default.options.methods.selectItem.call(this, pastedItemText);
      }
    },
    clearableCallback() {
      this.editingIndex = -1;
      VAutocomplete_default.options.methods.clearableCallback.call(this);
    }
  }
});

// node_modules/vuetify/lib/components/VData/VData.js
var VData_default = vue_runtime_esm_default.extend({
  name: "v-data",
  inheritAttrs: false,
  props: {
    items: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({})
    },
    sortBy: {
      type: [String, Array]
    },
    sortDesc: {
      type: [Boolean, Array]
    },
    customSort: {
      type: Function,
      default: sortItems
    },
    mustSort: Boolean,
    multiSort: Boolean,
    page: {
      type: Number,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      default: 10
    },
    groupBy: {
      type: [String, Array],
      default: () => []
    },
    groupDesc: {
      type: [Boolean, Array],
      default: () => []
    },
    customGroup: {
      type: Function,
      default: groupItems
    },
    locale: {
      type: String,
      default: "en-US"
    },
    disableSort: Boolean,
    disablePagination: Boolean,
    disableFiltering: Boolean,
    search: String,
    customFilter: {
      type: Function,
      default: searchItems
    },
    serverItemsLength: {
      type: Number,
      default: -1
    }
  },
  data() {
    let internalOptions = {
      page: this.page,
      itemsPerPage: this.itemsPerPage,
      sortBy: wrapInArray(this.sortBy),
      sortDesc: wrapInArray(this.sortDesc),
      groupBy: wrapInArray(this.groupBy),
      groupDesc: wrapInArray(this.groupDesc),
      mustSort: this.mustSort,
      multiSort: this.multiSort
    };
    if (this.options) {
      internalOptions = Object.assign(internalOptions, this.options);
    }
    const {
      sortBy,
      sortDesc,
      groupBy,
      groupDesc
    } = internalOptions;
    const sortDiff = sortBy.length - sortDesc.length;
    const groupDiff = groupBy.length - groupDesc.length;
    if (sortDiff > 0) {
      internalOptions.sortDesc.push(...fillArray(sortDiff, false));
    }
    if (groupDiff > 0) {
      internalOptions.groupDesc.push(...fillArray(groupDiff, false));
    }
    return {
      internalOptions
    };
  },
  computed: {
    itemsLength() {
      return this.serverItemsLength >= 0 ? this.serverItemsLength : this.filteredItems.length;
    },
    pageCount() {
      return this.internalOptions.itemsPerPage <= 0 ? 1 : Math.ceil(this.itemsLength / this.internalOptions.itemsPerPage);
    },
    pageStart() {
      if (this.internalOptions.itemsPerPage === -1 || !this.items.length)
        return 0;
      return (this.internalOptions.page - 1) * this.internalOptions.itemsPerPage;
    },
    pageStop() {
      if (this.internalOptions.itemsPerPage === -1)
        return this.itemsLength;
      if (!this.items.length)
        return 0;
      return Math.min(this.itemsLength, this.internalOptions.page * this.internalOptions.itemsPerPage);
    },
    isGrouped() {
      return !!this.internalOptions.groupBy.length;
    },
    pagination() {
      return {
        page: this.internalOptions.page,
        itemsPerPage: this.internalOptions.itemsPerPage,
        pageStart: this.pageStart,
        pageStop: this.pageStop,
        pageCount: this.pageCount,
        itemsLength: this.itemsLength
      };
    },
    filteredItems() {
      let items = this.items.slice();
      if (!this.disableFiltering && this.serverItemsLength <= 0) {
        items = this.customFilter(items, this.search);
      }
      return items;
    },
    computedItems() {
      let items = this.filteredItems.slice();
      if ((!this.disableSort || this.internalOptions.groupBy.length) && this.serverItemsLength <= 0) {
        items = this.sortItems(items);
      }
      if (!this.disablePagination && this.serverItemsLength <= 0) {
        items = this.paginateItems(items);
      }
      return items;
    },
    groupedItems() {
      return this.isGrouped ? this.groupItems(this.computedItems) : null;
    },
    scopedProps() {
      return {
        sort: this.sort,
        sortArray: this.sortArray,
        group: this.group,
        items: this.computedItems,
        options: this.internalOptions,
        updateOptions: this.updateOptions,
        pagination: this.pagination,
        groupedItems: this.groupedItems,
        originalItemsLength: this.items.length
      };
    },
    computedOptions() {
      return __spreadValues({}, this.options);
    }
  },
  watch: {
    computedOptions: {
      handler(options, old) {
        if (deepEqual(options, old))
          return;
        this.updateOptions(options);
      },
      deep: true,
      immediate: true
    },
    internalOptions: {
      handler(options, old) {
        if (deepEqual(options, old))
          return;
        this.$emit("update:options", options);
      },
      deep: true,
      immediate: true
    },
    page(page) {
      this.updateOptions({
        page
      });
    },
    "internalOptions.page"(page) {
      this.$emit("update:page", page);
    },
    itemsPerPage(itemsPerPage) {
      this.updateOptions({
        itemsPerPage
      });
    },
    "internalOptions.itemsPerPage"(itemsPerPage) {
      this.$emit("update:items-per-page", itemsPerPage);
    },
    sortBy(sortBy) {
      this.updateOptions({
        sortBy: wrapInArray(sortBy)
      });
    },
    "internalOptions.sortBy"(sortBy, old) {
      !deepEqual(sortBy, old) && this.$emit("update:sort-by", Array.isArray(this.sortBy) ? sortBy : sortBy[0]);
    },
    sortDesc(sortDesc) {
      this.updateOptions({
        sortDesc: wrapInArray(sortDesc)
      });
    },
    "internalOptions.sortDesc"(sortDesc, old) {
      !deepEqual(sortDesc, old) && this.$emit("update:sort-desc", Array.isArray(this.sortDesc) ? sortDesc : sortDesc[0]);
    },
    groupBy(groupBy) {
      this.updateOptions({
        groupBy: wrapInArray(groupBy)
      });
    },
    "internalOptions.groupBy"(groupBy, old) {
      !deepEqual(groupBy, old) && this.$emit("update:group-by", Array.isArray(this.groupBy) ? groupBy : groupBy[0]);
    },
    groupDesc(groupDesc) {
      this.updateOptions({
        groupDesc: wrapInArray(groupDesc)
      });
    },
    "internalOptions.groupDesc"(groupDesc, old) {
      !deepEqual(groupDesc, old) && this.$emit("update:group-desc", Array.isArray(this.groupDesc) ? groupDesc : groupDesc[0]);
    },
    multiSort(multiSort) {
      this.updateOptions({
        multiSort
      });
    },
    "internalOptions.multiSort"(multiSort) {
      this.$emit("update:multi-sort", multiSort);
    },
    mustSort(mustSort) {
      this.updateOptions({
        mustSort
      });
    },
    "internalOptions.mustSort"(mustSort) {
      this.$emit("update:must-sort", mustSort);
    },
    pageCount: {
      handler(pageCount) {
        this.$emit("page-count", pageCount);
      },
      immediate: true
    },
    computedItems: {
      handler(computedItems) {
        this.$emit("current-items", computedItems);
      },
      immediate: true
    },
    pagination: {
      handler(pagination, old) {
        if (deepEqual(pagination, old))
          return;
        this.$emit("pagination", this.pagination);
      },
      immediate: true
    }
  },
  methods: {
    toggle(key, oldBy, oldDesc, page, mustSort, multiSort) {
      let by = oldBy.slice();
      let desc = oldDesc.slice();
      const byIndex = by.findIndex((k) => k === key);
      if (byIndex < 0) {
        if (!multiSort) {
          by = [];
          desc = [];
        }
        by.push(key);
        desc.push(false);
      } else if (byIndex >= 0 && !desc[byIndex]) {
        desc[byIndex] = true;
      } else if (!mustSort) {
        by.splice(byIndex, 1);
        desc.splice(byIndex, 1);
      } else {
        desc[byIndex] = false;
      }
      if (!deepEqual(by, oldBy) || !deepEqual(desc, oldDesc)) {
        page = 1;
      }
      return {
        by,
        desc,
        page
      };
    },
    group(key) {
      const {
        by: groupBy,
        desc: groupDesc,
        page
      } = this.toggle(key, this.internalOptions.groupBy, this.internalOptions.groupDesc, this.internalOptions.page, true, false);
      this.updateOptions({
        groupBy,
        groupDesc,
        page
      });
    },
    sort(key) {
      if (Array.isArray(key))
        return this.sortArray(key);
      const {
        by: sortBy,
        desc: sortDesc,
        page
      } = this.toggle(key, this.internalOptions.sortBy, this.internalOptions.sortDesc, this.internalOptions.page, this.internalOptions.mustSort, this.internalOptions.multiSort);
      this.updateOptions({
        sortBy,
        sortDesc,
        page
      });
    },
    sortArray(sortBy) {
      const sortDesc = sortBy.map((s) => {
        const i = this.internalOptions.sortBy.findIndex((k) => k === s);
        return i > -1 ? this.internalOptions.sortDesc[i] : false;
      });
      this.updateOptions({
        sortBy,
        sortDesc
      });
    },
    updateOptions(options) {
      this.internalOptions = __spreadProps(__spreadValues(__spreadValues({}, this.internalOptions), options), {
        page: this.serverItemsLength < 0 ? Math.max(1, Math.min(options.page || this.internalOptions.page, this.pageCount)) : options.page || this.internalOptions.page
      });
    },
    sortItems(items) {
      let sortBy = [];
      let sortDesc = [];
      if (!this.disableSort) {
        sortBy = this.internalOptions.sortBy;
        sortDesc = this.internalOptions.sortDesc;
      }
      if (this.internalOptions.groupBy.length) {
        sortBy = [...this.internalOptions.groupBy, ...sortBy];
        sortDesc = [...this.internalOptions.groupDesc, ...sortDesc];
      }
      return this.customSort(items, sortBy, sortDesc, this.locale);
    },
    groupItems(items) {
      return this.customGroup(items, this.internalOptions.groupBy, this.internalOptions.groupDesc);
    },
    paginateItems(items) {
      if (this.serverItemsLength === -1 && items.length <= this.pageStart) {
        this.internalOptions.page = Math.max(1, Math.ceil(items.length / this.internalOptions.itemsPerPage)) || 1;
      }
      return items.slice(this.pageStart, this.pageStop);
    }
  },
  render() {
    return this.$scopedSlots.default && this.$scopedSlots.default(this.scopedProps);
  }
});

// node_modules/vuetify/lib/components/VDataIterator/VDataFooter.js
var VDataFooter_default = vue_runtime_esm_default.extend({
  name: "v-data-footer",
  props: {
    options: {
      type: Object,
      required: true
    },
    pagination: {
      type: Object,
      required: true
    },
    itemsPerPageOptions: {
      type: Array,
      default: () => [5, 10, 15, -1]
    },
    prevIcon: {
      type: String,
      default: "$prev"
    },
    nextIcon: {
      type: String,
      default: "$next"
    },
    firstIcon: {
      type: String,
      default: "$first"
    },
    lastIcon: {
      type: String,
      default: "$last"
    },
    itemsPerPageText: {
      type: String,
      default: "$vuetify.dataFooter.itemsPerPageText"
    },
    itemsPerPageAllText: {
      type: String,
      default: "$vuetify.dataFooter.itemsPerPageAll"
    },
    showFirstLastPage: Boolean,
    showCurrentPage: Boolean,
    disablePagination: Boolean,
    disableItemsPerPage: Boolean,
    pageText: {
      type: String,
      default: "$vuetify.dataFooter.pageText"
    }
  },
  computed: {
    disableNextPageIcon() {
      return this.options.itemsPerPage <= 0 || this.options.page * this.options.itemsPerPage >= this.pagination.itemsLength || this.pagination.pageStop < 0;
    },
    computedDataItemsPerPageOptions() {
      return this.itemsPerPageOptions.map((option) => {
        if (typeof option === "object")
          return option;
        else
          return this.genDataItemsPerPageOption(option);
      });
    }
  },
  methods: {
    updateOptions(obj) {
      this.$emit("update:options", Object.assign({}, this.options, obj));
    },
    onFirstPage() {
      this.updateOptions({
        page: 1
      });
    },
    onPreviousPage() {
      this.updateOptions({
        page: this.options.page - 1
      });
    },
    onNextPage() {
      this.updateOptions({
        page: this.options.page + 1
      });
    },
    onLastPage() {
      this.updateOptions({
        page: this.pagination.pageCount
      });
    },
    onChangeItemsPerPage(itemsPerPage) {
      this.updateOptions({
        itemsPerPage,
        page: 1
      });
    },
    genDataItemsPerPageOption(option) {
      return {
        text: option === -1 ? this.$vuetify.lang.t(this.itemsPerPageAllText) : String(option),
        value: option
      };
    },
    genItemsPerPageSelect() {
      let value = this.options.itemsPerPage;
      const computedIPPO = this.computedDataItemsPerPageOptions;
      if (computedIPPO.length <= 1)
        return null;
      if (!computedIPPO.find((ippo) => ippo.value === value))
        value = computedIPPO[0];
      return this.$createElement("div", {
        staticClass: "v-data-footer__select"
      }, [this.$vuetify.lang.t(this.itemsPerPageText), this.$createElement(VSelect_default, {
        attrs: {
          "aria-label": this.$vuetify.lang.t(this.itemsPerPageText)
        },
        props: {
          disabled: this.disableItemsPerPage,
          items: computedIPPO,
          value,
          hideDetails: true,
          auto: true,
          minWidth: "75px"
        },
        on: {
          input: this.onChangeItemsPerPage
        }
      })]);
    },
    genPaginationInfo() {
      let children = ["\u2013"];
      const itemsLength = this.pagination.itemsLength;
      let pageStart = this.pagination.pageStart;
      let pageStop = this.pagination.pageStop;
      if (this.pagination.itemsLength && this.pagination.itemsPerPage) {
        pageStart = this.pagination.pageStart + 1;
        pageStop = itemsLength < this.pagination.pageStop || this.pagination.pageStop < 0 ? itemsLength : this.pagination.pageStop;
        children = this.$scopedSlots["page-text"] ? [this.$scopedSlots["page-text"]({
          pageStart,
          pageStop,
          itemsLength
        })] : [this.$vuetify.lang.t(this.pageText, pageStart, pageStop, itemsLength)];
      } else if (this.$scopedSlots["page-text"]) {
        children = [this.$scopedSlots["page-text"]({
          pageStart,
          pageStop,
          itemsLength
        })];
      }
      return this.$createElement("div", {
        class: "v-data-footer__pagination"
      }, children);
    },
    genIcon(click, disabled, label, icon) {
      return this.$createElement(VBtn_default2, {
        props: {
          disabled: disabled || this.disablePagination,
          icon: true,
          text: true
        },
        on: {
          click
        },
        attrs: {
          "aria-label": label
        }
      }, [this.$createElement(VIcon_default2, icon)]);
    },
    genIcons() {
      const before = [];
      const after = [];
      before.push(this.genIcon(this.onPreviousPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.prevPage"), this.$vuetify.rtl ? this.nextIcon : this.prevIcon));
      after.push(this.genIcon(this.onNextPage, this.disableNextPageIcon, this.$vuetify.lang.t("$vuetify.dataFooter.nextPage"), this.$vuetify.rtl ? this.prevIcon : this.nextIcon));
      if (this.showFirstLastPage) {
        before.unshift(this.genIcon(this.onFirstPage, this.options.page === 1, this.$vuetify.lang.t("$vuetify.dataFooter.firstPage"), this.$vuetify.rtl ? this.lastIcon : this.firstIcon));
        after.push(this.genIcon(this.onLastPage, this.options.page >= this.pagination.pageCount || this.options.itemsPerPage === -1, this.$vuetify.lang.t("$vuetify.dataFooter.lastPage"), this.$vuetify.rtl ? this.firstIcon : this.lastIcon));
      }
      return [this.$createElement("div", {
        staticClass: "v-data-footer__icons-before"
      }, before), this.showCurrentPage && this.$createElement("span", [this.options.page.toString()]), this.$createElement("div", {
        staticClass: "v-data-footer__icons-after"
      }, after)];
    }
  },
  render() {
    return this.$createElement("div", {
      staticClass: "v-data-footer"
    }, [getSlot(this, "prepend"), this.genItemsPerPageSelect(), this.genPaginationInfo(), this.genIcons()]);
  }
});

// node_modules/vuetify/lib/components/VDataIterator/VDataIterator.js
var VDataIterator_default = mixins(mobile_default, themeable_default).extend({
  name: "v-data-iterator",
  props: __spreadProps(__spreadValues({}, VData_default.options.props), {
    itemKey: {
      type: String,
      default: "id"
    },
    value: {
      type: Array,
      default: () => []
    },
    singleSelect: Boolean,
    expanded: {
      type: Array,
      default: () => []
    },
    mobileBreakpoint: __spreadProps(__spreadValues({}, mobile_default.options.props.mobileBreakpoint), {
      default: 600
    }),
    singleExpand: Boolean,
    loading: [Boolean, String],
    noResultsText: {
      type: String,
      default: "$vuetify.dataIterator.noResultsText"
    },
    noDataText: {
      type: String,
      default: "$vuetify.noDataText"
    },
    loadingText: {
      type: String,
      default: "$vuetify.dataIterator.loadingText"
    },
    hideDefaultFooter: Boolean,
    footerProps: Object,
    selectableKey: {
      type: String,
      default: "isSelectable"
    }
  }),
  data: () => ({
    selection: {},
    expansion: {},
    internalCurrentItems: [],
    shiftKeyDown: false,
    lastEntry: -1
  }),
  computed: {
    everyItem() {
      return !!this.selectableItems.length && this.selectableItems.every((i) => this.isSelected(i));
    },
    someItems() {
      return this.selectableItems.some((i) => this.isSelected(i));
    },
    sanitizedFooterProps() {
      return camelizeObjectKeys(this.footerProps);
    },
    selectableItems() {
      return this.internalCurrentItems.filter((item) => this.isSelectable(item));
    }
  },
  watch: {
    value: {
      handler(value) {
        this.selection = value.reduce((selection, item) => {
          selection[getObjectValueByPath(item, this.itemKey)] = item;
          return selection;
        }, {});
      },
      immediate: true
    },
    selection(value, old) {
      if (deepEqual(Object.keys(value), Object.keys(old)))
        return;
      this.$emit("input", Object.values(value));
    },
    expanded: {
      handler(value) {
        this.expansion = value.reduce((expansion, item) => {
          expansion[getObjectValueByPath(item, this.itemKey)] = true;
          return expansion;
        }, {});
      },
      immediate: true
    },
    expansion(value, old) {
      if (deepEqual(value, old))
        return;
      const keys2 = Object.keys(value).filter((k) => value[k]);
      const expanded = !keys2.length ? [] : this.items.filter((i) => keys2.includes(String(getObjectValueByPath(i, this.itemKey))));
      this.$emit("update:expanded", expanded);
    }
  },
  created() {
    const breakingProps = [["disable-initial-sort", "sort-by"], ["filter", "custom-filter"], ["pagination", "options"], ["total-items", "server-items-length"], ["hide-actions", "hide-default-footer"], ["rows-per-page-items", "footer-props.items-per-page-options"], ["rows-per-page-text", "footer-props.items-per-page-text"], ["prev-icon", "footer-props.prev-icon"], ["next-icon", "footer-props.next-icon"]];
    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original))
        breaking(original, replacement, this);
    });
    const removedProps = ["expand", "content-class", "content-props", "content-tag"];
    removedProps.forEach((prop) => {
      if (this.$attrs.hasOwnProperty(prop))
        removed(prop);
    });
  },
  mounted() {
    window.addEventListener("keydown", this.onKeyDown);
    window.addEventListener("keyup", this.onKeyUp);
  },
  beforeDestroy() {
    window.removeEventListener("keydown", this.onKeyDown);
    window.removeEventListener("keyup", this.onKeyUp);
  },
  methods: {
    onKeyDown(e) {
      if (e.keyCode !== keyCodes.shift)
        return;
      this.shiftKeyDown = true;
    },
    onKeyUp(e) {
      if (e.keyCode !== keyCodes.shift)
        return;
      this.shiftKeyDown = false;
    },
    toggleSelectAll(value) {
      const selection = Object.assign({}, this.selection);
      for (let i = 0; i < this.selectableItems.length; i++) {
        const item = this.selectableItems[i];
        if (!this.isSelectable(item))
          continue;
        const key = getObjectValueByPath(item, this.itemKey);
        if (value)
          selection[key] = item;
        else
          delete selection[key];
      }
      this.selection = selection;
      this.$emit("toggle-select-all", {
        items: this.internalCurrentItems,
        value
      });
    },
    isSelectable(item) {
      return getObjectValueByPath(item, this.selectableKey) !== false;
    },
    isSelected(item) {
      return !!this.selection[getObjectValueByPath(item, this.itemKey)] || false;
    },
    select(item, value = true, emit = true) {
      if (!this.isSelectable(item))
        return;
      const selection = this.singleSelect ? {} : Object.assign({}, this.selection);
      const key = getObjectValueByPath(item, this.itemKey);
      if (value)
        selection[key] = item;
      else
        delete selection[key];
      const index2 = this.selectableItems.findIndex((x) => getObjectValueByPath(x, this.itemKey) === key);
      if (this.lastEntry === -1)
        this.lastEntry = index2;
      else if (this.shiftKeyDown && !this.singleSelect && emit) {
        const lastEntryKey = getObjectValueByPath(this.selectableItems[this.lastEntry], this.itemKey);
        const lastEntryKeySelected = Object.keys(this.selection).includes(String(lastEntryKey));
        this.multipleSelect(lastEntryKeySelected, emit, selection, index2);
      }
      this.lastEntry = index2;
      if (this.singleSelect && emit) {
        const keys2 = Object.keys(this.selection);
        const old = keys2.length && getObjectValueByPath(this.selection[keys2[0]], this.itemKey);
        old && old !== key && this.$emit("item-selected", {
          item: this.selection[old],
          value: false
        });
      }
      this.selection = selection;
      emit && this.$emit("item-selected", {
        item,
        value
      });
    },
    multipleSelect(value = true, emit = true, selection, index2) {
      const start = index2 < this.lastEntry ? index2 : this.lastEntry;
      const end = index2 < this.lastEntry ? this.lastEntry : index2;
      for (let i = start; i <= end; i++) {
        const currentItem = this.selectableItems[i];
        const key = getObjectValueByPath(currentItem, this.itemKey);
        if (value)
          selection[key] = currentItem;
        else
          delete selection[key];
        emit && this.$emit("item-selected", {
          currentItem,
          value
        });
      }
    },
    isExpanded(item) {
      return this.expansion[getObjectValueByPath(item, this.itemKey)] || false;
    },
    expand(item, value = true) {
      const expansion = this.singleExpand ? {} : Object.assign({}, this.expansion);
      const key = getObjectValueByPath(item, this.itemKey);
      if (value)
        expansion[key] = true;
      else
        delete expansion[key];
      this.expansion = expansion;
      this.$emit("item-expanded", {
        item,
        value
      });
    },
    createItemProps(item, index2) {
      return {
        item,
        index: index2,
        select: (v) => this.select(item, v),
        isSelected: this.isSelected(item),
        expand: (v) => this.expand(item, v),
        isExpanded: this.isExpanded(item),
        isMobile: this.isMobile
      };
    },
    genEmptyWrapper(content) {
      return this.$createElement("div", content);
    },
    genEmpty(originalItemsLength, filteredItemsLength) {
      if (originalItemsLength === 0 && this.loading) {
        const loading = this.$slots.loading || this.$vuetify.lang.t(this.loadingText);
        return this.genEmptyWrapper(loading);
      } else if (originalItemsLength === 0) {
        const noData = this.$slots["no-data"] || this.$vuetify.lang.t(this.noDataText);
        return this.genEmptyWrapper(noData);
      } else if (filteredItemsLength === 0) {
        const noResults = this.$slots["no-results"] || this.$vuetify.lang.t(this.noResultsText);
        return this.genEmptyWrapper(noResults);
      }
      return null;
    },
    genItems(props2) {
      const empty = this.genEmpty(props2.originalItemsLength, props2.pagination.itemsLength);
      if (empty)
        return [empty];
      if (this.$scopedSlots.default) {
        return this.$scopedSlots.default(__spreadProps(__spreadValues({}, props2), {
          isSelected: this.isSelected,
          select: this.select,
          isExpanded: this.isExpanded,
          isMobile: this.isMobile,
          expand: this.expand
        }));
      }
      if (this.$scopedSlots.item) {
        return props2.items.map((item, index2) => this.$scopedSlots.item(this.createItemProps(item, index2)));
      }
      return [];
    },
    genFooter(props2) {
      if (this.hideDefaultFooter)
        return null;
      const data = {
        props: __spreadProps(__spreadValues({}, this.sanitizedFooterProps), {
          options: props2.options,
          pagination: props2.pagination
        }),
        on: {
          "update:options": (value) => props2.updateOptions(value)
        }
      };
      const scopedSlots = getPrefixedScopedSlots("footer.", this.$scopedSlots);
      return this.$createElement(VDataFooter_default, __spreadValues({
        scopedSlots
      }, data));
    },
    genDefaultScopedSlot(props2) {
      const outerProps = __spreadProps(__spreadValues({}, props2), {
        someItems: this.someItems,
        everyItem: this.everyItem,
        toggleSelectAll: this.toggleSelectAll
      });
      return this.$createElement("div", {
        staticClass: "v-data-iterator"
      }, [getSlot(this, "header", outerProps, true), this.genItems(props2), this.genFooter(props2), getSlot(this, "footer", outerProps, true)]);
    }
  },
  render() {
    return this.$createElement(VData_default, {
      props: this.$props,
      on: {
        "update:options": (v, old) => !deepEqual(v, old) && this.$emit("update:options", v),
        "update:page": (v) => this.$emit("update:page", v),
        "update:items-per-page": (v) => this.$emit("update:items-per-page", v),
        "update:sort-by": (v) => this.$emit("update:sort-by", v),
        "update:sort-desc": (v) => this.$emit("update:sort-desc", v),
        "update:group-by": (v) => this.$emit("update:group-by", v),
        "update:group-desc": (v) => this.$emit("update:group-desc", v),
        pagination: (v, old) => !deepEqual(v, old) && this.$emit("pagination", v),
        "current-items": (v) => {
          this.internalCurrentItems = v;
          this.$emit("current-items", v);
        },
        "page-count": (v) => this.$emit("page-count", v)
      },
      scopedSlots: {
        default: this.genDefaultScopedSlot
      }
    });
  }
});

// node_modules/vuetify/lib/components/VDataTable/mixins/header.js
var header_default = mixins().extend({
  directives: {
    ripple: ripple_default
  },
  props: {
    headers: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({
        page: 1,
        itemsPerPage: 10,
        sortBy: [],
        sortDesc: [],
        groupBy: [],
        groupDesc: [],
        multiSort: false,
        mustSort: false
      })
    },
    checkboxColor: String,
    sortIcon: {
      type: String,
      default: "$sort"
    },
    everyItem: Boolean,
    someItems: Boolean,
    showGroupBy: Boolean,
    singleSelect: Boolean,
    disableSort: Boolean
  },
  methods: {
    genSelectAll() {
      var _this$checkboxColor;
      const data = {
        props: {
          value: this.everyItem,
          indeterminate: !this.everyItem && this.someItems,
          color: (_this$checkboxColor = this.checkboxColor) != null ? _this$checkboxColor : ""
        },
        on: {
          input: (v) => this.$emit("toggle-select-all", v)
        }
      };
      if (this.$scopedSlots["data-table-select"]) {
        return this.$scopedSlots["data-table-select"](data);
      }
      return this.$createElement(VSimpleCheckbox_default, __spreadValues({
        staticClass: "v-data-table__checkbox"
      }, data));
    },
    genSortIcon() {
      return this.$createElement(VIcon_default2, {
        staticClass: "v-data-table-header__icon",
        props: {
          size: 18
        }
      }, [this.sortIcon]);
    }
  }
});

// node_modules/vuetify/lib/components/VDataTable/VDataTableHeaderMobile.js
var VDataTableHeaderMobile_default = mixins(header_default).extend({
  name: "v-data-table-header-mobile",
  props: {
    sortByText: {
      type: String,
      default: "$vuetify.dataTable.sortBy"
    }
  },
  methods: {
    genSortChip(props2) {
      const children = [props2.item.text];
      const sortIndex = this.options.sortBy.findIndex((k) => k === props2.item.value);
      const beingSorted = sortIndex >= 0;
      const isDesc = this.options.sortDesc[sortIndex];
      children.push(this.$createElement("div", {
        staticClass: "v-chip__close",
        class: {
          sortable: true,
          active: beingSorted,
          asc: beingSorted && !isDesc,
          desc: beingSorted && isDesc
        }
      }, [this.genSortIcon()]));
      return this.$createElement(VChip_default2, {
        staticClass: "sortable",
        on: {
          click: (e) => {
            e.stopPropagation();
            this.$emit("sort", props2.item.value);
          }
        }
      }, children);
    },
    genSortSelect(items) {
      return this.$createElement(VSelect_default, {
        props: {
          label: this.$vuetify.lang.t(this.sortByText),
          items,
          hideDetails: true,
          multiple: this.options.multiSort,
          value: this.options.multiSort ? this.options.sortBy : this.options.sortBy[0],
          menuProps: {
            closeOnContentClick: true
          }
        },
        on: {
          change: (v) => this.$emit("sort", v)
        },
        scopedSlots: {
          selection: (props2) => this.genSortChip(props2)
        }
      });
    }
  },
  render(h) {
    const children = [];
    const header = this.headers.find((h2) => h2.value === "data-table-select");
    if (header && !this.singleSelect) {
      children.push(this.$createElement("div", {
        class: ["v-data-table-header-mobile__select", ...wrapInArray(header.class)],
        attrs: {
          width: header.width
        }
      }, [this.genSelectAll()]));
    }
    const sortHeaders = this.headers.filter((h2) => h2.sortable !== false && h2.value !== "data-table-select").map((h2) => ({
      text: h2.text,
      value: h2.value
    }));
    if (!this.disableSort && sortHeaders.length) {
      children.push(this.genSortSelect(sortHeaders));
    }
    const th = children.length ? h("th", [h("div", {
      staticClass: "v-data-table-header-mobile__wrapper"
    }, children)]) : void 0;
    const tr = h("tr", [th]);
    return h("thead", {
      staticClass: "v-data-table-header v-data-table-header-mobile"
    }, [tr]);
  }
});

// node_modules/vuetify/lib/components/VDataTable/VDataTableHeaderDesktop.js
var VDataTableHeaderDesktop_default = mixins(header_default).extend({
  name: "v-data-table-header-desktop",
  methods: {
    genGroupByToggle(header) {
      return this.$createElement("span", {
        on: {
          click: (e) => {
            e.stopPropagation();
            this.$emit("group", header.value);
          }
        }
      }, ["group"]);
    },
    getAria(beingSorted, isDesc) {
      const $t = (key) => this.$vuetify.lang.t(`$vuetify.dataTable.ariaLabel.${key}`);
      let ariaSort = "none";
      let ariaLabel = [$t("sortNone"), $t("activateAscending")];
      if (!beingSorted) {
        return {
          ariaSort,
          ariaLabel: ariaLabel.join(" ")
        };
      }
      if (isDesc) {
        ariaSort = "descending";
        ariaLabel = [$t("sortDescending"), $t(this.options.mustSort ? "activateAscending" : "activateNone")];
      } else {
        ariaSort = "ascending";
        ariaLabel = [$t("sortAscending"), $t("activateDescending")];
      }
      return {
        ariaSort,
        ariaLabel: ariaLabel.join(" ")
      };
    },
    genHeader(header) {
      const data = {
        attrs: {
          role: "columnheader",
          scope: "col",
          "aria-label": header.text || ""
        },
        style: {
          width: convertToUnit(header.width),
          minWidth: convertToUnit(header.width)
        },
        class: [`text-${header.align || "start"}`, ...wrapInArray(header.class), header.divider && "v-data-table__divider"],
        on: {}
      };
      const children = [];
      if (header.value === "data-table-select" && !this.singleSelect) {
        return this.$createElement("th", data, [this.genSelectAll()]);
      }
      children.push(this.$scopedSlots.hasOwnProperty(header.value) ? this.$scopedSlots[header.value]({
        header
      }) : this.$createElement("span", [header.text]));
      if (!this.disableSort && (header.sortable || !header.hasOwnProperty("sortable"))) {
        data.on.click = () => this.$emit("sort", header.value);
        const sortIndex = this.options.sortBy.findIndex((k) => k === header.value);
        const beingSorted = sortIndex >= 0;
        const isDesc = this.options.sortDesc[sortIndex];
        data.class.push("sortable");
        const {
          ariaLabel,
          ariaSort
        } = this.getAria(beingSorted, isDesc);
        data.attrs["aria-label"] += `${header.text ? ": " : ""}${ariaLabel}`;
        data.attrs["aria-sort"] = ariaSort;
        if (beingSorted) {
          data.class.push("active");
          data.class.push(isDesc ? "desc" : "asc");
        }
        if (header.align === "end")
          children.unshift(this.genSortIcon());
        else
          children.push(this.genSortIcon());
        if (this.options.multiSort && beingSorted) {
          children.push(this.$createElement("span", {
            class: "v-data-table-header__sort-badge"
          }, [String(sortIndex + 1)]));
        }
      }
      if (this.showGroupBy && header.groupable !== false)
        children.push(this.genGroupByToggle(header));
      return this.$createElement("th", data, children);
    }
  },
  render() {
    return this.$createElement("thead", {
      staticClass: "v-data-table-header"
    }, [this.$createElement("tr", this.headers.map((header) => this.genHeader(header)))]);
  }
});

// node_modules/vuetify/lib/util/dedupeModelListeners.js
function dedupeModelListeners(data) {
  if (data.model && data.on && data.on.input) {
    if (Array.isArray(data.on.input)) {
      const i = data.on.input.indexOf(data.model.callback);
      if (i > -1)
        data.on.input.splice(i, 1);
    } else {
      delete data.on.input;
    }
  }
}

// node_modules/vuetify/lib/util/rebuildFunctionalSlots.js
function rebuildFunctionalSlots(slots, h) {
  const children = [];
  for (const slot in slots) {
    if (slots.hasOwnProperty(slot)) {
      children.push(h("template", {
        slot
      }, slots[slot]));
    }
  }
  return children;
}

// node_modules/vuetify/lib/components/VDataTable/VDataTableHeader.js
var VDataTableHeader_default = vue_runtime_esm_default.extend({
  name: "v-data-table-header",
  functional: true,
  props: __spreadProps(__spreadValues({}, header_default.options.props), {
    mobile: Boolean
  }),
  render(h, {
    props: props2,
    data,
    slots
  }) {
    dedupeModelListeners(data);
    const children = rebuildFunctionalSlots(slots(), h);
    data = mergeData2(data, {
      props: props2
    });
    if (props2.mobile) {
      return h(VDataTableHeaderMobile_default, data, children);
    } else {
      return h(VDataTableHeaderDesktop_default, data, children);
    }
  }
});

// node_modules/vuetify/lib/components/VDataTable/Row.js
function needsTd(slot) {
  var _slot$;
  return slot.length !== 1 || !["td", "th"].includes((_slot$ = slot[0]) == null ? void 0 : _slot$.tag);
}
var Row_default = vue_runtime_esm_default.extend({
  name: "row",
  functional: true,
  props: {
    headers: Array,
    index: Number,
    item: Object,
    rtl: Boolean
  },
  render(h, {
    props: props2,
    slots,
    data
  }) {
    const computedSlots = slots();
    const columns = props2.headers.map((header) => {
      const children = [];
      const value = getObjectValueByPath(props2.item, header.value);
      const slotName = header.value;
      const scopedSlot = data.scopedSlots && data.scopedSlots.hasOwnProperty(slotName) && data.scopedSlots[slotName];
      const regularSlot = computedSlots.hasOwnProperty(slotName) && computedSlots[slotName];
      if (scopedSlot) {
        children.push(...wrapInArray(scopedSlot({
          item: props2.item,
          isMobile: false,
          header,
          index: props2.index,
          value
        })));
      } else if (regularSlot) {
        children.push(...wrapInArray(regularSlot));
      } else {
        children.push(value == null ? value : String(value));
      }
      const textAlign = `text-${header.align || "start"}`;
      return needsTd(children) ? h("td", {
        class: [textAlign, header.cellClass, {
          "v-data-table__divider": header.divider
        }]
      }, children) : children;
    });
    return h("tr", data, columns);
  }
});

// node_modules/vuetify/lib/components/VDataTable/RowGroup.js
var RowGroup_default = vue_runtime_esm_default.extend({
  name: "row-group",
  functional: true,
  props: {
    value: {
      type: Boolean,
      default: true
    },
    headerClass: {
      type: String,
      default: "v-row-group__header"
    },
    contentClass: String,
    summaryClass: {
      type: String,
      default: "v-row-group__summary"
    }
  },
  render(h, {
    slots,
    props: props2
  }) {
    const computedSlots = slots();
    const children = [];
    if (computedSlots["column.header"]) {
      children.push(h("tr", {
        staticClass: props2.headerClass
      }, computedSlots["column.header"]));
    } else if (computedSlots["row.header"]) {
      children.push(...computedSlots["row.header"]);
    }
    if (computedSlots["row.content"] && props2.value)
      children.push(...computedSlots["row.content"]);
    if (computedSlots["column.summary"]) {
      children.push(h("tr", {
        staticClass: props2.summaryClass
      }, computedSlots["column.summary"]));
    } else if (computedSlots["row.summary"]) {
      children.push(...computedSlots["row.summary"]);
    }
    return children;
  }
});

// node_modules/vuetify/lib/components/VDataTable/VSimpleTable.js
var VSimpleTable_default = mixins(themeable_default).extend({
  name: "v-simple-table",
  props: {
    dense: Boolean,
    fixedHeader: Boolean,
    height: [Number, String]
  },
  computed: {
    classes() {
      return __spreadValues({
        "v-data-table--dense": this.dense,
        "v-data-table--fixed-height": !!this.height && !this.fixedHeader,
        "v-data-table--fixed-header": this.fixedHeader,
        "v-data-table--has-top": !!this.$slots.top,
        "v-data-table--has-bottom": !!this.$slots.bottom
      }, this.themeClasses);
    }
  },
  methods: {
    genWrapper() {
      return this.$slots.wrapper || this.$createElement("div", {
        staticClass: "v-data-table__wrapper",
        style: {
          height: convertToUnit(this.height)
        }
      }, [this.$createElement("table", this.$slots.default)]);
    }
  },
  render(h) {
    return h("div", {
      staticClass: "v-data-table",
      class: this.classes
    }, [this.$slots.top, this.genWrapper(), this.$slots.bottom]);
  }
});

// node_modules/vuetify/lib/components/VDataTable/MobileRow.js
var MobileRow_default = vue_runtime_esm_default.extend({
  name: "row",
  functional: true,
  props: {
    headers: Array,
    hideDefaultHeader: Boolean,
    index: Number,
    item: Object,
    rtl: Boolean
  },
  render(h, {
    props: props2,
    slots,
    data
  }) {
    const computedSlots = slots();
    const columns = props2.headers.map((header) => {
      const classes = {
        "v-data-table__mobile-row": true
      };
      const children = [];
      const value = getObjectValueByPath(props2.item, header.value);
      const slotName = header.value;
      const scopedSlot = data.scopedSlots && data.scopedSlots.hasOwnProperty(slotName) && data.scopedSlots[slotName];
      const regularSlot = computedSlots.hasOwnProperty(slotName) && computedSlots[slotName];
      if (scopedSlot) {
        children.push(scopedSlot({
          item: props2.item,
          isMobile: true,
          header,
          index: props2.index,
          value
        }));
      } else if (regularSlot) {
        children.push(regularSlot);
      } else {
        children.push(value == null ? value : String(value));
      }
      const mobileRowChildren = [h("div", {
        staticClass: "v-data-table__mobile-row__cell"
      }, children)];
      if (header.value !== "dataTableSelect" && !props2.hideDefaultHeader) {
        mobileRowChildren.unshift(h("div", {
          staticClass: "v-data-table__mobile-row__header"
        }, [header.text]));
      }
      return h("td", {
        class: classes
      }, mobileRowChildren);
    });
    return h("tr", __spreadProps(__spreadValues({}, data), {
      staticClass: "v-data-table__mobile-table-row"
    }), columns);
  }
});

// node_modules/vuetify/lib/components/VDataTable/VDataTable.js
function filterFn(item, search, filter) {
  return (header) => {
    const value = getObjectValueByPath(item, header.value);
    return header.filter ? header.filter(value, search, item) : filter(value, search, item);
  };
}
function searchTableItems(items, search, headersWithCustomFilters, headersWithoutCustomFilters, customFilter) {
  search = typeof search === "string" ? search.trim() : null;
  return items.filter((item) => {
    const matchesColumnFilters = headersWithCustomFilters.every(filterFn(item, search, defaultFilter));
    const matchesSearchTerm = !search || headersWithoutCustomFilters.some(filterFn(item, search, customFilter));
    return matchesColumnFilters && matchesSearchTerm;
  });
}
var VDataTable_default = mixins(VDataIterator_default, loadable_default).extend({
  name: "v-data-table",
  directives: {
    ripple: ripple_default
  },
  props: {
    headers: {
      type: Array,
      default: () => []
    },
    showSelect: Boolean,
    checkboxColor: String,
    showExpand: Boolean,
    showGroupBy: Boolean,
    height: [Number, String],
    hideDefaultHeader: Boolean,
    caption: String,
    dense: Boolean,
    headerProps: Object,
    calculateWidths: Boolean,
    fixedHeader: Boolean,
    headersLength: Number,
    expandIcon: {
      type: String,
      default: "$expand"
    },
    customFilter: {
      type: Function,
      default: defaultFilter
    },
    itemClass: {
      type: [String, Function],
      default: () => ""
    },
    loaderHeight: {
      type: [Number, String],
      default: 4
    }
  },
  data() {
    return {
      internalGroupBy: [],
      openCache: {},
      widths: []
    };
  },
  computed: {
    computedHeaders() {
      if (!this.headers)
        return [];
      const headers = this.headers.filter((h) => h.value === void 0 || !this.internalGroupBy.find((v) => v === h.value));
      const defaultHeader = {
        text: "",
        sortable: false,
        width: "1px"
      };
      if (this.showSelect) {
        const index2 = headers.findIndex((h) => h.value === "data-table-select");
        if (index2 < 0)
          headers.unshift(__spreadProps(__spreadValues({}, defaultHeader), {
            value: "data-table-select"
          }));
        else
          headers.splice(index2, 1, __spreadValues(__spreadValues({}, defaultHeader), headers[index2]));
      }
      if (this.showExpand) {
        const index2 = headers.findIndex((h) => h.value === "data-table-expand");
        if (index2 < 0)
          headers.unshift(__spreadProps(__spreadValues({}, defaultHeader), {
            value: "data-table-expand"
          }));
        else
          headers.splice(index2, 1, __spreadValues(__spreadValues({}, defaultHeader), headers[index2]));
      }
      return headers;
    },
    colspanAttrs() {
      return this.isMobile ? void 0 : {
        colspan: this.headersLength || this.computedHeaders.length
      };
    },
    columnSorters() {
      return this.computedHeaders.reduce((acc, header) => {
        if (header.sort)
          acc[header.value] = header.sort;
        return acc;
      }, {});
    },
    headersWithCustomFilters() {
      return this.headers.filter((header) => header.filter && (!header.hasOwnProperty("filterable") || header.filterable === true));
    },
    headersWithoutCustomFilters() {
      return this.headers.filter((header) => !header.filter && (!header.hasOwnProperty("filterable") || header.filterable === true));
    },
    sanitizedHeaderProps() {
      return camelizeObjectKeys(this.headerProps);
    },
    computedItemsPerPage() {
      const itemsPerPage = this.options && this.options.itemsPerPage ? this.options.itemsPerPage : this.itemsPerPage;
      const itemsPerPageOptions = this.sanitizedFooterProps.itemsPerPageOptions;
      if (itemsPerPageOptions && !itemsPerPageOptions.find((item) => typeof item === "number" ? item === itemsPerPage : item.value === itemsPerPage)) {
        const firstOption = itemsPerPageOptions[0];
        return typeof firstOption === "object" ? firstOption.value : firstOption;
      }
      return itemsPerPage;
    }
  },
  created() {
    const breakingProps = [["sort-icon", "header-props.sort-icon"], ["hide-headers", "hide-default-header"], ["select-all", "show-select"]];
    breakingProps.forEach(([original, replacement]) => {
      if (this.$attrs.hasOwnProperty(original))
        breaking(original, replacement, this);
    });
  },
  mounted() {
    if (this.calculateWidths) {
      window.addEventListener("resize", this.calcWidths);
      this.calcWidths();
    }
  },
  beforeDestroy() {
    if (this.calculateWidths) {
      window.removeEventListener("resize", this.calcWidths);
    }
  },
  methods: {
    calcWidths() {
      this.widths = Array.from(this.$el.querySelectorAll("th")).map((e) => e.clientWidth);
    },
    customFilterWithColumns(items, search) {
      return searchTableItems(items, search, this.headersWithCustomFilters, this.headersWithoutCustomFilters, this.customFilter);
    },
    customSortWithHeaders(items, sortBy, sortDesc, locale) {
      return this.customSort(items, sortBy, sortDesc, locale, this.columnSorters);
    },
    createItemProps(item, index2) {
      const props2 = VDataIterator_default.options.methods.createItemProps.call(this, item, index2);
      return Object.assign(props2, {
        headers: this.computedHeaders
      });
    },
    genCaption(props2) {
      if (this.caption)
        return [this.$createElement("caption", [this.caption])];
      return getSlot(this, "caption", props2, true);
    },
    genColgroup(props2) {
      return this.$createElement("colgroup", this.computedHeaders.map((header) => {
        return this.$createElement("col", {
          class: {
            divider: header.divider
          }
        });
      }));
    },
    genLoading() {
      const th = this.$createElement("th", {
        staticClass: "column",
        attrs: this.colspanAttrs
      }, [this.genProgress()]);
      const tr = this.$createElement("tr", {
        staticClass: "v-data-table__progress"
      }, [th]);
      return this.$createElement("thead", [tr]);
    },
    genHeaders(props2) {
      const data = {
        props: __spreadProps(__spreadValues({}, this.sanitizedHeaderProps), {
          headers: this.computedHeaders,
          options: props2.options,
          mobile: this.isMobile,
          showGroupBy: this.showGroupBy,
          checkboxColor: this.checkboxColor,
          someItems: this.someItems,
          everyItem: this.everyItem,
          singleSelect: this.singleSelect,
          disableSort: this.disableSort
        }),
        on: {
          sort: props2.sort,
          group: props2.group,
          "toggle-select-all": this.toggleSelectAll
        }
      };
      const children = [getSlot(this, "header", __spreadProps(__spreadValues({}, data), {
        isMobile: this.isMobile
      }))];
      if (!this.hideDefaultHeader) {
        const scopedSlots = getPrefixedScopedSlots("header.", this.$scopedSlots);
        children.push(this.$createElement(VDataTableHeader_default, __spreadProps(__spreadValues({}, data), {
          scopedSlots
        })));
      }
      if (this.loading)
        children.push(this.genLoading());
      return children;
    },
    genEmptyWrapper(content) {
      return this.$createElement("tr", {
        staticClass: "v-data-table__empty-wrapper"
      }, [this.$createElement("td", {
        attrs: this.colspanAttrs
      }, content)]);
    },
    genItems(items, props2) {
      const empty = this.genEmpty(props2.originalItemsLength, props2.pagination.itemsLength);
      if (empty)
        return [empty];
      return props2.groupedItems ? this.genGroupedRows(props2.groupedItems, props2) : this.genRows(items, props2);
    },
    genGroupedRows(groupedItems, props2) {
      return groupedItems.map((group) => {
        if (!this.openCache.hasOwnProperty(group.name))
          this.$set(this.openCache, group.name, true);
        if (this.$scopedSlots.group) {
          return this.$scopedSlots.group({
            group: group.name,
            options: props2.options,
            isMobile: this.isMobile,
            items: group.items,
            headers: this.computedHeaders
          });
        } else {
          return this.genDefaultGroupedRow(group.name, group.items, props2);
        }
      });
    },
    genDefaultGroupedRow(group, items, props2) {
      const isOpen = !!this.openCache[group];
      const children = [this.$createElement("template", {
        slot: "row.content"
      }, this.genRows(items, props2))];
      const toggleFn = () => this.$set(this.openCache, group, !this.openCache[group]);
      const removeFn = () => props2.updateOptions({
        groupBy: [],
        groupDesc: []
      });
      if (this.$scopedSlots["group.header"]) {
        children.unshift(this.$createElement("template", {
          slot: "column.header"
        }, [this.$scopedSlots["group.header"]({
          group,
          groupBy: props2.options.groupBy,
          isMobile: this.isMobile,
          items,
          headers: this.computedHeaders,
          isOpen,
          toggle: toggleFn,
          remove: removeFn
        })]));
      } else {
        const toggle = this.$createElement(VBtn_default2, {
          staticClass: "ma-0",
          props: {
            icon: true,
            small: true
          },
          on: {
            click: toggleFn
          }
        }, [this.$createElement(VIcon_default2, [isOpen ? "$minus" : "$plus"])]);
        const remove2 = this.$createElement(VBtn_default2, {
          staticClass: "ma-0",
          props: {
            icon: true,
            small: true
          },
          on: {
            click: removeFn
          }
        }, [this.$createElement(VIcon_default2, ["$close"])]);
        const column = this.$createElement("td", {
          staticClass: "text-start",
          attrs: this.colspanAttrs
        }, [toggle, `${props2.options.groupBy[0]}: ${group}`, remove2]);
        children.unshift(this.$createElement("template", {
          slot: "column.header"
        }, [column]));
      }
      if (this.$scopedSlots["group.summary"]) {
        children.push(this.$createElement("template", {
          slot: "column.summary"
        }, [this.$scopedSlots["group.summary"]({
          group,
          groupBy: props2.options.groupBy,
          isMobile: this.isMobile,
          items,
          headers: this.computedHeaders,
          isOpen,
          toggle: toggleFn
        })]));
      }
      return this.$createElement(RowGroup_default, {
        key: group,
        props: {
          value: isOpen
        }
      }, children);
    },
    genRows(items, props2) {
      return this.$scopedSlots.item ? this.genScopedRows(items, props2) : this.genDefaultRows(items, props2);
    },
    genScopedRows(items, props2) {
      const rows = [];
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        rows.push(this.$scopedSlots.item(__spreadProps(__spreadValues({}, this.createItemProps(item, i)), {
          isMobile: this.isMobile
        })));
        if (this.isExpanded(item)) {
          rows.push(this.$scopedSlots["expanded-item"]({
            headers: this.computedHeaders,
            isMobile: this.isMobile,
            index: i,
            item
          }));
        }
      }
      return rows;
    },
    genDefaultRows(items, props2) {
      return this.$scopedSlots["expanded-item"] ? items.map((item, index2) => this.genDefaultExpandedRow(item, index2)) : items.map((item, index2) => this.genDefaultSimpleRow(item, index2));
    },
    genDefaultExpandedRow(item, index2) {
      const isExpanded = this.isExpanded(item);
      const classes = {
        "v-data-table__expanded v-data-table__expanded__row": isExpanded
      };
      const headerRow = this.genDefaultSimpleRow(item, index2, classes);
      const expandedRow = this.$createElement("tr", {
        staticClass: "v-data-table__expanded v-data-table__expanded__content"
      }, [this.$scopedSlots["expanded-item"]({
        headers: this.computedHeaders,
        isMobile: this.isMobile,
        item
      })]);
      return this.$createElement(RowGroup_default, {
        props: {
          value: isExpanded
        }
      }, [this.$createElement("template", {
        slot: "row.header"
      }, [headerRow]), this.$createElement("template", {
        slot: "row.content"
      }, [expandedRow])]);
    },
    genDefaultSimpleRow(item, index2, classes = {}) {
      const scopedSlots = getPrefixedScopedSlots("item.", this.$scopedSlots);
      const data = this.createItemProps(item, index2);
      if (this.showSelect) {
        const slot = scopedSlots["data-table-select"];
        scopedSlots["data-table-select"] = slot ? () => slot(__spreadProps(__spreadValues({}, data), {
          isMobile: this.isMobile
        })) : () => {
          var _this$checkboxColor;
          return this.$createElement(VSimpleCheckbox_default, {
            staticClass: "v-data-table__checkbox",
            props: {
              value: data.isSelected,
              disabled: !this.isSelectable(item),
              color: (_this$checkboxColor = this.checkboxColor) != null ? _this$checkboxColor : ""
            },
            on: {
              input: (val) => data.select(val)
            }
          });
        };
      }
      if (this.showExpand) {
        const slot = scopedSlots["data-table-expand"];
        scopedSlots["data-table-expand"] = slot ? () => slot(data) : () => this.$createElement(VIcon_default2, {
          staticClass: "v-data-table__expand-icon",
          class: {
            "v-data-table__expand-icon--active": data.isExpanded
          },
          on: {
            click: (e) => {
              e.stopPropagation();
              data.expand(!data.isExpanded);
            }
          }
        }, [this.expandIcon]);
      }
      return this.$createElement(this.isMobile ? MobileRow_default : Row_default, {
        key: getObjectValueByPath(item, this.itemKey),
        class: mergeClasses(__spreadProps(__spreadValues({}, classes), {
          "v-data-table__selected": data.isSelected
        }), getPropertyFromItem(item, this.itemClass)),
        props: {
          headers: this.computedHeaders,
          hideDefaultHeader: this.hideDefaultHeader,
          index: index2,
          item,
          rtl: this.$vuetify.rtl
        },
        scopedSlots,
        on: {
          click: () => this.$emit("click:row", item, data),
          contextmenu: (event) => this.$emit("contextmenu:row", event, data),
          dblclick: (event) => this.$emit("dblclick:row", event, data)
        }
      });
    },
    genBody(props2) {
      const data = __spreadProps(__spreadValues({}, props2), {
        expand: this.expand,
        headers: this.computedHeaders,
        isExpanded: this.isExpanded,
        isMobile: this.isMobile,
        isSelected: this.isSelected,
        select: this.select
      });
      if (this.$scopedSlots.body) {
        return this.$scopedSlots.body(data);
      }
      return this.$createElement("tbody", [getSlot(this, "body.prepend", data, true), this.genItems(props2.items, props2), getSlot(this, "body.append", data, true)]);
    },
    genFoot(props2) {
      var _this$$scopedSlots$fo, _this$$scopedSlots;
      return (_this$$scopedSlots$fo = (_this$$scopedSlots = this.$scopedSlots).foot) == null ? void 0 : _this$$scopedSlots$fo.call(_this$$scopedSlots, props2);
    },
    genFooters(props2) {
      const data = {
        props: __spreadValues({
          options: props2.options,
          pagination: props2.pagination,
          itemsPerPageText: "$vuetify.dataTable.itemsPerPageText"
        }, this.sanitizedFooterProps),
        on: {
          "update:options": (value) => props2.updateOptions(value)
        },
        widths: this.widths,
        headers: this.computedHeaders
      };
      const children = [getSlot(this, "footer", data, true)];
      if (!this.hideDefaultFooter) {
        children.push(this.$createElement(VDataFooter_default, __spreadProps(__spreadValues({}, data), {
          scopedSlots: getPrefixedScopedSlots("footer.", this.$scopedSlots)
        })));
      }
      return children;
    },
    genDefaultScopedSlot(props2) {
      const simpleProps = {
        height: this.height,
        fixedHeader: this.fixedHeader,
        dense: this.dense
      };
      return this.$createElement(VSimpleTable_default, {
        props: simpleProps,
        class: {
          "v-data-table--mobile": this.isMobile
        }
      }, [this.proxySlot("top", getSlot(this, "top", __spreadProps(__spreadValues({}, props2), {
        isMobile: this.isMobile
      }), true)), this.genCaption(props2), this.genColgroup(props2), this.genHeaders(props2), this.genBody(props2), this.genFoot(props2), this.proxySlot("bottom", this.genFooters(props2))]);
    },
    proxySlot(slot, content) {
      return this.$createElement("template", {
        slot
      }, content);
    }
  },
  render() {
    return this.$createElement(VData_default, {
      props: __spreadProps(__spreadValues({}, this.$props), {
        customFilter: this.customFilterWithColumns,
        customSort: this.customSortWithHeaders,
        itemsPerPage: this.computedItemsPerPage
      }),
      on: {
        "update:options": (v, old) => {
          this.internalGroupBy = v.groupBy || [];
          !deepEqual(v, old) && this.$emit("update:options", v);
        },
        "update:page": (v) => this.$emit("update:page", v),
        "update:items-per-page": (v) => this.$emit("update:items-per-page", v),
        "update:sort-by": (v) => this.$emit("update:sort-by", v),
        "update:sort-desc": (v) => this.$emit("update:sort-desc", v),
        "update:group-by": (v) => this.$emit("update:group-by", v),
        "update:group-desc": (v) => this.$emit("update:group-desc", v),
        pagination: (v, old) => !deepEqual(v, old) && this.$emit("pagination", v),
        "current-items": (v) => {
          this.internalCurrentItems = v;
          this.$emit("current-items", v);
        },
        "page-count": (v) => this.$emit("page-count", v)
      },
      scopedSlots: {
        default: this.genDefaultScopedSlot
      }
    });
  }
});

// node_modules/vuetify/lib/components/VDataTable/index.js
var VTableOverflow = createSimpleFunctional("v-table__overflow");

// node_modules/vuetify/lib/components/VGrid/grid.js
function VGrid(name) {
  return vue_runtime_esm_default.extend({
    name: `v-${name}`,
    functional: true,
    props: {
      id: String,
      tag: {
        type: String,
        default: "div"
      }
    },
    render(h, {
      props: props2,
      data,
      children
    }) {
      data.staticClass = `${name} ${data.staticClass || ""}`.trim();
      const {
        attrs: attrs2
      } = data;
      if (attrs2) {
        data.attrs = {};
        const classes = Object.keys(attrs2).filter((key) => {
          if (key === "slot")
            return false;
          const value = attrs2[key];
          if (key.startsWith("data-")) {
            data.attrs[key] = value;
            return false;
          }
          return value || typeof value === "string";
        });
        if (classes.length)
          data.staticClass += ` ${classes.join(" ")}`;
      }
      if (props2.id) {
        data.domProps = data.domProps || {};
        data.domProps.id = props2.id;
      }
      return h(props2.tag, data, children);
    }
  });
}

// node_modules/vuetify/lib/components/VGrid/VContainer.js
var VContainer_default = VGrid("container").extend({
  name: "v-container",
  functional: true,
  props: {
    id: String,
    tag: {
      type: String,
      default: "div"
    },
    fluid: {
      type: Boolean,
      default: false
    }
  },
  render(h, {
    props: props2,
    data,
    children
  }) {
    let classes;
    const {
      attrs: attrs2
    } = data;
    if (attrs2) {
      data.attrs = {};
      classes = Object.keys(attrs2).filter((key) => {
        if (key === "slot")
          return false;
        const value = attrs2[key];
        if (key.startsWith("data-")) {
          data.attrs[key] = value;
          return false;
        }
        return value || typeof value === "string";
      });
    }
    if (props2.id) {
      data.domProps = data.domProps || {};
      data.domProps.id = props2.id;
    }
    return h(props2.tag, mergeData2(data, {
      staticClass: "container",
      class: Array({
        "container--fluid": props2.fluid
      }).concat(classes || [])
    }), children);
  }
});

// node_modules/vuetify/lib/components/VGrid/VCol.js
var breakpoints = ["sm", "md", "lg", "xl"];
var breakpointProps = (() => {
  return breakpoints.reduce((props2, val) => {
    props2[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props2;
  }, {});
})();
var offsetProps = (() => {
  return breakpoints.reduce((props2, val) => {
    props2["offset" + upperFirst(val)] = {
      type: [String, Number],
      default: null
    };
    return props2;
  }, {});
})();
var orderProps = (() => {
  return breakpoints.reduce((props2, val) => {
    props2["order" + upperFirst(val)] = {
      type: [String, Number],
      default: null
    };
    return props2;
  }, {});
})();
var propMap = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};
function breakpointClass(type2, prop, val) {
  let className = type2;
  if (val == null || val === false) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type2, "");
    className += `-${breakpoint}`;
  }
  if (type2 === "col" && (val === "" || val === true)) {
    return className.toLowerCase();
  }
  className += `-${val}`;
  return className.toLowerCase();
}
var cache = new Map();
var VCol_default = vue_runtime_esm_default.extend({
  name: "v-col",
  functional: true,
  props: __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    cols: {
      type: [Boolean, String, Number],
      default: false
    }
  }, breakpointProps), {
    offset: {
      type: [String, Number],
      default: null
    }
  }), offsetProps), {
    order: {
      type: [String, Number],
      default: null
    }
  }), orderProps), {
    alignSelf: {
      type: String,
      default: null,
      validator: (str) => ["auto", "start", "end", "center", "baseline", "stretch"].includes(str)
    },
    tag: {
      type: String,
      default: "div"
    }
  }),
  render(h, {
    props: props2,
    data,
    children,
    parent
  }) {
    let cacheKey = "";
    for (const prop in props2) {
      cacheKey += String(props2[prop]);
    }
    let classList = cache.get(cacheKey);
    if (!classList) {
      classList = [];
      let type2;
      for (type2 in propMap) {
        propMap[type2].forEach((prop) => {
          const value = props2[prop];
          const className = breakpointClass(type2, prop, value);
          if (className)
            classList.push(className);
        });
      }
      const hasColClasses = classList.some((className) => className.startsWith("col-"));
      classList.push({
        col: !hasColClasses || !props2.cols,
        [`col-${props2.cols}`]: props2.cols,
        [`offset-${props2.offset}`]: props2.offset,
        [`order-${props2.order}`]: props2.order,
        [`align-self-${props2.alignSelf}`]: props2.alignSelf
      });
      cache.set(cacheKey, classList);
    }
    return h(props2.tag, mergeData2(data, {
      class: classList
    }), children);
  }
});

// node_modules/vuetify/lib/components/VGrid/VRow.js
var breakpoints2 = ["sm", "md", "lg", "xl"];
var ALIGNMENT = ["start", "end", "center"];
function makeProps(prefix, def2) {
  return breakpoints2.reduce((props2, val) => {
    props2[prefix + upperFirst(val)] = def2();
    return props2;
  }, {});
}
var alignValidator = (str) => [...ALIGNMENT, "baseline", "stretch"].includes(str);
var alignProps = makeProps("align", () => ({
  type: String,
  default: null,
  validator: alignValidator
}));
var justifyValidator = (str) => [...ALIGNMENT, "space-between", "space-around"].includes(str);
var justifyProps = makeProps("justify", () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));
var alignContentValidator = (str) => [...ALIGNMENT, "space-between", "space-around", "stretch"].includes(str);
var alignContentProps = makeProps("alignContent", () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
var propMap2 = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
var classMap = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function breakpointClass2(type2, prop, val) {
  let className = classMap[type2];
  if (val == null) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type2, "");
    className += `-${breakpoint}`;
  }
  className += `-${val}`;
  return className.toLowerCase();
}
var cache2 = new Map();
var VRow_default = vue_runtime_esm_default.extend({
  name: "v-row",
  functional: true,
  props: __spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({
    tag: {
      type: String,
      default: "div"
    },
    dense: Boolean,
    noGutters: Boolean,
    align: {
      type: String,
      default: null,
      validator: alignValidator
    }
  }, alignProps), {
    justify: {
      type: String,
      default: null,
      validator: justifyValidator
    }
  }), justifyProps), {
    alignContent: {
      type: String,
      default: null,
      validator: alignContentValidator
    }
  }), alignContentProps),
  render(h, {
    props: props2,
    data,
    children
  }) {
    let cacheKey = "";
    for (const prop in props2) {
      cacheKey += String(props2[prop]);
    }
    let classList = cache2.get(cacheKey);
    if (!classList) {
      classList = [];
      let type2;
      for (type2 in propMap2) {
        propMap2[type2].forEach((prop) => {
          const value = props2[prop];
          const className = breakpointClass2(type2, prop, value);
          if (className)
            classList.push(className);
        });
      }
      classList.push({
        "no-gutters": props2.noGutters,
        "row--dense": props2.dense,
        [`align-${props2.align}`]: props2.align,
        [`justify-${props2.justify}`]: props2.justify,
        [`align-content-${props2.alignContent}`]: props2.alignContent
      });
      cache2.set(cacheKey, classList);
    }
    return h(props2.tag, mergeData2(data, {
      staticClass: "row",
      class: classList
    }), children);
  }
});

// node_modules/vuetify/lib/components/VGrid/VSpacer.js
var VSpacer_default = createSimpleFunctional("spacer", "div", "v-spacer");

// node_modules/vuetify/lib/components/VRating/VRating.js
var VRating_default = mixins(colorable_default, delayable_default, rippleable_default, sizeable_default, themeable_default).extend({
  name: "v-rating",
  props: {
    backgroundColor: {
      type: String,
      default: "accent"
    },
    color: {
      type: String,
      default: "primary"
    },
    clearable: Boolean,
    dense: Boolean,
    emptyIcon: {
      type: String,
      default: "$ratingEmpty"
    },
    fullIcon: {
      type: String,
      default: "$ratingFull"
    },
    halfIcon: {
      type: String,
      default: "$ratingHalf"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
      type: [Number, String],
      default: 5
    },
    readonly: Boolean,
    size: [Number, String],
    value: {
      type: Number,
      default: 0
    },
    iconLabel: {
      type: String,
      default: "$vuetify.rating.ariaLabel.icon"
    }
  },
  data() {
    return {
      hoverIndex: -1,
      internalValue: this.value
    };
  },
  computed: {
    directives() {
      if (this.readonly || !this.ripple)
        return [];
      return [{
        name: "ripple",
        value: {
          circle: true
        }
      }];
    },
    iconProps() {
      const {
        dark,
        large,
        light,
        medium,
        small,
        size,
        xLarge,
        xSmall
      } = this.$props;
      return {
        dark,
        large,
        light,
        medium,
        size,
        small,
        xLarge,
        xSmall
      };
    },
    isHovering() {
      return this.hover && this.hoverIndex >= 0;
    }
  },
  watch: {
    internalValue(val) {
      val !== this.value && this.$emit("input", val);
    },
    value(val) {
      this.internalValue = val;
    }
  },
  methods: {
    createClickFn(i) {
      return (e) => {
        if (this.readonly)
          return;
        const newValue = this.genHoverIndex(e, i);
        if (this.clearable && this.internalValue === newValue) {
          this.internalValue = 0;
        } else {
          this.internalValue = newValue;
        }
      };
    },
    createProps(i) {
      const props2 = {
        index: i,
        value: this.internalValue,
        click: this.createClickFn(i),
        isFilled: Math.floor(this.internalValue) > i,
        isHovered: Math.floor(this.hoverIndex) > i
      };
      if (this.halfIncrements) {
        props2.isHalfHovered = !props2.isHovered && (this.hoverIndex - i) % 1 > 0;
        props2.isHalfFilled = !props2.isFilled && (this.internalValue - i) % 1 > 0;
      }
      return props2;
    },
    genHoverIndex(e, i) {
      let isHalf = this.isHalfEvent(e);
      if (this.halfIncrements && this.$vuetify.rtl) {
        isHalf = !isHalf;
      }
      return i + (isHalf ? 0.5 : 1);
    },
    getIconName(props2) {
      const isFull = this.isHovering ? props2.isHovered : props2.isFilled;
      const isHalf = this.isHovering ? props2.isHalfHovered : props2.isHalfFilled;
      return isFull ? this.fullIcon : isHalf ? this.halfIcon : this.emptyIcon;
    },
    getColor(props2) {
      if (this.isHovering) {
        if (props2.isHovered || props2.isHalfHovered)
          return this.color;
      } else {
        if (props2.isFilled || props2.isHalfFilled)
          return this.color;
      }
      return this.backgroundColor;
    },
    isHalfEvent(e) {
      if (this.halfIncrements) {
        const rect = e.target && e.target.getBoundingClientRect();
        if (rect && e.pageX - rect.left < rect.width / 2)
          return true;
      }
      return false;
    },
    onMouseEnter(e, i) {
      this.runDelay("open", () => {
        this.hoverIndex = this.genHoverIndex(e, i);
      });
    },
    onMouseLeave() {
      this.runDelay("close", () => this.hoverIndex = -1);
    },
    genItem(i) {
      const props2 = this.createProps(i);
      if (this.$scopedSlots.item)
        return this.$scopedSlots.item(props2);
      const listeners = {
        click: props2.click
      };
      if (this.hover) {
        listeners.mouseenter = (e) => this.onMouseEnter(e, i);
        listeners.mouseleave = this.onMouseLeave;
        if (this.halfIncrements) {
          listeners.mousemove = (e) => this.onMouseEnter(e, i);
        }
      }
      return this.$createElement(VIcon_default2, this.setTextColor(this.getColor(props2), {
        attrs: {
          "aria-label": this.$vuetify.lang.t(this.iconLabel, i + 1, Number(this.length))
        },
        directives: this.directives,
        props: this.iconProps,
        on: listeners
      }), [this.getIconName(props2)]);
    }
  },
  render(h) {
    const children = createRange(Number(this.length)).map((i) => this.genItem(i));
    return h("div", {
      staticClass: "v-rating",
      class: {
        "v-rating--readonly": this.readonly,
        "v-rating--dense": this.dense
      }
    }, children);
  }
});

// src/components/Table.vue
var __vue_script__2 = vue_runtime_esm_default.extend({
  components: {
    VAlert: VAlert_default,
    VDataTable: VDataTable_default,
    VApp: VApp_default,
    VTextField: VTextField_default,
    VRating: VRating_default,
    VSlider: VSlider_default,
    MarkdownLink: MarkdownLink_default,
    VSelect: VSelect_default,
    VSimpleCheckbox: VSimpleCheckbox_default,
    VCombobox: VCombobox_default,
    VChip: VChip_default,
    VIcon: VIcon_default,
    VBtn: VBtn_default,
    VImg: VImg_default,
    VRow: VRow_default,
    VCol: VCol_default,
    VSpacer: VSpacer_default,
    VContainer: VContainer_default
  },
  directives: {
    Ripple
  },
  props: {
    fields: [],
    groupBy: [],
    sources: [],
    rows: [],
    sortBy: [],
    urlBase: String
  },
  data() {
    return {
      newFileName: ""
    };
  },
  computed: {
    headers() {
      return this.fields.map((f) => {
        return {
          text: f.label || f.name,
          value: f.name
        };
      });
    },
    addSources() {
      return this.sources.filter((s) => "addRow" in s);
    }
  },
  methods: {
    addRow() {
      return __async(this, null, function* () {
        const addSources = this.addSources;
        if (addSources.length == 1) {
          yield addSources[0].addRow(this.newFileName);
        }
        this.$emit("refresh");
      });
    },
    rowDeleted(row) {
      return __async(this, null, function* () {
        yield row._source.deleteRow(row._file);
        this.$emit("refresh");
      });
    },
    fieldUpdated(row, field) {
      return __async(this, null, function* () {
        console.log(`updated field ${field} on ${row._file.path}`);
        yield row._source.setData(row._file, field, row[field]);
      });
    },
    linkUpdated(row, field) {
      return __async(this, null, function* () {
        console.log(`updated link ${field} on ${row._file.path}`);
        if (!Array.isArray(row[field]) && row[field] != null) {
          row[field] = [row[field]];
        }
        yield row._source.setLink(row._file, field, row[field]);
      });
    },
    getCellStyle(field, row) {
      const fieldValue = row[field.name];
      if (field.type == "dropdown") {
        const selectedOption = field.options.filter((x) => x.value == fieldValue).first();
        if (selectedOption && selectedOption.color) {
          return `background-color: ${selectedOption.color}`;
        }
      }
      return "";
    },
    isFontWhite(field, row) {
      const fieldValue = row[field.name];
      if (field.type == "dropdown") {
        const selectedOption = field.options.filter((x) => x.value == fieldValue).first();
        if (selectedOption && selectedOption.color) {
          return selectedOption.dark || new TinyColor(selectedOption.color).isDark();
        }
      }
      return false;
    },
    getFieldByName(name) {
      return this.fields.filter((f) => f.name == name).first();
    },
    getFieldSelectedOption(fieldName, optionValue) {
      return this.getFieldByName(fieldName).options.filter((o) => o.value == optionValue).first();
    }
  }
});
var __vue_render__2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("v-data-table", {
    staticClass: "ma-0 pa-0",
    attrs: {
      headers: _vm.headers,
      items: _vm.rows,
      "hide-default-footer": "",
      dense: "",
      "group-by": _vm.groupBy,
      "item-key": "_file.path",
      "multi-sort": "",
      "sort-by": _vm.sortBy,
      "items-per-page": -1
    },
    scopedSlots: _vm._u([
      {
        key: "item",
        fn: function(ref2) {
          var item = ref2.item;
          return [
            _c("tr", {
              attrs: {
                "data-category-id": item._file.path,
                "data-id": item._file.path
              }
            }, _vm._l(_vm.fields, function(field) {
              return _c("td", {
                key: field.name,
                style: _vm.getCellStyle(field, item),
                attrs: { width: field.width || "" }
              }, [
                field.type == "fileName" ? _c("markdown-link", {
                  attrs: { href: item._file.name }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "filePath" ? _c("markdown-link", {
                  attrs: { href: item._file.name }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "delete" ? _c("v-btn", {
                  attrs: { icon: "", "x-small": "" },
                  on: {
                    click: function($event) {
                      return _vm.rowDeleted(item);
                    }
                  }
                }, [_c("v-icon", [_vm._v("mdi-delete-outline")])], 1) : _vm._e(),
                _vm._v(" "),
                field.type == "image" && item[field.name] ? _c("v-img", {
                  attrs: {
                    src: "app://local/" + _vm.urlBase + "/" + item[field.name],
                    "max-width": field.maxWidth,
                    "max-height": field.maxHeigh
                  }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "link" ? _c("v-combobox", {
                  attrs: {
                    items: field._sourceAutocomplete || [],
                    "hide-details": "",
                    dense: "",
                    multiple: field.multiple
                  },
                  on: {
                    change: function($event) {
                      return _vm.linkUpdated(item, field.name);
                    }
                  },
                  scopedSlots: _vm._u([
                    {
                      key: "selection",
                      fn: function(ref3) {
                        var item2 = ref3.item;
                        return [
                          field.multiple ? _c("v-chip", { attrs: { small: "" } }, [
                            _c("markdown-link", {
                              attrs: {
                                href: Array.isArray(item2) ? item2[0] : item2
                              }
                            })
                          ], 1) : _c("markdown-link", {
                            key: item2.join(","),
                            attrs: {
                              href: Array.isArray(item2) ? item2[0] : item2
                            }
                          })
                        ];
                      }
                    }
                  ], null, true),
                  model: {
                    value: item[field.name],
                    callback: function($$v) {
                      _vm.$set(item, field.name, $$v);
                    },
                    expression: "item[field.name]"
                  }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "rating" ? _c("v-rating", {
                  attrs: {
                    hover: "",
                    "half-increments": "",
                    dense: "",
                    value: 1 * (item[field.name] || 0)
                  },
                  on: {
                    input: function($event) {
                      item[field.name] = $event;
                      _vm.fieldUpdated(item, field.name);
                    }
                  }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "progress" ? _c("v-slider", {
                  attrs: { dense: "", "hide-details": "" },
                  on: {
                    end: function($event) {
                      return _vm.fieldUpdated(item, field.name);
                    }
                  },
                  model: {
                    value: item[field.name],
                    callback: function($$v) {
                      _vm.$set(item, field.name, $$v);
                    },
                    expression: "item[field.name]"
                  }
                }) : _vm._e(),
                _vm._v(" "),
                !field.type || field.type != "dropdown" && field.type != "link" && field.type != "progress" && field.type != "fileName" && field.type != "filePath" && field.type != "checkbox" && field.type != "delete" && field.type != "image" && field.type != "rating" ? _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model.lazy",
                      value: item[field.name],
                      expression: "item[field.name]",
                      modifiers: { lazy: true }
                    }
                  ],
                  attrs: {
                    type: field.type,
                    placeholder: "" + (field.default || "")
                  },
                  domProps: { value: item[field.name] },
                  on: {
                    change: [
                      function($event) {
                        return _vm.$set(item, field.name, $event.target.value);
                      },
                      function($event) {
                        return _vm.fieldUpdated(item, field.name);
                      }
                    ]
                  }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "checkbox" ? _c("v-simple-checkbox", {
                  attrs: { "hide-details": "", dense: "" },
                  on: {
                    input: function($event) {
                      return _vm.fieldUpdated(item, field.name);
                    }
                  },
                  model: {
                    value: item[field.name],
                    callback: function($$v) {
                      _vm.$set(item, field.name, $$v);
                    },
                    expression: "item[field.name]"
                  }
                }) : _vm._e(),
                _vm._v(" "),
                field.type == "dropdown" ? _c("v-select", {
                  attrs: {
                    items: field.options,
                    "hide-details": "",
                    "item-text": "label",
                    "item-value": "value",
                    dense: "",
                    dark: _vm.isFontWhite(field, item),
                    "small-chips": field.multiple != null && field.multiple != false,
                    multiple: field.multiple != null && field.multiple != false,
                    chips: field.multiple != null && field.multiple != false
                  },
                  on: {
                    change: function($event) {
                      return _vm.fieldUpdated(item, field.name);
                    }
                  },
                  model: {
                    value: item[field.name],
                    callback: function($$v) {
                      _vm.$set(item, field.name, $$v);
                    },
                    expression: "item[field.name]"
                  }
                }) : _vm._e()
              ], 1);
            }), 0)
          ];
        }
      },
      {
        key: "group.header",
        fn: function(ref2) {
          var groupBy = ref2.groupBy;
          var group = ref2.group;
          var isOpen = ref2.isOpen;
          var toggle = ref2.toggle;
          var remove2 = ref2.remove;
          return [
            _c("td", { attrs: { colspan: _vm.headers.length } }, [
              _c("v-icon", { on: { click: toggle } }, [
                _vm._v("\n        " + _vm._s(isOpen ? "mdi-minus" : "mdi-plus") + "\n      ")
              ]),
              _vm._v(" "),
              _c("span", [
                _vm._v(_vm._s(_vm.getFieldByName(groupBy[0]).label) + " :\n        " + _vm._s(_vm.getFieldSelectedOption(groupBy[0], group).label))
              ])
            ], 1)
          ];
        }
      },
      _vm.addSources.length > 0 ? {
        key: "body.append",
        fn: function(ref2) {
          var headers = ref2.headers;
          return [
            _c("tr", [
              _c("td", {
                staticStyle: {
                  "text-align": "center",
                  "background-color": "white"
                },
                attrs: { colspan: headers.length }
              }, [
                _c("v-row", {
                  staticClass: "ma-0 pa-0",
                  attrs: { "no-gutters": "", dense: "" }
                }, [
                  _c("v-spacer"),
                  _vm._v(" "),
                  _c("v-col", {
                    staticClass: "pa-0 ma-0",
                    attrs: { cols: "4" }
                  }, [
                    _c("v-text-field", {
                      attrs: {
                        "append-outer-icon": "mdi-plus-circle-outline",
                        placeholder: "new file name",
                        type: "text",
                        "hide-details": "",
                        solo: "",
                        flat: "",
                        "single-line": ""
                      },
                      on: {
                        keydown: function($event) {
                          if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
                            return null;
                          }
                          return _vm.addRow.apply(null, arguments);
                        },
                        "click:append-outer": _vm.addRow
                      },
                      model: {
                        value: _vm.newFileName,
                        callback: function($$v) {
                          _vm.newFileName = $$v;
                        },
                        expression: "newFileName"
                      }
                    })
                  ], 1),
                  _vm._v(" "),
                  _c("v-spacer")
                ], 1)
              ], 1)
            ])
          ];
        }
      } : null
    ], null, true)
  });
};
var __vue_staticRenderFns__2 = [];
__vue_render__2._withStripped = true;
var __vue_inject_styles__2 = void 0;
var __vue_scope_id__2 = "data-v-2c3e871c";
var __vue_module_identifier__2 = void 0;
var __vue_is_functional_template__2 = false;
function __vue_normalize__2(template, style2, script, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  const component = (typeof script === "function" ? script.options : script) || {};
  component.__file = "src/components/Table.vue";
  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional)
      component.functional = true;
  }
  component._scopeId = scope;
  if (false) {
    let hook;
    if (false) {
      hook = function(context) {
        context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style2) {
          style2.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      component._ssrRegister = hook;
    } else if (style2) {
      hook = shadowMode ? function(context) {
        style2.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
      } : function(context) {
        style2.call(this, createInjector(context));
      };
    }
    if (hook !== void 0) {
      if (component.functional) {
        const originalRender = component.render;
        component.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        const existing = component.beforeCreate;
        component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
  }
  return component;
}
var __vue_component__2 = /* @__PURE__ */ __vue_normalize__2({ render: __vue_render__2, staticRenderFns: __vue_staticRenderFns__2 }, __vue_inject_styles__2, __vue_script__2, __vue_scope_id__2, __vue_is_functional_template__2, __vue_module_identifier__2, false, void 0, void 0, void 0);
var Table_default = __vue_component__2;

// src/source.ts
var import_obsidian2 = __toModule(require("obsidian"));
var import_obsidian3 = __toModule(require("obsidian"));
var mapSources = (sources, app, ignoreFilters) => {
  return sources.map((s) => {
    switch (s.type) {
      case "directory":
        return new DirectorySource(s.path, app.vault, app.metadataCache, ignoreFilters);
      case "tags":
        return new TagsSource(s.tags, app.vault, app.metadataCache, ignoreFilters);
      case "related":
        return new RelatedSource(app.workspace.getActiveFile().path, s.tags, app.vault, app.metadataCache, ignoreFilters);
      case "self":
        return new SelfSource(app.workspace.getActiveFile(), app.vault, app.metadataCache, ignoreFilters);
    }
  });
};
var FileSystemSource = class {
  constructor(vault, metadataCache, ignoreFilters) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.ignoreFilters = ignoreFilters;
  }
  matchIgnoreFilters(path) {
    for (let filter of this.ignoreFilters) {
      if (filter && path.match(filter)) {
        return true;
      }
    }
    return false;
  }
  loadData() {
    return __async(this, null, function* () {
      const files = this.getFiles();
      const rows = [];
      for (let f of files) {
        if (this.matchIgnoreFilters(f.path)) {
          continue;
        }
        const links = yield this.readLinks(f);
        rows.push(__spreadProps(__spreadValues(__spreadValues({}, this.metadataCache.getFileCache(f).frontmatter), links), {
          _file: f,
          _source: this
        }));
      }
      return Promise.resolve(rows);
    });
  }
  readLinks(file) {
    return __async(this, null, function* () {
      let content = yield this.vault.read(file);
      const startIndex = content.indexOf("%%%");
      const endIndex = content.indexOf("%%%", startIndex + 3);
      if (startIndex == -1) {
        return Promise.resolve({});
      }
      const linksContent = content.substring(startIndex + 3, endIndex);
      const linksObj = (0, import_obsidian3.parseYaml)(linksContent) || {};
      for (let k in linksObj) {
        if (!Array.isArray(linksObj[k])) {
          linksObj[k] = linksObj[k].split(",");
        }
        for (let i in linksObj[k]) {
          linksObj[k][i] = linksObj[k][i].replaceAll("[[", "").replaceAll("]]", "");
        }
      }
      return Promise.resolve(linksObj);
    });
  }
  setLink(file, field, value) {
    return __async(this, null, function* () {
      let content = yield this.vault.cachedRead(file);
      const startIndex = content.indexOf("%%%");
      const endIndex = content.indexOf("%%%", startIndex + 3);
      let beforeLinksContent = "";
      let linksContent = "";
      let afterLinksContent = "";
      if (startIndex == -1) {
        const frontmatter = this.metadataCache.getFileCache(file).frontmatter;
        if (frontmatter) {
          beforeLinksContent = content.substring(0, frontmatter.position.end.offset + 1);
          afterLinksContent = content.substring(frontmatter.position.end.offset);
        } else {
          afterLinksContent = content;
        }
      } else {
        beforeLinksContent = content.substring(0, startIndex);
        linksContent = content.substring(startIndex + 3, endIndex);
        afterLinksContent = content.substring(endIndex + 3);
      }
      const linksObj = (0, import_obsidian3.parseYaml)(linksContent) || {};
      if (!Array.isArray(value) && value != null) {
        value = [value];
      }
      if (value == null) {
        value = [];
      }
      linksObj[field] = value.filter((x) => x != null).map((x) => `[[${x.trim()}]]`);
      if (linksObj[field].length == 1) {
        linksObj[field] = linksObj[field][0];
      }
      let outFileContents = "";
      outFileContents += beforeLinksContent;
      outFileContents += "%%%\n";
      outFileContents += (0, import_obsidian2.stringifyYaml)(linksObj);
      outFileContents += "%%%";
      outFileContents += afterLinksContent;
      yield this.vault.modify(file, outFileContents);
      return Promise.resolve();
    });
  }
  setData(file, field, value) {
    return __async(this, null, function* () {
      let contentWithoutFrontmatter = yield this.vault.cachedRead(file);
      let frontmatterContent = "";
      const frontmatter = this.metadataCache.getFileCache(file).frontmatter;
      if (frontmatter) {
        frontmatterContent = contentWithoutFrontmatter.substring(frontmatter.position.start.offset + 3, frontmatter.position.end.offset - 3);
        contentWithoutFrontmatter = contentWithoutFrontmatter.substring(frontmatter.position.end.offset);
      }
      const frontmatterObj = (0, import_obsidian3.parseYaml)(frontmatterContent) || {};
      frontmatterObj[field] = value;
      let outFileContents = "---\n";
      outFileContents += (0, import_obsidian2.stringifyYaml)(frontmatterObj);
      outFileContents += "---";
      if (!frontmatter) {
        outFileContents += "\n";
      }
      outFileContents += contentWithoutFrontmatter;
      yield this.vault.modify(file, outFileContents);
      return Promise.resolve();
    });
  }
  deleteRow(file) {
    return __async(this, null, function* () {
      return this.vault.delete(file);
    });
  }
};
var DirectorySource = class extends FileSystemSource {
  constructor(path, vault, metadataCache, ignoreFilters) {
    super(vault, metadataCache, ignoreFilters);
    this.path = path;
  }
  addRow(name) {
    return this.vault.create(this.path + "/" + name + ".md", "");
  }
  getFiles() {
    return this.vault.getMarkdownFiles().filter((f) => f.path.startsWith(this.path));
  }
};
var SelfSource = class extends FileSystemSource {
  constructor(file, vault, metadataCache, ignoreFilters) {
    super(vault, metadataCache, ignoreFilters);
    this.file = file;
  }
  getFiles() {
    return [this.file];
  }
};
var TagsSource = class extends FileSystemSource {
  constructor(tags, vault, metadataCache, ignoreFilters) {
    super(vault, metadataCache, ignoreFilters);
    this.tags = tags;
  }
  getFiles() {
    return filterByTags(this.vault.getMarkdownFiles(), this.tags, this.metadataCache);
  }
  addRow(name) {
    return this.vault.create(name + ".md", `---
tags: ${this.tags.join(", ")}
---
`);
  }
};
var RelatedSource = class extends FileSystemSource {
  constructor(currentFile, tags, vault, metadataCache, ignoreFilters) {
    super(vault, metadataCache, ignoreFilters);
    this.currentFile = currentFile;
    this.tags = tags;
  }
  getFiles() {
    const files = [];
    for (const k in this.metadataCache.resolvedLinks) {
      if (this.metadataCache.resolvedLinks[k][this.currentFile]) {
        files.push(k);
      }
    }
    return filterByTags(this.vault.getMarkdownFiles().filter((x) => files.contains(x.path)), this.tags, this.metadataCache);
  }
};
function filterByTags(files, tags, metadataCache) {
  if (tags == null || tags.length == 0) {
    return files;
  }
  return files.map((f) => {
    var _a, _b;
    let fmTags = ((_b = (_a = metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.tags) || "";
    if (!Array.isArray(fmTags)) {
      fmTags = fmTags.split(",").map((x) => x.trim());
    }
    return {
      tags: fmTags,
      file: f
    };
  }).filter((x) => x.tags.some((r) => tags.contains(r))).map((x) => x.file);
}

// src/App.vue
var import_obsidian4 = __toModule(require("obsidian"));
var __vue_script__3 = {
  name: "App",
  components: {
    Table: Table_default,
    VApp: VApp_default
  },
  data() {
    return {
      rows: [],
      sources: [],
      finalParameters: {}
    };
  },
  props: {
    app: import_obsidian4.App,
    parameters: {},
    settings: {},
    urlBase: String
  },
  created() {
    return __async(this, null, function* () {
      yield this.refresh();
    });
  },
  methods: {
    refresh() {
      return __async(this, null, function* () {
        this.finalParameters = __spreadValues({}, this.parameters);
        if (this.finalParameters.include) {
          if (!Array.isArray(this.finalParameters.include)) {
            this.finalParameters.include = this.parameters.include.split(",");
          }
          for (let i of this.finalParameters.include) {
            let fm = this.app.metadataCache.getCache(i).frontmatter;
            this.finalParameters = __spreadValues(__spreadValues({}, this.finalParameters), fm);
          }
        }
        for (let f of this.finalParameters.fields.filter((f2) => f2.type == "link" && f2.sources != null)) {
          const fieldSources = mapSources(f.sources, this.app, this.settings.globalIgnoreFilters);
          let autocomplete = (yield Promise.all(fieldSources.map((x) => x.loadData()))).flat().map((x) => x._file.name.replace(".md", ""));
          f._sourceAutocomplete = autocomplete;
        }
        this.sources = mapSources(this.finalParameters.sources, this.app, this.settings.globalIgnoreFilters);
        this.rows = (yield Promise.all(this.sources.map((x) => x.loadData()))).flat();
      });
    }
  }
};
var __vue_render__3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("v-app", [
    _c("Table", {
      key: _vm.rows.length,
      attrs: {
        fields: _vm.finalParameters.fields,
        groupBy: _vm.finalParameters.groupBy,
        sortBy: _vm.finalParameters.sortBy,
        rows: _vm.rows,
        sources: _vm.sources,
        urlBase: _vm.urlBase
      },
      on: { refresh: _vm.refresh }
    })
  ], 1);
};
var __vue_staticRenderFns__3 = [];
__vue_render__3._withStripped = true;
var __vue_inject_styles__3 = void 0;
var __vue_scope_id__3 = void 0;
var __vue_module_identifier__3 = void 0;
var __vue_is_functional_template__3 = false;
function __vue_normalize__3(template, style2, script, scope, functional, moduleIdentifier, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  const component = (typeof script === "function" ? script.options : script) || {};
  component.__file = "src/App.vue";
  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional)
      component.functional = true;
  }
  component._scopeId = scope;
  if (false) {
    let hook;
    if (false) {
      hook = function(context) {
        context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style2) {
          style2.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      component._ssrRegister = hook;
    } else if (style2) {
      hook = shadowMode ? function(context) {
        style2.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
      } : function(context) {
        style2.call(this, createInjector(context));
      };
    }
    if (hook !== void 0) {
      if (component.functional) {
        const originalRender = component.render;
        component.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        const existing = component.beforeCreate;
        component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
  }
  return component;
}
var __vue_component__3 = /* @__PURE__ */ __vue_normalize__3({ render: __vue_render__3, staticRenderFns: __vue_staticRenderFns__3 }, __vue_inject_styles__3, __vue_script__3, __vue_scope_id__3, __vue_is_functional_template__3, __vue_module_identifier__3, false, void 0, void 0, void 0);
var App_default = __vue_component__3;

// src/vuetify.ts
vue_runtime_esm_default.use(Vuetify);
var vuetify_default = new Vuetify({
  icons: {
    iconfont: "mdi"
  },
  theme: {
    dark: false
  },
  themes: {
    light: {
      primary: "#4682b4",
      secondary: "#b0bec5",
      accent: "#8c9eff",
      error: "#b71c1c"
    }
  }
});

// src/main.ts
var DEFAULT_SETTINGS = {
  globalIgnoreFilters: []
};
var DatabasePlugin = class extends import_obsidian5.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.instances = [];
      this.addSettingTab(new DatabasePluginSettingTab(this.app, this));
      this.registerMarkdownCodeBlockProcessor(`databaseTable`, (src, el, context) => __async(this, null, function* () {
        let parameters = (0, import_obsidian6.parseYaml)(src);
        const div = document.createElement("div");
        const child = new import_obsidian7.MarkdownRenderChild(div);
        while (!this.app.workspace.getActiveFile()) {
          yield new Promise((resolve) => setTimeout(resolve, 50));
        }
        const app = new vue_runtime_esm_default({
          vuetify: vuetify_default,
          render: (h) => h(App_default, {
            props: {
              parameters,
              app: this.app,
              settings: this.settings,
              urlBase: this.app.vault.adapter.basePath.replaceAll("\\", "/")
            }
          })
        });
        this.instances.push(app);
        context.addChild(child);
        el.append(div);
        app.$mount(div);
        child.onunload = () => {
        };
      }));
    });
  }
  removeItemOnce(arr, value) {
    var index2 = arr.indexOf(value);
    if (index2 > -1) {
      arr.splice(index2, 1);
    }
    return arr;
  }
  onunload() {
    this.instances.forEach((i) => i.$destroy());
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var DatabasePluginSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Database settings" });
    new import_obsidian5.Setting(containerEl).setName("Global ignore list").setDesc("Put a list of regexes, one per line, to ignore some of the files").addTextArea((ta) => ta.setPlaceholder("Put regex to ignore fiels, one per line").setValue(this.plugin.settings.globalIgnoreFilters.join("\n")).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.globalIgnoreFilters = value.split("\n");
      yield this.plugin.saveSettings();
    })));
  }
};
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
